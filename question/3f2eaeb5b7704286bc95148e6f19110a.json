[
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: find_tenure_block_ids()] [Missing Validation] At lines 612-623, could TenureStartEnd::from_inventory return None for a peer who actually has valid tenure data but in an unexpected format, causing the node to miss available download sources? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: make_ibd_download_schedule()] [Schedule Starvation] At lines 636-647, could a malicious majority of peers report not having certain tenures in their availability data, causing make_ibd_download_schedule to skip those tenures entirely and prevent IBD completion? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: make_rarest_first_download_schedule()] [Rarity Manipulation] At lines 670-675, could malicious peers coordinate to report false availability for certain tenures, manipulating the rarest-first schedule to prioritize malicious blocks over legitimate ones? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: make_rarest_first_download_schedule()] [Sorting Instability] Could the sort_by at line 674 produce non-deterministic ordering when multiple tenures have the same neighbor count, causing different nodes to download in different orders and potentially diverge? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: count_available_tenure_neighbors()] [HashSet Counting] At lines 680-690, could inserting the same NeighborAddress multiple times through different tenure mappings cause count_available_tenure_neighbors to undercount available neighbors? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Schedule Clear Race] At lines 711-715, could clearing available_tenures and tenure_block_ids when tenure_download_schedule is empty cause the node to lose track of downloads in progress, leading to duplicate requests? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Early Return Exploitation] At lines 716-720, could count_available_tenure_neighbors returning a non-zero value for peers that have since disconnected prevent the node from updating its download schedule, causing starvation? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Empty Inventory Bypass] At lines 725-729, could an attacker cause all peers to report empty inventories temporarily, preventing update_available_tenures from calculating new schedules and stalling the download? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Prev Tenures Calculation] At lines 733-748, could the calculation of prev_available using saturating_sub(1) on reward_cycle produce incorrect availability data if called at reward cycle 0? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Availability Merge Conflict] At line 755, could extending available with prev_available cause key collisions if the same tenure consensus hash appears in both current and previous reward cycles, leading to incorrect peer lists? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Block ID Merge Logic] At lines 790-797, could the merge logic for tenure_block_ids incorrectly combine availability data from current and previous reward cycles if the same peer has conflicting TenureStartEnd data? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Schedule Generation Inconsistency] At lines 800-842, could the IBD and steady-state branches produce incompatible schedules when transitioning between modes, causing the node to skip or duplicate tenure downloads? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: update_available_tenures()] [Prev Schedule Extension] At lines 819-820 and 839-840, could extending prev_schedule with schedule cause tenures to be downloaded in incorrect order if prev_schedule contains higher block heights than schedule? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: find_unconfirmed_tenure_ids()] [Tenure Ordering Assumption] At lines 878-882, could mapping tenures by burn_height into a BTreeMap cause incorrect ordering if two tenures have the same burn_height but different consensus hashes, potentially selecting wrong tenures as unconfirmed? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: find_unconfirmed_tenure_ids()] [Rev Iterator Manipulation] At line 886, could iterating in reverse order miss the actual highest tenures if the BTreeMap contains duplicate burn_heights that were deduplicated during insertion? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: find_unconfirmed_tenure_ids()] [Availability Check Bypass] At lines 887-895, could checking available.get(&ch) return None for tenures that are actually available due to race conditions in availability updates, causing incorrect unconfirmed tenure selection? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: find_unconfirmed_tenure_ids()] [Return Value Confusion] At lines 902-903, could reversing highest_available and then popping cause the returned tuple to have the tenures in wrong order relative to block height, violating the documented invariant? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: need_unconfirmed_tenures()] [Burnchain Height Check] At lines 924-930, could comparing sort_tip.block_height < burnchain_height using stale burnchain data cause the function to incorrectly return false and prevent downloading critical unconfirmed tenures? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: need_unconfirmed_tenures()] [Empty Tenures Exploitation] At lines 932-940, could an attacker manipulate the system state to make wanted_tenures or prev_wanted_tenures empty, causing need_unconfirmed_tenures to incorrectly return false and stall steady-state sync? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: need_unconfirmed_tenures()] [Availability Check Logic] At lines 960-966, could the is_available_and_processed check using tenure_block_ids.iter().any() produce incorrect results if multiple peers have conflicting processed states for the same tenure? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: need_unconfirmed_tenures()] [Unconfirmed Tenure Bypass] At lines 968-984, could the is_unconfirmed check allow a third highest tenure to be skipped even if it's not available via the unconfirmed downloader, causing the node to wait indefinitely? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: need_unconfirmed_tenures()] [Early Return Logic Error] At lines 986-994, could returning false when a tenure is available but not yet processed prevent the node from transitioning to unconfirmed mode even when it's safe to do so? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: make_unconfirmed_tenure_download_schedule()] [Chain View Mismatch] At lines 1010-1015, could comparing chain_view.burn_block_hash with convo.burnchain_tip_burn_header_hash exclude peers who have valid but slightly newer burnchain views, unnecessarily limiting download sources? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: make_unconfirmed_tenure_download_schedule()] [Authentication Bypass] At lines 1016-1021, could the checks for is_authenticated() and is_outbound() exclude legitimate peers who could serve unconfirmed tenures, causing unnecessary delays in steady-state sync? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/download_state_machine.rs] [Function: make_unconfirmed_tenure_downloaders()] [Retain Logic Error] At lines 1044-1061, could the retain closure's logic of returning true when added >= count cause schedule items to be retained even when they should be processed, leading to stale schedule entries? (Medium)"
]