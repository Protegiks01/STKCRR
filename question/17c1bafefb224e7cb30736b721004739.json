[
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: linear()] [Integer Overflow] Can the multiplication (* a n) overflow when n approaches uint max and a is large, causing underestimation of costs and consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: linear()] [Integer Overflow] Can the addition (+ (* a n) b) overflow after the multiplication, wrapping to a small value and enabling DoS through underpriced operations? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: logn()] [Integer Overflow] Can the multiplication (* a (log2 n)) overflow when a is large and log2 returns a high value, causing cost underestimation? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: logn()] [Edge Case] What happens when n=0 is passed to log2 within logn - does it cause undefined behavior or return a predictable value that could be exploited? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: nlogn()] [Integer Overflow] Can the nested multiplication (* n (log2 n)) overflow before being multiplied by a, especially for large n values? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: nlogn()] [Integer Overflow] Can the final multiplication (* a (* n (log2 n))) overflow when all three values are moderately large, wrapping to zero or small values? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: nlogn()] [Integer Overflow] Can the addition (+ (* a (* n (log2 n))) b) overflow after computing n*log(n)*a, causing cost wraparound? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: runtime()] [Validation] Does the runtime helper validate that the input r is non-negative and within reasonable bounds before constructing the cost specification? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_type_annotate()] [Cost Underestimation] Is the linear cost (n * 1 + 9) sufficient to prevent DoS via deeply nested type annotations that require exponential checking? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_type_check()] [Cost Underestimation] Can an attacker craft contracts with complex type hierarchies where the linear formula (n * 113 + 1) severely underestimates actual type checking cost? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_type_lookup()] [DoS] Is the cost (n * 1 + 6) too low for type lookup operations, allowing attackers to exhaust resources with minimal fee expenditure? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_visit()] [Cost Underestimation] Why is the visit cost fixed at u1 regardless of n - can this be exploited to perform expensive AST traversals nearly free? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_bind_name()] [Integer Overflow] Can the linear calculation (n * 2 + 176) overflow for extremely long variable names, causing cost wraparound? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_check_tuple_merge()] [Cost Formula] The cost is (n * 1000 + 1000) - is this intentionally high or could it incorrectly reject valid tuple merge operations in legitimate contracts? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_check_tuple_cons()] [Complexity Mismatch] Does the nlogn formula accurately reflect tuple construction costs, or could quadratic-time operations be undercharged with this complexity class? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_lookup_variable_depth()] [Complexity Mismatch] Is nlogn the correct complexity for variable depth lookup, or should it be linear/quadratic based on scope chain traversal? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_ast_parse()] [Integer Overflow] Can the linear formula (n * 172 + 287441) overflow when n represents the size of a maximum-size contract, causing cost underestimation? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_ast_cycle_detection()] [Cost Underestimation] Is linear cost (n * 141 + 72) sufficient for cycle detection, or can carefully crafted graphs cause exponential-time execution with linear charges? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_storage()] [Missing Validation] Are the read_count and write_count values (both u1) always correct for storage operations, or can some operations perform multiple reads/writes? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_storage()] [Integer Overflow] Can write_length calculation (n * 1 + 1) overflow for maximum-size storage values, causing incorrect I/O accounting? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_use_trait_entry()] [I/O Accounting] Does read_length formula (n * 1 + 1) correctly account for trait entry size, or can fragmented traits bypass this cost? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_get_function_entry()] [Cost Underestimation] Is the runtime cost (n * 81 + 1303) sufficient to prevent DoS via repeated function entry lookups? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_analysis_fetch_contract_entry()] [Cost Formula] The formula (n * 1000 + 1000) seems arbitrary - is this based on empirical measurements or could it be significantly off? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_lookup_variable_depth()] [Consensus Divergence] If depth lookup uses nlogn in analysis but linear here (n * 2 + 14), can this cause blocks to be accepted during execution but rejected during analysis? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_lookup_variable_size()] [Cost Underestimation] Is the cost (n * 2 + 1) sufficient for variable size lookup, or can attackers construct large variables that exceed this estimate? (High)"
]