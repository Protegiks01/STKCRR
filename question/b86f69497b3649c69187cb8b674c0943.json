[
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: has_ith_block()] [Integer Overflow] Can an attacker provide a block_height value near u64::MAX such that the calculation `sortition_height = block_height - self.first_block_height` overflows, potentially causing the function to incorrectly return false for valid blocks or access wrong bitmap indices? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: has_ith_block()] [Off-by-One Error] In the bit index calculation `bit = sortition_height % 8` and array access at line 108-110, can an attacker craft a block_height that causes the byte index calculation `idx = (sortition_height / 8) as usize` to point to an incorrect position, leading to wrong availability information being returned? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: has_ith_microblock_stream()] [Consensus Divergence] If has_ith_microblock_stream() returns true for a height where no microblock stream actually exists due to bitmap corruption or integer overflow in the index calculation at lines 122-123, could this cause nodes to incorrectly believe microblocks are available and diverge from consensus when they fail to download them? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: has_ith_anchor_block()] [Integer Underflow] At line 134, the condition checks `if self.num_reward_cycles <= reward_cycle` before accessing the bitmap. Can an attacker exploit edge cases where num_reward_cycles is 0 and reward_cycle is 0, causing the boundary check to fail and potentially accessing uninitialized bitmap data? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [Integer Overflow] At line 162, the assertion `assert!(block_height >= self.first_block_height)` is used, but the subtraction `sortition_height = block_height - self.first_block_height` on line 162 is performed without checked arithmetic. If block_height is exactly self.first_block_height, could this lead to incorrect calculations in the loop starting at line 175? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [Integer Overflow] In the loop at lines 175-215, the calculation `insert_index += 1` at line 214 increments without overflow checking. If bitlen is u64::MAX or near it, and this loop executes that many times, could insert_index overflow and wrap around, causing bitmap corruption by overwriting earlier entries? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [Array Bounds] At lines 183-188, the code resizes block_inv and microblocks_inv vectors based on set_idx. If an attacker sends a crafted bitlen value causing set_idx to be extremely large, could this trigger excessive memory allocation leading to OOM DoS, or could the resize operation fail silently causing subsequent indexing at lines 191 and 196 to panic? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [Consensus Divergence] At line 197, when clear_bits is true, the code clears bits with `self.block_inv[set_idx] &= !(1 << set_bit)`. If an attacker can repeatedly call this with clear_bits=true for valid blocks that exist, could they cause the node to forget about available blocks and diverge from peers who maintain correct availability state? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [State Corruption] The function updates num_sortitions at line 164-168 to the maximum of current and new value. If an attacker sends a BlocksInv with bitlen causing `sortition_height + bitlen` to overflow u64, could this set num_sortitions to a wrapped-around small value, truncating the known sortition range and causing loss of block availability information? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [Incorrect Counter] At lines 191-194, the code increments new_blocks counter when a bit is newly set. However, if the vector resize at line 184 initializes new bytes to 0, and then immediately a bit is set, this is counted as 'new' even if it represents unknown state rather than newly discovered blocks. Could this cause incorrect reporting of learned data to the inv sync state machine? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_blocks_inv()] [Assertion Failure] At lines 219-220, assertions check that `insert_index / 8 <= self.block_inv.len() as u64`. If the division rounds down and the actual required size is one byte more due to remaining bits, could this assertion fail incorrectly, or conversely, could it pass when memory corruption has occurred? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: truncate_block_inventories()] [Integer Arithmetic] At line 230, `highest_agreed_block_height = burnchain.reward_cycle_to_block_height(reward_cycle)` converts reward cycle to height. If reward_cycle is at the boundary (0 or max), could this return an unexpected height value that causes the subsequent check at line 232-235 to fail the assertion or calculate incorrect num_bits at line 239-240? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: truncate_block_inventories()] [State Corruption] At lines 239-240, num_bits is calculated as `self.first_block_height + self.num_sortitions - highest_agreed_block_height`. If num_sortitions was previously corrupted to be very large, could this calculation overflow and wrap to a small value, causing only a small portion of the invalid inventory to be cleared instead of the full range? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: truncate_block_inventories()] [Memory Allocation] At lines 241-244, a zeros vector is allocated with capacity `(num_bits / 8 + 1)`. If num_bits is u64::MAX, this calculation could overflow usize on 32-bit systems or allocate massive memory on 64-bit systems. Could an attacker trigger this to cause OOM DoS? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: truncate_block_inventories()] [Incorrect Truncation] After calling merge_blocks_inv with zeros at line 252-258, line 259 manually sets `self.num_sortitions = highest_agreed_block_height - self.first_block_height`. If merge_blocks_inv had side effects that set num_sortitions differently, could this create an inconsistency between the bitmap length and num_sortitions, causing has_ith_block to return incorrect results? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: truncate_pox_inventory()] [Integer Underflow] At line 279, `num_bits = self.num_reward_cycles - reward_cycle` is calculated when `reward_cycle < self.num_reward_cycles`. If both values are very large and close together, could this subtraction produce an unexpectedly small num_bits, failing to clear all the invalid PoX bits? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: truncate_pox_inventory()] [State Inconsistency] At line 285, truncate_pox_inventory calls merge_pox_inv which may have side effects including calling truncate_block_inventories. At line 287, num_reward_cycles is then manually decremented. Could this sequence create a race condition or inconsistent state if merge_pox_inv's internal calls modify num_reward_cycles independently? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_pox_inv()] [Recursive Truncation] At lines 345-347, if a PoX bit flips from 0 to 1, truncate_block_inventories is called for that reward cycle. If the truncation itself triggers state changes that cause more PoX bits to flip, could this create an infinite recursion or cascade that corrupts the entire inventory state? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_pox_inv()] [Integer Overflow] At line 307, num_reward_cycles is updated to `max(self.num_reward_cycles, reward_cycle + bitlen)`. If reward_cycle and bitlen are both large values near u64::MAX/2, could their addition overflow, causing num_reward_cycles to be set to a small wrapped value and losing track of known reward cycles? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_pox_inv()] [Array Bounds] At lines 324-326, pox_inv vector is resized based on set_idx. Similar to merge_blocks_inv, if an attacker provides a malicious bitlen causing set_idx to be enormous, could this cause OOM DoS or subsequent indexing at line 336 to panic? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_pox_inv()] [Consensus Divergence] When clear_bits is true at line 305, the function clears PoX bits at line 339 with `self.pox_inv[set_idx] &= !(1 << set_bit)`. If a node incorrectly clears a PoX anchor block bit that should be set, and this disagreement with the actual PoX fork causes the node to accept blocks on an invalid fork, could this lead to consensus divergence? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: merge_pox_inv()] [State Corruption] At lines 328-334, when a new PoX anchor block is learned (bit flips from 0 to 1), reward_cycle_flipped is set to insert_index. If multiple bits flip in a single call, only the first is recorded. Could this cause the truncate_block_inventories call at line 346 to truncate at the wrong reward cycle, leaving some invalid block inventories uncleared? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: set_block_bit()] [State Consistency] This function calls merge_blocks_inv with a single-bit vector [0x01] for blocks at line 360. If block_height is less than first_block_height, merge_blocks_inv will assert-fail. However, there's no pre-check here. Could a caller pass an invalid block_height causing a panic and node crash? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: set_microblocks_bit()] [Incorrect Bitmap] At line 368, this sets a microblock bit by passing vec![0x01] to the microblocks parameter but vec![0x00] to blocks. If merge_blocks_inv's clear_bits parameter (false here) has unexpected interactions, could this inadvertently clear a block bit when setting a microblock bit? (Low)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: clear_block_bit()] [State Corruption] At line 375, clear_block_bit calls merge_blocks_inv with clear_bits=true and vectors [0x01], [0x00]. The logic in merge_blocks_inv will clear the block bit but not touch the microblock bit. However, if the microblock bit was set for this height, leaving it set while clearing the block bit could represent an invalid state where microblocks exist without an anchor block. Could this cause consensus issues? (Medium)"
]