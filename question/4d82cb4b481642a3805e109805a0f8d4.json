[
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_default_to()] [Fixed Cost] Returns u287. Shouldn't this depend on the size of the default value being used? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_unwrap_ret(), cost_unwrap_err_or_ret()] [Cost Parity] Both return u339. Are these operations truly identical in cost? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_is_okay(), cost_is_none(), cost_is_err(), cost_is_some()] [Fixed Cost] All return u287. Are type checks truly identical regardless of checked value size? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_unwrap(), cost_unwrap_err()] [Fixed Cost] Both return u287. Should unwrapping depend on wrapped value size? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_try_ret()] [Fixed Cost] Returns u287. Doesn't account for early return logic complexity or unwrapped value size? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_match()] [Fixed Cost] Returns u287. Shouldn't matching on large values cost more than small values? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_or()] [Linear Cost] Uses linear(n, u3, u149). What does n represent - number of arguments? Could many-argument OR expressions overflow this cost? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_and()] [Cost Parity] Identical to cost_or with linear(n, u3, u149). Is this appropriate, or should short-circuit evaluation affect costs differently? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_append()] [Linear Cost] Uses linear(n, u71, u176). Does n represent total size after append? Could appending to very large lists overflow the multiplication (* u71 n)? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_concat()] [Linear Cost] Uses linear(n, u75, u244). If n is total concatenated size, could large concatenations overflow or is the coefficient u75 too low? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_as_max_len()] [Fixed Cost] Returns u475. Type casting to max-len should depend on actual length checking - is this constant sufficient? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_contract_call()] [Fixed Cost] Returns u153. Contract calls can be expensive with argument passing and context switching - is this severely undercharged? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_contract_of()] [Fixed Cost] Returns u13400. This is expensive, but why is it constant? Doesn't it depend on contract size or complexity? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_principal_of()] [Fixed Cost] Returns u999. Deriving principal from public key is expensive - is this constant appropriate for all cases? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_at_block()] [I/O Costs] Has read_count u1, read_length u1, runtime u210. If accessing historical blocks requires reading large state, are these I/O costs accurate? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_load_contract()] [Read Count] Has read_count u3 with comment 'associated metadata loads'. If contract size varies dramatically, should read_length depend more heavily on n? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_load_contract()] [Linear Runtime] Uses linear(n, u1, u157). The coefficient u1 seems very low - can loading huge contracts be exploited? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_create_map()] [Write Costs] Has write_count u1, write_length linear(n, u1, u1). If n is very large, could the write_length overflow or mismatch actual writes? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_create_var()] [Write Count] Has write_count u2. Why two writes for creating one variable? Is this accounting correct or could it be exploited? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_create_nft()] [Linear Runtime] Uses linear(n, u1, u1610). What does n represent for NFT creation - token ID size? Could this undercharge complex NFT creation? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_create_ft()] [Fixed Cost] Returns fixed runtime u1972, write_count u2. Why doesn't fungible token creation scale with any parameter? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_fetch_entry()] [Linear Runtime] Uses linear(n, u1, u1539). Coefficient u1 is very low - can fetching large map entries be undercharged for DoS? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_set_entry()] [Write Cost] Has write_count u1, read_count u1, write_length linear(n, u1, u1). Does this properly account for both reading old value and writing new? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_set_entry()] [Runtime Formula] Uses linear(n, u4, u2204). Could (* u4 n) overflow for very large entries, wrapping to undercharge expensive map updates? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2.clar] [Function: cost_fetch_var()] [Linear Cost] Uses linear(n, u1, u543). Is coefficient u1 sufficient for variable fetching, or could large variables be fetched too cheaply? (Low)"
]