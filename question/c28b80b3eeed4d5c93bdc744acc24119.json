[
  "[File: stackslib/src/net/httpcore.rs] [Function: decode_request_path()] [Path Traversal] Can an attacker craft a URL-encoded path with '../' sequences that bypass path validation after percent_decode_str() to access unintended endpoints, potentially exposing sensitive chain state data? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: decode_request_path()] [Input Validation] Does the function reject paths containing null bytes (%00) after URL decoding, or could an attacker use null byte injection to truncate path matching and bypass request handler routing? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: decode_request_path()] [DoS] Can an attacker send extremely long URL-encoded paths (e.g., thousands of '%XX' sequences) that cause excessive CPU consumption during percent_decode_str() decoding, leading to node unresponsiveness? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: decode_request_path()] [Error Handling] If Url::parse() fails with a malformed URL, does the error message leak any internal path information that could aid reconnaissance of the node's endpoint structure? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: decode_request_path()] [Unicode Handling] Can an attacker use Unicode normalization attacks (e.g., different representations of the same character) after UTF-8 decoding to bypass path-based access controls or regex matching in request handlers? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: decode_request_path()] [Query String Injection] If the query string contains URL-encoded '?' or '#' characters, can these be used to inject fake query parameters that bypass validation or cause misrouting after decode_utf8()? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: TipRequest::from()] [Type Confusion] If an attacker provides a hex string that is 64 characters but not a valid StacksBlockId, does StacksBlockId::from_hex() return an error, or does it succeed with corrupted data leading to incorrect tip queries? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: TipRequest::from()] [Default Fallback] When TipRequest::from() falls back to UseLatestAnchoredTip for invalid input, does this allow attackers to bypass specific tip requests by providing malformed tip= parameters, potentially causing inconsistent reads? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: TipRequest::from()] [Case Sensitivity] Is the comparison s == \\",
  "[File: stackslib/src/net/httpcore.rs] [Function: find_response_handler()] [Handler Ambiguity] If multiple regex patterns in request_handlers match the same request_path, does the function return the first match? Can an attacker exploit registration order to hit unintended handlers with overlapping patterns? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: find_response_handler()] [Regex DoS] Can an attacker craft request paths that trigger catastrophic backtracking in regex.captures(), causing CPU exhaustion and node unresponsiveness if any handler uses complex regex patterns? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: find_response_handler()] [Verb Validation] Does the function perform case-sensitive verb matching? Can an attacker use lowercase 'get' instead of 'GET' to bypass handler selection and cause routing failures? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: find_allowed_methods()] [Method Enumeration] Does this function leak information about available endpoints by checking both strict and permissive regexes? Can attackers enumerate all possible API paths by observing which paths return 405 vs 404? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: find_allowed_methods()] [Permissive Regex Exploitation] If the permissive regex is too broad (due to make_permissive_regex() replacing capture groups with '[a-zA-Z0-9._~:@!$&\\\\'()*+,;=-]+'), can attackers trigger 405 responses for paths that should return 404, leaking endpoint existence? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: make_permissive_regex()] [Regex Bypass] Does the CAPTURE_GROUP_REGEX correctly handle all nested and complex regex patterns, or can edge cases cause the permissive regex to fail to match valid paths, incorrectly returning 404 instead of 400/405? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: make_permissive_regex()] [Fallback Safety] When replace_all() fails to create a valid regex and falls back to strict_regex.clone(), does this break the intended 400/404/405 differentiation logic, allowing invalid parameters to be treated as missing endpoints? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: try_parse_request()] [State Machine Pollution] If try_parse_request() encounters an error after iterating through multiple handlers, does it correctly call request.restart() on all touched handlers, or can partial state persist across requests? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: try_parse_request()] [400 vs 404 Logic] The logic returns 400 if verb_matched_but_params_invalid && !any_strict_match. Can an attacker carefully craft requests to trigger 400 responses for paths that should be 404, leaking information about parameter validation rules? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: try_parse_request()] [Handler Order Dependency] Does the order of request_handlers affect which error is returned (400 vs 405 vs 404)? Can registering handlers in different orders lead to inconsistent error responses for the same malformed request? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: try_parse_request()] [Verb Matching Race] If permissive_regex matches but strict regex doesn't, and verb matches, verb_matched_but_params_invalid is set. Can this flag be incorrectly set by multiple handlers, causing the wrong final error code? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: try_parse_request()] [Query String Injection] After decode_request_path() splits path and query, if query.is_empty() check is bypassed, can attackers inject empty query strings that are treated as Some(&\\",
  "[File: stackslib/src/net/httpcore.rs] [Function: try_parse_request()] [Body Size Validation] Does this function validate that body.len() matches the Content-Length header before passing body to request.try_parse_request()? Can mismatches lead to partial request processing or buffer overruns? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_contract_address()] [Address Validation] If StacksAddress::from_string() returns None for an invalid address, the function returns Http(400). Can an attacker send borderline-invalid addresses that pass from_string() but fail later in contract calls, causing state inconsistencies? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_contract_address()] [Contract Name Length] Does ContractName::try_from() enforce length limits? Can an attacker provide extremely long contract names (e.g., 1MB) that pass regex validation but cause excessive memory allocation in QualifiedContractIdentifier::new()? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_contract_address()] [Missing Capture Handling] If captures.name(address_key) returns None, the function returns Http(404, \\"
]