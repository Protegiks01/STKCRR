[
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Integer Overflow] Can an attacker provide a Content-Length header value exceeding u32::MAX (e.g., '4294967296' or larger) to cause integer overflow during parsing, potentially leading to buffer allocation issues or memory exhaustion in downstream code that uses this value? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [DoS - Resource Exhaustion] Can an attacker send a Content-Length header with maximum u32 value (4294967295) to force the node to attempt allocating ~4GB of memory for a single HTTP request body, causing memory exhaustion and node crash? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Input Validation] Does the function properly reject negative Content-Length values like '-1' or '-100', or does the u32 parsing silently fail without logging, potentially masking malicious requests? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Parsing Ambiguity] Can an attacker provide Content-Length values with leading zeros (e.g., '0000000100'), plus signs ('+100'), or whitespace ('  100  ') that might be parsed differently by different HTTP implementations, causing desynchronization attacks? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [DoS - Slow Parse] Can an attacker send Content-Length header values with extremely long digit sequences (e.g., millions of zeros) to cause expensive parsing operations that consume CPU and delay request processing? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Type Confusion] Can an attacker provide Content-Length values in hexadecimal (0x100), octal (0o100), binary (0b100), or scientific notation (1e10) that might bypass validation or be parsed inconsistently? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Silent Failure] When Content-Length parsing fails, the function returns None without logging or error details - can this silent failure mask attack attempts or make debugging production issues difficult? (Low)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Content-Type Bypass] Can an attacker craft malformed Content-Type header values that fail parsing but allow the request to proceed with a default or unvalidated content type, bypassing security checks in downstream handlers? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Injection Attack] Can an attacker inject additional MIME parameters or boundary strings into the Content-Type header (e.g., 'application/json; boundary=malicious') that get parsed and used unsafely by the HttpContentType parser? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Charset Confusion] Does the Content-Type parsing handle charset parameters correctly (e.g., 'application/json; charset=utf-16'), and could an attacker use non-UTF-8 charsets to cause deserialization failures or inject malicious data? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Host Header Injection] Can an attacker inject malicious hostnames, invalid ports, or control characters into the Host header that pass PeerHost parsing but cause issues in routing, logging, or downstream request handling? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [SSRF Vector] Can an attacker provide a Host header pointing to internal network addresses (127.0.0.1, 169.254.169.254, internal IPs) that get validated by PeerHost::parse() and used for server-side requests, enabling SSRF attacks? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Port Overflow] Can an attacker specify port numbers exceeding u16::MAX (65535) in the Host header that cause overflow or unexpected behavior in PeerHost parsing? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Unicode/IDN Attack] Can an attacker use Unicode domain names, IDN homograph attacks, or punycode in the Host header to bypass validation or redirect requests to malicious servers? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Case Sensitivity Bypass] The function uses to_lowercase() for header name matching - can an attacker exploit timing differences in the lowercase conversion or send mixed-case headers that behave differently across the codebase? (Low)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::try_from_str()] [Memory Allocation] Does calling to_string().to_lowercase() on every header allocation create temporary strings that could cause excessive memory allocation during a flood of requests with long header names? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::is_reserved()] [Header Smuggling] The is_reserved() function only checks three specific headers - can an attacker smuggle forbidden headers (e.g., Transfer-Encoding, Connection) through custom headers that aren't in the reserved list, causing HTTP request smuggling? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: HttpReservedHeader::is_reserved()] [Case Sensitivity] The is_reserved() function uses exact string matching without case normalization - can an attacker send 'Content-Length' with different casing to bypass the reserved check while still being processed elsewhere? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Constant: HTTP_PREAMBLE_MAX_ENCODED_SIZE] [DoS - Large Headers] The HTTP_PREAMBLE_MAX_ENCODED_SIZE is set to 4096 bytes - is this limit sufficient to prevent DoS attacks via extremely large header collections, and is it enforced before or after decompression/decoding? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Constant: HTTP_PREAMBLE_MAX_NUM_HEADERS] [DoS - Header Flood] The HTTP_PREAMBLE_MAX_NUM_HEADERS is set to 64 - can an attacker send exactly 64 headers with maximum allowed lengths to bypass rate limiting while still consuming excessive resources during parsing and validation? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Constant: HTTP_PREAMBLE_MAX_ENCODED_SIZE] [Insufficient Limit] Is 4096 bytes sufficient for all legitimate use cases, or could valid requests with many custom headers or long URLs be rejected, causing availability issues for legitimate users? (Low)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Constant: HTTP_PREAMBLE_MAX_NUM_HEADERS] [Resource Exhaustion] Does the limit of 64 headers account for the cost of parsing, validation, and storage of each header, or could an attacker still exhaust resources by sending 64 complex headers that require expensive processing? (Medium)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: parse_bytestream()] [Content-Type Bypass] The function checks if content_type equals HttpContentType::Bytes, but what if the preamble is maliciously crafted to have a different content_type that somehow gets coerced to Bytes downstream, bypassing this validation? (High)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: parse_bytestream()] [Deserialization Attack] The function uses read_next() with StacksMessageCodec to deserialize arbitrary types - can an attacker craft malicious byte sequences that exploit vulnerabilities in the codec implementation, causing crashes, memory corruption, or arbitrary code execution? (Critical)",
  "[File: stacks-core/stackslib/src/net/http/common.rs] [Function: parse_bytestream()] [Length Prefix Attack] The comment mentions 'first 4 bytes are a big-endian length prefix' for SIP-003 - can an attacker provide a length prefix that doesn't match the actual data length, causing buffer overruns, underruns, or infinite loops in read_next()? (Critical)"
]