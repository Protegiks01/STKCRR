[
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: MinerReward::total()] [Integer Overflow] Can the addition of coinbase + tx_fees_anchored + tx_fees_streamed_produced + tx_fees_streamed_confirmed overflow u128, causing reward calculation underflow and incorrect balance updates that diverge consensus? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: MinerPaymentSchedule::streamed_tx_fees_confirmed()] [Integer Overflow] Can tx_fees_streamed * 3 overflow u128 before the division by 5, causing incorrect fee distribution that differs across nodes? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: MinerPaymentSchedule::streamed_tx_fees_produced()] [Integer Overflow] Can tx_fees_streamed * 2 overflow u128 before division, resulting in incorrect producer fees and consensus divergence on reward amounts? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: calculate_miner_reward()] [Integer Overflow] In the user burn support calculation loop, can total_user checked_add overflow when malicious miners collude to submit extremely high user_support.burnchain_commit_burn values? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: calculate_miner_reward()] [Integer Overflow] Can total_other checked_add overflow in the else branch when calculating user burn support rewards with many colluding users? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: calculate_miner_reward()] [Integer Overflow] Can other_burn_total.checked_add(this_burn_total) fail when both values are near u128::MAX, causing a panic that halts block processing? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: calculate_miner_reward()] [Integer Overflow] Can participant.coinbase.checked_mul(this_burn_total) overflow when coinbase and burn amounts are both large, causing a panic mid-reward-calculation? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: update_account_nonce()] [Integer Overflow] Can cur_nonce.checked_add(1) fail when cur_nonce == u64::MAX, causing the node to panic with 'OUT OF NONCES' and preventing further transactions from that account? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: poison_microblock_commission()] [Integer Overflow] Can coinbase * POISON_MICROBLOCK_COMMISSION_FRACTION overflow u128 before division, resulting in incorrect poison reporter rewards? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: FromRow<MinerPaymentSchedule>] [Integer Parsing] Can coinbase_text.parse::<u128>() succeed with values exceeding total STX supply, allowing impossible reward amounts to be scheduled? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: FromRow<MinerReward>] [Integer Parsing] Can coinbase_text, tx_fees_anchored_text, tx_fees_streamed_confirmed_text, or tx_fees_streamed_produced_text parse to u128 values that exceed the theoretical maximum STX amount, bypassing economic constraints? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: calculate_miner_reward()] [Division by Zero] When burn_total equals 0 in shadow blocks, the code replaces it with 1, but can this lead to incorrect proportional rewards if this_burn_total is also modified inconsistently? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: MinerPaymentSchedule::streamed_tx_fees_confirmed()] [Integer Precision Loss] Does the division (tx_fees_streamed * 3) / 5 lose precision due to integer division, and can this cause cumulative discrepancies in fee totals that violate conservation of STX? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: MinerPaymentSchedule::streamed_tx_fees_produced()] [Integer Precision Loss] Does (tx_fees_streamed * 2) / 5 lose fractional microSTX due to integer division, and can accumulated losses across many blocks be exploited? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: calculate_miner_reward()] [Integer Precision Loss] Can the integer division participant.coinbase * this_burn_total / burn_total systematically round down and destroy STX tokens through accumulated rounding errors? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: account_debit()] [Balance Validation] The function panics if insufficient funds exist rather than returning an error - can a race condition or reorg cause the panic condition to be reached unexpectedly, halting consensus? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: account_debit()] [Transaction Ordering] If snapshot.can_transfer() passes but snapshot.debit() fails due to concurrent state changes, does the panic in the unwrap_or_else preserve consensus safety? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: account_credit()] [Balance Overflow] Can snapshot.credit(amount as u128) cause balance overflow if an account receives credits from multiple sources in the same block without bounds checking? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: account_genesis_credit()] [Genesis State] Can malicious genesis allocations use extremely large amount values to overflow balances or violate the total STX supply cap? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: get_account()] [Error Handling] The function panics on ClarityError rather than returning an error - can this be triggered by malformed database state to DOS the node? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: get_nonce()] [Error Handling] The unwrap_or_else panics on failure to query nonce - can this be exploited to halt block validation if the database is in an inconsistent state? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: account_debit()] [Type Conversion] The conversion amount as u128 from u64 is safe, but does calling code ensure amount fits in u64 to prevent unintended truncation? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: account_credit()] [Type Conversion] Similar u64 to u128 conversion - can callers pass values that should be larger than u64::MAX but get truncated? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: update_account_nonce()] [Nonce Consistency] If the nonce update succeeds but the transaction later fails, can the nonce increment persist, allowing nonce gaps that enable transaction replay? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/db/accounts.rs] [Function: update_account_nonce()] [Race Condition] If two transactions with the same nonce are processed concurrently in different threads, can both update_account_nonce calls succeed, causing double-spend? (Critical)"
]