[
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_1ADD/OP_1SUB] OP_1ADD (0x8B) and OP_1SUB (0x8C) increment/decrement the top stack element in place (lines 322-324) - do these operations correctly handle integer overflow/underflow, and what happens when incrementing the maximum representable value or decrementing zero? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_NEGATE] OP_NEGATE (0x8F) multiplies the top stack item by -1 in place (line 330) - does this correctly handle the negation of zero, and could edge cases in two's complement representation cause incorrect negation results? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_ABS] OP_ABS (0x90) takes the absolute value of the top stack item in place (line 332) - does this handle negative zero correctly, and could the absolute value of the minimum representable negative number cause overflow? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_NOT/OP_0NOTEQUAL] OP_NOT (0x91) maps 0 to 1 and everything else to 0, while OP_0NOTEQUAL (0x92) maps 0 to 0 and everything else to 1 (lines 334-336) - could these opcodes be confused with logical NOT operations, and do they correctly handle the Bitcoin script number representation where empty array equals zero? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_ADD/OP_SUB] OP_ADD (0x93) and OP_SUB (0x94) perform arithmetic (lines 338-340) - do these operations correctly handle integer overflow/underflow according to Bitcoin consensus rules, and could overflow cause wraparound behavior or script failure? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_BOOLAND/OP_BOOLOR] OP_BOOLAND (0x9A) and OP_BOOLOR (0x9B) perform boolean logic (lines 352-354) - do these correctly treat zero (empty byte array and 0x00) as false and all other values as true, matching Bitcoin's boolean semantics? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_EQUAL/OP_EQUALVERIFY] OP_EQUAL (0x87) and OP_EQUALVERIFY (0x88) test byte-wise equality (lines 314-316) - do these correctly handle byte array comparisons including empty arrays, and does OP_EQUALVERIFY correctly fail the script when inputs are not equal? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_NUMEQUAL/OP_NUMEQUALVERIFY] OP_NUMEQUAL (0x9C) and OP_NUMEQUALVERIFY (0x9D) test numerical equality (lines 356-358) - do these correctly parse byte arrays as Bitcoin script numbers and compare them numerically, handling negative numbers and different encodings of the same value? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_LESSTHAN/OP_GREATERTHAN] OP_LESSTHAN (0x9F), OP_GREATERTHAN (0xA0), OP_LESSTHANOREQUAL (0xA1), OP_GREATERTHANOREQUAL (0xA2) perform numeric comparisons (lines 362-368) - do these handle signed comparisons correctly, including edge cases like comparing negative numbers and handling the maximum/minimum representable values? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_MIN/OP_MAX] OP_MIN (0xA3) and OP_MAX (0xA4) return the smaller/larger of two values (lines 370-372) - do these correctly compare signed numbers, and could edge cases in number encoding cause these operations to return unexpected results? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_WITHIN] OP_WITHIN (0xA5) checks if 'the top is >= the second and < the third' (line 374) - does this implement the correct range check (inclusive lower bound, exclusive upper bound), and could off-by-one errors in the comparison cause values to be incorrectly accepted or rejected? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - Hash Functions] OP_RIPEMD160 (0xA6), OP_SHA1 (0xA7), OP_SHA256 (0xA8), OP_HASH160 (0xA9), OP_HASH256 (0xAA) perform cryptographic hashing (lines 376-384) - do all implementations use the same hash function implementations and produce deterministic results across different platforms, or could differences in hash implementations cause consensus divergence? (Critical)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_CODESEPARATOR] OP_CODESEPARATOR (0xAB) affects signature checking by altering what script data is hashed (line 386) - is this opcode correctly handled in signature validation, and could its presence or absence in scripts cause signature validation to succeed/fail unexpectedly? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_CHECKSIG] OP_CHECKSIG (0xAC) and OP_CHECKSIGVERIFY (0xAD) verify ECDSA signatures (lines 388-390) - do these correctly validate secp256k1 signatures, handle DER encoding edge cases, enforce low-S values, and properly extract the public key and message being signed? (Critical)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_CHECKMULTISIG] OP_CHECKMULTISIG (0xAE) and OP_CHECKMULTISIGVERIFY (0xAF) validate M-of-N multisig (lines 392-395) - does the implementation correctly handle the off-by-one bug that requires a dummy value to be popped, validate the M and N parameters are within limits, and prevent signature reuse across different pubkeys? (Critical)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_CHECKMULTISIG Bug] The OP_CHECKMULTISIG documentation mentions 'a dummy (due to bug in reference code)' (line 392) - is this off-by-one bug consistently implemented across all nodes, and could differences in handling this bug cause consensus splits or allow attackers to craft transactions that validate differently on different nodes? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - NOP Opcodes] OP_NOP (0x61) and OP_NOP1-10 (0xB0-0xB9) are documented to do nothing (lines 235, 397-415) - could these be soft-forked to add new functionality, and would all nodes correctly classify these as NoOp until a soft fork activates? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Static: OP_CLTV/OP_CSV] OP_CLTV and OP_CSV are defined as aliases to OP_NOP2 and OP_NOP3 (lines 652-654) - do script validators check for the activation of these soft forks and correctly enforce CLTV/CSV semantics, or could scripts bypass timelock validation by using the OP_NOP2/OP_NOP3 names? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Function: classify()] [Consensus - NOP Range] The NoOp classification range 'All::OP_NOP1 as u8 <= *self as u8 && *self as u8 <= All::OP_NOP10 as u8' (line 585) includes OP_NOP2 (OP_CLTV) and OP_NOP3 (OP_CSV) - should these be excluded from the generic NoOp classification since they have special semantics after their respective soft forks activated? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [\n\n### Citations\n\n**File:** stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs (L1-719)\n```rust\n// Rust Bitcoin Library\n// Written in 2014 by\n//   Andrew Poelstra <apoelstra@wpsoftware.net>\n//\n// To the extent possible under law, the author(s) have dedicated all\n// copyright and related and neighboring rights to this software to\n// the public domain worldwide. This software is distributed without\n// any warranty.\n//\n// You should have received a copy of the CC0 Public Domain Dedication\n// along with this software.\n// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n//\n\n//! Opcodes\n//!\n//! Bitcoin's script uses a stack-based assembly language. This module defines\n//! all of the opcodes\n//!\n\n#![allow(non_camel_case_types)]\n\n// Heavy stick to translate between opcode types\nuse std::mem::transmute;\n\n#[cfg(feature ="
]