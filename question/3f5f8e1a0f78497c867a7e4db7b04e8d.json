[
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode() / c32_check_decode()] [Version Consensus] Different Stacks network types (mainnet/testnet) use different version numbers. Can an address from one network be accidentally accepted on another network if version validation is insufficient? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: double_sha256_checksum()] [Collision Resistance] With a 32-bit checksum space, birthday paradox suggests collisions after ~65k addresses. Can an attacker pre-generate a collision table to create valid addresses with matching checksums for different version/data combinations? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Malleability] Can an attacker modify the last few characters of a valid address such that it still passes checksum validation but decodes to different data, enabling transaction malleability attacks? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Prefix Enforcement] Since the 'S' prefix is stripped without validation, can addresses with other prefixes (or no prefix) be accepted by some protocol layers, causing inconsistent address validation across the network? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [DoS via Large Input] If an attacker provides an extremely long C32 string (e.g., 1MB), can the Vec allocations at lines 238 and 255 cause memory exhaustion DoS during address validation in P2P message handling? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Bit Shift Undefined Behavior] At line 194, if carry_bits becomes >= 8, the expression `current_value >> (8 - carry_bits)` would shift by 0 or negative. Does Rust's type system prevent this, or can overflow in carry_bits calculations trigger undefined behavior? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Error Path Consensus] Different error types (InvalidCrockford32 vs BadChecksum) at lines 323, 327, 334, 354 provide different failure information. Can nodes disagree on which error to return for the same input, causing consensus issues in error handling? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address()] [Address Length Limits] What is the maximum valid address length? Can arbitrarily long data inputs create addresses that exceed protocol buffer limits in P2P messages or blockchain storage? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Checksum Preimage Resistance] Given a desired checksum value, can an attacker find data that produces that checksum faster than brute force (2^32 operations)? Does the double-SHA256 provide adequate preimage resistance for the truncated output? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Zero-Length Input] What happens when an empty string is passed to c32_decode_ascii()? Does it return Ok(vec![]) or Err? Can this inconsistency cause protocol-level issues? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Version Array Access] At line 357, `check_data[0]` assumes check_data is non-empty. The check at line 340 extends check_data with data_bytes. If both version decode and data_bytes are empty, can this cause a panic? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Maximum Input Size] What is the maximum size of input_bytes that can be safely encoded? At what point does the saturating_mul(8).div_ceil(5) calculation at line 183 saturate, and does this cause silent truncation of encoded data? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Maximum Input Length] Can an attacker provide a C32 string with length approaching usize::MAX? At line 254, would saturating_mul(5).div_ceil(8) overflow or saturate, causing incorrect buffer allocation? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [All-Zeros Input] For input_bytes = [0, 0, 0, ...], the encoding should produce \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [All-Zeros Input] For C32 input \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Single Byte Input] For a single-byte input, e.g., [0x42], does the carry bit logic correctly handle the case where the loop only executes once, and carry_bits may not reach 5? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Minimum Valid Input] What is the absolute minimum valid C32-check-encoded string? If it's version (1 char) + checksum (5 chars) = 6 chars total, can inputs of length 2-5 cause unexpected behavior despite the length check at line 326? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Exactly 6 Characters] An address \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Version 31] Version 31 is the maximum valid version. Does c32_encode correctly handle this edge case where the version character is 'Z' (the last character in C32_CHARACTERS)? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Version Extraction Overflow] After decoding the version at line 339, check_data[0] is used at line 357. If c32_decode_ascii() returns a different version value due to normalization, can this mismatch the checksum validation? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Carry Bits Initialization] carry and carry_bits are initialized to 0 at lines 185-186. For the first iteration when current_value is processed, is it possible for carry_bits to become negative if low_bits_to_take is miscalculated? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Carry Bits Upper Bound] At line 193, carry_bits = (8 + carry_bits) - 5 suggests carry_bits should be in [0,7]. Can prior iterations cause carry_bits to exceed 7, and if so, does the check at line 196 (carry_bits >= 5) correctly handle this? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Carry Value After Shift] At line 200, `carry >>= 5` reduces carry after extracting 5 bits. If carry_bits was exactly 5, carry becomes 0. If carry_bits was 6-7, carry should retain 1-2 bits. Is this logic correct for all cases? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Carry Accumulation Overflow] At line 260, carry is u16 and accumulates `(*current_5bit as u16) << carry_bits`. The maximum value is 31 << 10 = 31744 (if carry_bits somehow reaches 10). Can carry_bits exceed 9, causing carry to overflow u16::MAX? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Carry Bits After Extraction] At line 265, `carry_bits -= 8` occurs after extracting 8 bits. If carry_bits was exactly 8, it becomes 0. If it was 9-12, it becomes 1-4. Is there an upper bound check to prevent carry_bits from growing unbounded? (Medium)"
]