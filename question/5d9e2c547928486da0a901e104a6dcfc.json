[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: linear()] [Integer Overflow] Can the multiplication (* a n) in the linear cost function overflow when n approaches uint max, causing cost underestimation and allowing attackers to execute expensive operations for minimal cost, leading to DoS? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: linear()] [Integer Overflow] Can the addition (+ (* a n) b) overflow after the multiplication completes, wrapping to a small value and bypassing block cost limits? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: logn()] [Division by Zero] What happens when n=0 is passed to log2(n) in the logn function? Does log2(0) cause a runtime error, return an undefined value, or could this be exploited to bypass cost accounting? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: logn()] [Integer Overflow] Can the multiplication (* a (log2 n)) overflow for large values of a when log2(n) is near its maximum, causing cost underestimation? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: nlogn()] [Integer Overflow] Can the nested multiplication (* a (* n (log2 n))) overflow in multiple stages, first in the inner (* n (log2 n)) and then in the outer multiplication, allowing massive cost underestimation? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: nlogn()] [Division by Zero] When n=0, does (* n (log2 n)) behave safely, or could the log2(0) edge case combined with multiplication by zero create undefined behavior in cost calculation? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: runtime()] [Data Structure Consistency] Are all fields in the cost specification tuple (runtime, write_length, write_count, read_count, read_length) properly initialized to u0, or could missing initializations lead to garbage values in memory cost accounting? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_type_annotate()] [Cost Underestimation] Is the linear formula (linear n u1 u9) sufficient for type annotation cost? Could an attacker craft deeply nested type annotations that require more than linear time but are charged linearly? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_type_check()] [Cost Underestimation] Does the coefficient u113 in (linear n u113 u1) accurately reflect type checking complexity, or could complex recursive types with n type nodes consume significantly more resources than charged? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_visit()] [Cost Model Error] Why does cost_analysis_visit() return a constant runtime u1 regardless of n? Could this allow attackers to perform many visits (large n) while only being charged for one unit? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_check_tuple_get()] [Cost Model Inconsistency] Is the logarithmic cost (logn n u1 u2) correct for tuple get operations, or should this be constant time O(1) since tuple access by key should not depend on tuple size? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_check_tuple_merge()] [Cost Underestimation] Is the nlogn cost model (nlogn n u45 u49) sufficient for tuple merge? Could merging large tuples with many overlapping keys require quadratic time due to key comparison overhead? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_check_tuple_cons()] [Cost Model Inconsistency] Why do cost_analysis_check_tuple_cons (nlogn n u3 u5) and cost_tuple_cons (nlogn n u10 u1876) use the same nlogn model but drastically different coefficients? Could this inconsistency indicate an error in one of them? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_lookup_variable_depth()] [Cost Underestimation] Is the nlogn model (nlogn n u1 u12) correct for variable lookup by depth, or could pathological variable shadowing patterns with depth n require more than n*log(n) lookups? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ast_parse()] [DoS Vector] Can an attacker craft a maximally complex AST with n nodes where the linear cost (linear n u27 u81) severely undercharges, allowing parsing of gigantic malformed contracts to DoS validators? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ast_cycle_detection()] [Algorithm Complexity Mismatch] Does cycle detection truly run in O(n) time as the linear formula (linear n u141 u72) suggests, or does the graph traversal algorithm actually require O(nÂ²) or O(n*edges) time for dense graphs? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_storage()] [Read/Write Accounting Error] Are read_count: u1 and read_length: u1 correct for storage analysis? Could large contracts with n storage operations only be charged for a single read operation? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_use_trait_entry()] [Cost Underestimation] Does the linear runtime (linear n u9 u698) with read_length (linear n u1 u1) properly account for trait resolution? Could complex trait hierarchies consume more resources than charged? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_fetch_contract_entry()] [I/O Cost Error] With read_count: u1 but read_length: (linear n u1 u1), could fetching a contract with size n require multiple read operations that are not reflected in read_count? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_analysis_get_function_entry()] [Cost Model Error] Is the coefficient u78 in (linear n u78 u1307) justified for function entry retrieval, or was this empirically derived and potentially vulnerable to adversarial inputs? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_lookup_variable_depth()] [Cost Inconsistency] Why does cost_lookup_variable_depth use (linear n u1 u1) while cost_analysis_lookup_variable_depth uses (nlogn n u1 u12)? Could this discrepancy cause consensus divergence between analysis and runtime phases? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_lookup_variable_size()] [Cost Underestimation] Is (linear n u2 u1) sufficient to account for looking up variables of size n bytes? Could this undercharge for deserializing large variable values? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_lookup_function()] [Cost Model Error] Why is function lookup a constant u16 regardless of function name length or lookup complexity? Could this be exploited with extremely long function names? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_bind_name()] [Cost Model Error] Is the constant cost u216 for name binding appropriate regardless of name length n? Could extremely long variable names consume more stack/memory than accounted for? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_inner_type_check_cost()] [Cost Underestimation] Does (linear n u2 u5) adequately charge for inner type checking? Could nested type checks with n levels require exponential rather than linear time? (High)"
]