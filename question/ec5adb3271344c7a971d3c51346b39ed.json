[
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_downloader()] [Silent Failure] In clear_downloader() lines 167-169, if self.downloaders.get_mut(index) returns None, an error is logged but the peer remains removed from self.peers, creating a desync. Could this cause the peer to be permanently unavailable for new downloads? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Schedule Front Access] In make_tenure_downloaders() line 374, schedule.front() is used to peek at the next tenure without removing it, but pop_front() is called in multiple places. If another thread modifies the schedule between front() and pop_front(), could this cause incorrect tenure selection? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Schedule Deque Exhaustion] In make_tenure_downloaders(), if the schedule VecDeque is drained to empty but the loop at line 373 continues checking num_scheduled_downloaders() < count, could the loop call schedule.front() on an empty deque, causing unexpected None returns? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Time Comparison Bug] In make_tenure_downloaders() line 394, the comparison is get_epoch_time_secs() < *self.deprioritized_peers.get(&naddr).unwrap_or(&0). If get_epoch_time_secs() returns 0 due to a clock reset, all deprioritized peers would become immediately available. Could this bypass rate limiting? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Deprioritization Leak] In make_tenure_downloaders() lines 394-400, if a peer is deprioritized, the function continues without removing the peer from neighbors or the naddr variable. Could this cause the same deprioritized peer to be checked repeatedly in the loop, wasting CPU? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Missing Signature Verification] In make_tenure_downloaders() lines 482-492, NakamotoTenureDownloader::new() is called with tenure_info data from peers. If tenure_info contains forged start_block_id or end_block_id, and these are not validated before downloader creation, could this lead to downloading and accepting invalid blocks? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Block Validation Bypass] In run() lines 610-634, handle_next_download_response() returns blocks that are directly inserted into new_blocks at line 641 without additional validation. If the downloader's validation is insufficient, could malformed or consensus-invalid blocks be accepted? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Tenure Boundary Validation] In run(), when blocks are returned for a tenure, there is no check that the blocks actually form a contiguous chain from start_block to end_block. Could an attacker provide blocks with gaps or incorrect parent relationships, causing chainstate corruption? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Unbounded Downloader Growth] In make_tenure_downloaders(), new downloaders are continuously added to self.downloaders without an upper bound check. If an attacker floods the schedule with many unique tenures, could this cause unbounded growth of the downloaders Vec, leading to memory exhaustion? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloader()] [Vec Growth Without Compaction] In add_downloader() line 144, self.downloaders.push(Some(downloader)) appends to the Vec without ever compacting or removing None entries from the middle. Could repeated additions and removals cause the Vec to grow indefinitely with sparse None slots? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Struct: NakamotoTenureDownloaderSet] [HashMap Growth] The attempted_tenures and attempt_failed_tenures HashMaps at lines 76-78 accumulate entries for every tenure ever attempted. If an attacker causes many tenure downloads to fail, could these HashMaps grow unboundedly without cleanup? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Struct: NakamotoTenureDownloaderSet] [Deprioritization Map Growth] The deprioritized_peers HashMap at lines 81 never removes expired entries (peers whose deprioritization time has passed). Could this HashMap grow indefinitely as new peers are deprioritized, causing memory exhaustion? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: try_resume_peer()] [Peer Stealing] In try_resume_peer() lines 268-269, a new peer is assigned to a downloader by updating downloader.naddr and inserting into self.peers. If the downloader already had a previous peer assigned (which was cleared), could this cause the previous peer's work to be attributed to the new peer? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: try_resume_peer()] [Idle State Assumption] In try_resume_peer() line 261, only downloaders with downloader.idle == true are considered for peer assignment. If a downloader is blocked waiting for chainstate data but not marked as idle, could it be starved of a peer assignment indefinitely? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Response Ordering] In run() line 599, neighbor_rpc.collect_replies(network) returns responses in an arbitrary order. If the order matters for tenure block sequence validation, could out-of-order processing cause blocks to be rejected or accepted incorrectly? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Response Timeout Handling] In run(), there is no explicit timeout handling for downloaders that have sent requests but not received responses. Could a stalled peer cause a downloader to remain in inflight state indefinitely, blocking other tenures that depend on it? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Partial Response Handling] In run() line 611, if handle_next_download_response() returns Ok(None), the downloader remains active but no blocks are added to new_blocks. If this happens repeatedly, could the downloader remain in a limbo state without making progress? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Dead Peer Detection Timing] In run() lines 584-589 and 662-667, dead/broken peers are checked twice. If a peer becomes dead after the first check but before response handling, could its response still be processed, potentially from a malicious source? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Broken Peer State Persistence] In run(), when a peer is marked as dead or broken, its downloader is cleared, but the partial download state is lost. If the tenure was nearly complete, could this waste resources by forcing a full re-download from another peer? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Unconfirmed Tenure Handling] In run() lines 643-648, if downloader.is_tenure_unconfirmed is true, only a debug log is emitted. Could unconfirmed tenures be processed differently by the caller, causing consensus divergence if some nodes treat them as confirmed? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Tenure Finalization Check] In run() lines 642-658, when a downloader completes, it is marked finished and added to completed_tenures. If the blocks in new_blocks have not been validated or stored successfully, could this cause completed_tenures to contain tenures with missing or invalid data? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Chainstate Lock Contention] In run() lines 541-548, try_advance_from_chainstate() is called with &mut StacksChainState. If multiple downloaders try to advance concurrently, could this cause lock contention or race conditions in chainstate access? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Chainstate Inconsistency] In run(), if try_advance_from_chainstate() fails for a downloader, the downloader continues to send requests at line 554. Could this cause requests for blocks that are not yet ready to be processed, leading to out-of-order block storage? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: find_new_tenure_start_blocks()] [Block Clone Overhead] In find_new_tenure_start_blocks() line 329, block.clone() is called for every tenure start block. If NakamotoBlock is large, could this cause significant memory overhead, especially if multiple downloaders have the same start block? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloader()] [Peer Clone] In add_downloader() line 145, naddr.clone() is stored in self.peers. If NeighborAddress contains large data structures, could repeated cloning cause memory exhaustion during high peer churn? (Low)"
]