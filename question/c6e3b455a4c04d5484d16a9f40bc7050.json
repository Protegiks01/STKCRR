[
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloader()] [Index Out of Bounds] In add_downloader(), if self.peers.get(&naddr) returns an index that is >= self.downloaders.len() due to a race condition or previous corruption, could this cause an out-of-bounds access when calling self.downloaders.get_mut(*idx), leading to a panic or undefined behavior? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloader()] [State Inconsistency] In add_downloader() lines 136-142, if the peer already exists in self.peers but the corresponding index points to a None slot in self.downloaders, the new downloader is assigned but could this create a state where the same peer is assigned to multiple downloaders through subsequent calls? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloader()] [Integer Overflow] In add_downloader() line 145, when computing self.downloaders.len() - 1 as the index to store in self.peers, if self.downloaders is empty after a push, could this result in an underflow (wrapping to usize::MAX) when stored as an index? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: has_downloader()] [Index Validation] In has_downloader() lines 150-158, if self.peers contains a stale index that exceeds self.downloaders.len() due to previous vec truncation or corruption, could this return false positives/negatives about downloader existence, leading to duplicate downloads or skipped tenures? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_downloader()] [State Desync] In clear_downloader() lines 161-170, the function removes the peer from self.peers but only sets the downloader slot to None. If another thread or code path still holds the old index value, could this lead to use-after-free-style bugs where the wrong downloader is accessed? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_downloader()] [Resource Leak] In clear_downloader(), after setting the downloader to None at line 166, the Vec slot remains allocated but unused. If an attacker can repeatedly trigger peer removals without cleanup, could this lead to unbounded memory growth in the downloaders Vec? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: try_resume_peer()] [State Machine Bypass] In try_resume_peer() lines 244-273, if a peer is already bound to a downloader (lines 246-256) but that downloader is in a completed state, the function returns true without checking downloader.is_done(). Could this prevent the peer from being reassigned to new work, causing download stalls? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: try_resume_peer()] [Priority Inversion] In try_resume_peer() lines 257-271, the first idle downloader found is assigned to the peer. If a critical high-priority tenure is waiting in a later position while a low-priority tenure is idle at an earlier index, could this create indefinite starvation of important downloads? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: try_resume_peer()] [Peer Reassignment Bug] In try_resume_peer() line 268, downloader.naddr is updated to the new peer, but if the downloader already had a partially completed download from a different peer, could this cause attribution errors or incomplete state validation when the download completes? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_available_peers()] [Race Condition] In clear_available_peers() lines 277-301, the function iterates over self.peers while potentially modifying it through idled.push(). If another thread modifies self.peers during iteration, could this cause the removal loop at lines 298-300 to skip peers or remove wrong entries? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_available_peers()] [Index Staleness] In clear_available_peers() line 280, when checking self.downloaders.get(*i), if the index i is stale due to previous Vec modifications, the function treats it as unreachable and removes the peer. Could this incorrectly remove active peers if the Vec has been reorganized? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_finished_downloaders()] [Incomplete Cleanup] In clear_finished_downloaders() lines 305-316, downloaders are set to None but their indices in the peers HashMap remain until clear_available_peers() is called. If the caller forgets to call clear_available_peers(), could this leave peers bound to null downloaders indefinitely? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: clear_finished_downloaders()] [Double Completion] In clear_finished_downloaders(), if a downloader's is_done() transiently returns true then false due to state changes, could the downloader be cleared prematurely, causing partial tenure data to be lost? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Schedule Manipulation] In make_tenure_downloaders() lines 374-497, if schedule.pop_front() is called after early returns (e.g., lines 380, 386, 391, 406, 423, 436, 447, 458), but before the downloader is actually created, could an attacker cause the same tenure to be skipped permanently by triggering these conditions repeatedly? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Deprioritization Bypass] In make_tenure_downloaders() lines 394-400, the deprioritization check compares get_epoch_time_secs() < deprioritized_peers.get(&naddr), but uses continue without removing the peer from neighbors. Could an attacker with a deprioritized peer monopolize the neighbors list, preventing other peers from being tried? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Integer Overflow] In make_tenure_downloaders() lines 462-464, attempt_count is incremented using saturating_add(1). If attempt_count reaches u64::MAX and saturates, could this prevent accurate attempt tracking and allow infinite retries without proper backoff? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Double Download] In make_tenure_downloaders(), lines 428-437 check if the tenure is already in completed_tenures, but line 405 calls has_downloader_for_tenure(). If a tenure passes the has_downloader_for_tenure() check but is then added to completed_tenures by another thread before the actual download starts, could this cause duplicate downloads? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Schedule Starvation] In make_tenure_downloaders() line 373, the loop continues while num_scheduled_downloaders() < count, but if all remaining tenures in the schedule require deprioritized peers or have other blocking conditions, could the loop iterate indefinitely without making progress? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Reward Cycle Validation] In make_tenure_downloaders() lines 439-460, if current_reward_cycles does not contain the start or end reward cycle for a tenure, the tenure is popped from the schedule. Could an attacker manipulate reward cycle availability to cause critical tenures to be permanently skipped? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Peer Exhaustion] In make_tenure_downloaders() line 389, if neighbors.pop() depletes the neighbor list but the tenure still needs downloading, and this happens for multiple tenures consecutively, could the system deadlock with tenures in the schedule but no available peers to download them? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Processed Flag Bypass] In make_tenure_downloaders() lines 421-427, if tenure_info.processed is true, the tenure is removed from completed_tenures but not from the schedule via pop_front(). Could this cause the tenure to be re-evaluated in the next iteration, bypassing the processed check? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Response Handling Race] In run() lines 598-659, responses are collected from neighbor_rpc and matched to downloaders via self.peers. If a peer is removed from self.peers between lines 516 and 600, could the response be processed against the wrong downloader or ignored entirely, causing tenure download failures? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Double Cleanup] In run() lines 583-596 and 661-674, finished downloaders are cleared twice (once after sending requests, once after handling responses). Could a downloader that becomes finished between these two cleanup phases cause state inconsistencies or double-removal errors? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Error Handling Desync] In run() lines 554-580, if downloader.send_next_download_request() returns an error, the peer is marked as dead and deprioritized, but the downloader is not cleared until lines 590-593. Could another thread access the downloader in an error state during this window? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Tenure Hash Collision] In run() line 641, new_blocks is keyed by downloader.tenure_id_consensus_hash. If two downloaders have the same tenure_id but different block ranges (start/end), could the HashMap insert at line 641 overwrite the previous download's blocks, causing data loss? (Critical)"
]