[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Integer Overflow] Can the hardcoded list size limit of 4430 entries be exploited if the contract attempts to store more entries than this limit, potentially causing a runtime error or silent truncation that could result in lost lockup records? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [State Consistency] Why is the list size limit exactly 4430, and does this correspond to a specific PoX cycle calculation or block height interval that could be violated during chain reorganizations? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Data Structure] Can an attacker exploit the fact that the lockups map uses uint keys (presumably block heights) by crafting transactions that target far-future block heights to pre-allocate expensive list structures? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Memory Exhaustion] If each of the 4430 list entries contains a principal and uint, what is the maximum memory cost of storing a single map entry, and could this be used for a denial-of-service attack by populating many block heights? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Contract Design] [Access Control] The contract defines only a read-only function with no write operations - how are lockups populated into the map, and is there a missing initialization or write function that should enforce access controls? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Contract Design] [State Immutability] If the lockups map is intended to be pre-populated at genesis or through a privileged operation, are there any mechanisms preventing unauthorized modification after deployment? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Contract Design] [Upgrade Path] Does the absence of any write functions mean this contract cannot be updated or migrated, potentially locking funds permanently if the list size limit is insufficient? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Block Height Validation] The function accepts an optional uint for stx-block-height-opt but performs no validation - can an attacker query future block heights beyond the chain tip or negative values (if represented as max uint) to cause unexpected behavior? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Default Value Handling] When stx-block-height-opt is none, the function defaults to the current block-height - could this create a race condition where the same query returns different results based on when it's executed within a block? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Empty List Semantics] The function returns an empty list when map-get? returns none - is there a semantic difference between 'no lockups scheduled' and 'block height not found' that should be distinguished for consensus correctness? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Return Type] The function returns (ok due-schedules) wrapping the list in a response type - under what conditions could this fail, and should there be explicit error handling for malformed map entries? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Cost Accounting] When returning a list of up to 4430 entries, does the Clarity VM properly account for the cost of copying and returning this data, or could repeated queries cause denial of service? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Principal Validation] The lockup entries contain a 'recipient' principal field - is there any validation ensuring these principals are valid Stacks addresses and not contract principals that could complicate fund distribution? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Principal Type] Can the recipient field contain contract principals (contract-caller), standard principals, or both, and could mixing these types cause issues during actual fund distribution? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Duplicate Recipients] Are duplicate recipients allowed within the same list of 4430 entries, and could this be exploited to claim multiple lockup amounts for the same principal? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Integer Bounds] The amount field is a uint - can zero amounts be stored, and would this create phantom lockup entries that waste storage or complicate processing logic? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Amount Overflow] Can the sum of all amounts in a single list of 4430 entries exceed the maximum uint value (u340282366920938463463374607431768211455), causing overflow when calculating total distributions? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Amount Consistency] Is there any validation ensuring lockup amounts correspond to actual STX balances or PoX commitments, or could arbitrary amounts be stored leading to unfunded distributions? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [List Iteration Cost] If external code iterates over the returned list of 4430 entries, what are the Clarity VM cost implications, and could this enable a DoS attack by forcing expensive iterations? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [List Order] Does the order of entries in the list matter for distribution fairness or consensus, and is the order deterministic across different nodes? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Partial Results] If the map contains exactly 4430 entries and more need to be added, is there a mechanism for pagination or batching, or would this create a hard limit on lockup capacity? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Block Height Zero] What happens when querying block height 0 or 1 (genesis blocks), and could this return unexpected lockup schedules or cause initialization issues? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Function: get-lockups] [Max Block Height] Can the function be queried with u340282366920938463463374607431768211455 (max uint), and would this cause issues with arithmetic or comparisons elsewhere in the system? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Map: lockups] [Block Height Gaps] If lockups are only scheduled for specific block heights with gaps in between, could querying an intermediate height return an empty list that's indistinguishable from 'no lockups at this exact height'? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/lockup.clar] [Contract Integration] [PoX Cycles] How does this lockup contract integrate with PoX reward cycles, and could a mismatch between lockup block heights and cycle boundaries cause funds to be released at incorrect times? (Critical)"
]