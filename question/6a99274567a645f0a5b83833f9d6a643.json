[
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Consensus Divergence] Can an attacker cause consensus divergence by providing block_commits and missed_commits vectors where missed_commits.len() + 1 != block_commits.len(), bypassing the assertion at line 115 through race conditions or by exploiting how these vectors are constructed upstream? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Integer Overflow] Can the window_size calculation at line 174 overflow when block_commits.len() is cast to u8, causing incorrect iteration bounds and skipped validation for miners with high relative block heights? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Consensus Divergence] Can an attacker exploit the remove() operations at lines 187, 200, and 201 to cause different nodes to process commits in different orders if the input vectors are not strictly ordered by block height, leading to different burn distributions? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [UTXO Chain Bypass] Can a miner bypass UTXO chaining requirements by submitting a block commit that spends an output index that doesn't match expected_chained_utxo at line 217, but still gets included if the continue statement at line 227 is not reached due to logic errors? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Sortition Manipulation] Can a miner gain unfair sortition advantage by crafting a block commit that references both a valid commit and a missed commit simultaneously, exploiting the precedence logic at lines 230-237 where valid commits are checked before missed commits? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [HashMap Collision] Can an attacker cause consensus divergence by creating block commits with colliding txids in the cur_commits_map and cur_missed_map HashMaps at lines 204-212, causing remove() to return different results on different nodes? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Index Out of Bounds] Can the indexing operation at line 251 (window_size - 1 - rel_block_height) result in incorrect array access or overflow when rel_block_height exceeds window_size - 1, potentially corrupting the linked_commit data structure? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Burn Fee Manipulation] In the LinkedCommitIdentifier::burn_fee() call at line 269, missed commits always return 1 (line 82), but can this be exploited by creating many missed commits to dilute the median calculation and reduce effective burns for subsequent miners? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Median Calculation] Can the median calculation at lines 281-287 produce incorrect results when window_size is even and the two middle values differ significantly, causing the average to round incorrectly and bias sortition toward certain miners? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Division Precision] In the even window_size median calculation at line 282-284, can integer division by 2 cause loss of precision that accumulates across multiple sortitions, gradually biasing the distribution? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Frequency Overflow] Can the frequency calculation at lines 291-299 overflow the u8 type when checked_add fails, and if so, does the expect() at line 295 properly prevent this, or can commit_window exceed 255 in edge cases? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Unreachable Panic] The unreachable! macro at line 306 assumes the first linked_commit is always Valid, but can a race condition or logic error in the linking phase cause this to be a Missed commit, resulting in an unexpected panic and node crash? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Assertion Bypass] The assertion at line 308 checks that candidate.burn_fee equals most_recent_burn, but can this be violated if the LinkedCommitIdentifier::burn_fee() method returns different values for the same commit due to concurrent modifications? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Min Calculation] The cmp::min() call at line 289 chooses between median_burn and most_recent_burn, but can an attacker exploit this by strategically timing burns to ensure most_recent_burn is always lower than median, effectively capping their effective burn below market rate? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [UTXO Validation] Can the expected_chained_utxo calculation at line 217 using LeaderBlockCommitOp::expected_chained_utxo() be bypassed by manipulating the burn_blocks vector to incorrectly classify PoB vs PoX sortitions? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Chain Break] If a block commit's spent_output() at line 223 doesn't match expected_index but the continue statement is somehow skipped, can this cause incorrect UTXO chain linking that persists through the entire distribution calculation? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [UTXO Reference] Can the spent_txid() call at line 231 return a txid that exists in both cur_commits_map and cur_missed_map, and if so, which takes precedence and can this be exploited for double-linking? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Remove Ordering] Since HashMap::remove() at lines 231 and 235 are checked sequentially, can a malicious miner create commits where the same txid appears as both a valid commit and a missed commit to exploit the ordering? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Missing Chain] If no chained UTXO is found (line 239-246), the code continues without adding to linked_commit, but can this cause an incomplete frequency count that underestimates a miner's commitment window participation? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Empty Sample] If burn_sample is empty at line 362, the function returns early without setting any ranges, but can this cause downstream sortition logic to crash when attempting to select a winner from an empty distribution? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Single Sample] When burn_sample.len() == 1 at line 366, the entire range [0, 2^256-1] is assigned, but can this be exploited by creating a single low-burn commit to monopolize the entire sortition space during prepare phases? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Total Burns Overflow] The get_total_burns() call at line 378 returns Option<u64>, but if it returns None due to overflow, does the unwrap() cause a panic, and can an attacker trigger this by submitting many high-value burns? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Division by Zero] If total_burns is calculated as zero at line 378-379 (e.g., all burns are zero or missed commits), does the division at line 393 cause a panic or undefined behavior? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Fixed-Point Precision] The fixed-point arithmetic using Uint512 at lines 386-393 multiplies by Uint256::max() then divides by total_burns, but can rounding errors in this calculation create gaps or overlaps between adjacent ranges? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Range Overlap] Can consecutive ranges overlap if the to_uint256() conversion at line 393 rounds inconsistently, causing the same VRF hash to match multiple candidates? (Critical)"
]