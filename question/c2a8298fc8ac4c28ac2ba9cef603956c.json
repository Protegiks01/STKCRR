[
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::min()] [Self-Minimum] Does min(&self) return an identical copy, and is the Copy trait implementation safe for this? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::one()] [Shift Amount] Is the shift amount 64 in 'Uint256::one() << 64' at line 48 validated, or can it cause undefined behavior if Uint256 is less than 128 bits? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::ipart()] [Shift Direction] Is the right shift '>>' at line 63 an arithmetic or logical shift, and does this affect sign extension for the integer part? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Normalization Shift] After multiplication, the >> 64 shift at line 92 - could this lose significant bits if the product uses the full Uint256 range? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Scale Factor] Is the << 192 shift at lines 130 and 132 correctly calculated to scale a 64-bit fraction to 256-bit probability space? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::is_overflowed()] [Boundary Comparison] Does the > comparison at line 68 correctly identify overflow, or should it be >= to catch exact max() values? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Less-Than Check] Is the < comparison at line 83 sufficient to prevent underflow, or can equal values cause issues? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::min()] [Total Ordering] Does the < operator at line 101 provide a total ordering over all valid AtcRational values? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Greater-Equal Comparison] Is the >= comparison at line 128 correct, or should it be > to allow exactly one() to be processed normally? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Struct: AtcRational] [Stack Allocation] Does AtcRational fit within reasonable stack size limits, or can deep recursion with AtcRational locals cause stack overflow? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Static Size] Is the 1024-element array at lines 149-1174 efficiently stored, or does it consume excessive binary size affecting deployment? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::to_hex()] [String Allocation] Can to_hex() at line 110 allocate unbounded strings causing memory exhaustion in debug scenarios? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [u64 to Uint256] Does Uint256::from_u64() at line 38 correctly convert u64::MAX without truncation or overflow? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::ipart()] [Uint256 to u64] Does low_u64() at line 63 safely truncate the shifted value, or can high bits be lost silently? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::max()] [Constant Composition] Can the bitwise OR at line 58 produce unexpected results if u64::MAX is not represented exactly in Uint256? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Commutativity] Is addition commutative - does a.add(&b) always equal b.add(&a) for all valid inputs? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Commutativity] Is multiplication commutative - does a.mul(&b) always equal b.mul(&a) including overflow detection? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Associativity] Is addition associative - does (a.add(&b)).add(&c) equal a.add(&(b.add(&c))) for sortition chain calculations? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Inverse Property] Does a.sub(&b).add(&b) return Some(a) for all valid a and b where a >= b? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Distribution] Does a.mul(&(b.add(&c))) equal a.mul(&b).add(&a.mul(&c)) in fixed-point arithmetic? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Index Calculation] If ATC_LOOKUP is indexed by 'atc_value * 1024', can floating-point to integer conversion cause out-of-bounds access? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Interpolation] If code interpolates between ATC_LOOKUP entries, can rounding errors cause non-deterministic sortition results? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Entry Validation] Are all 1024 entries at lines 150-1173 within valid AtcRational range [0, one_sup()]? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [BurnSamplePoint Compatibility] Does the 256-bit probability output integrate correctly with BurnSamplePoint ranges, or can misalignment cause sortition failures? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Burnchain Commit Amounts] Can Bitcoin satoshi amounts (u64) overflow when converted to ATC ratios in frac()? (High)"
]