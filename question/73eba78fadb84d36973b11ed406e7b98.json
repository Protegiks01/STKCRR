[
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: RunLoop::new()] [Race Condition] Can multiple threads call new() concurrently and create race conditions in CoordinatorCommunication::instantiate(), potentially leading to channel confusion or message routing errors between coordinator components? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: RunLoop::new()] [State Inconsistency] If event_dispatcher.register_observer() fails silently for some observers but succeeds for others, can this lead to inconsistent event propagation where critical consensus events are not delivered to all registered observers, causing state divergence? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: RunLoop::new()] [Resource Exhaustion] The MinerStatus is initialized with config.burnchain.burn_fee_cap - can an extremely large burn_fee_cap value cause integer overflow or excessive memory allocation in the MinerStatus struct, leading to DoS? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: RunLoop::get_globals()] [Panic Condition] The expect() call on line 119 will panic if globals are not instantiated - can an attacker trigger code paths that call get_globals() before start() is called, causing node crashes? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: RunLoop::get_burnchain()] [Panic Condition] The expect() on line 153 will panic if burnchain is accessed before start() - can this be exploited to crash nodes through API calls or P2P messages that trigger premature burnchain access? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Consensus Bypass] If config.get_node_config(false).mock_mining returns true on line 171, the function skips UTXO verification entirely - can an attacker set mock_mining in production to bypass Bitcoin UTXO requirements and mine without burning Bitcoin? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Wallet Security] The create_wallet_if_dne() call on line 176 only logs warnings on error - if wallet creation fails silently, can the node incorrectly believe it's a miner when it cannot actually sign Bitcoin transactions, leading to failed block commits? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Address Generation] The legacy Bitcoin address is generated using Hash160::from_data on line 185 - if get_public_key().to_bytes() returns inconsistent serialization across different platforms, can this cause miners to check UTXOs at different addresses, leading to consensus divergence? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Segwit Bypass] The segwit address generation on lines 189-198 only occurs if config.miner.segwit is true - if this flag is incorrectly set to false for Epoch 2.1+, will the node check legacy addresses and incorrectly determine mining eligibility during post-Epoch21 periods? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Key Compression] The segwit address uses to_bytes_compressed() on line 195 while legacy uses to_bytes() - if the key compression logic has bugs, can this cause the same private key to generate different addresses on different nodes, breaking miner consensus? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [UTXO Race Condition] The UTXO retry loop (lines 202-215) checks UTXOs with a 10-second interval - if Bitcoin reorgs occur during this window, can a node see UTXOs in one check, have them disappear due to reorg, and incorrectly cache stale UTXO state? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Denial of Service] The panic on line 216 'No UTXOs found, exiting' terminates the entire node if no UTXOs are detected after retries - can an attacker perform a targeted DoS by temporarily making Bitcoin nodes unreachable during the UTXO check window, forcing legitimate miners offline? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Epoch Confusion] UTXOs are checked with epoch_id parameter (Epoch2_05 for legacy, Epoch21 for segwit) on line 206 - if get_utxos() implementation treats epochs incorrectly, can a miner with Epoch21 UTXOs be rejected because the check looks for wrong epoch, causing mining failures? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Integer Overflow] The get_utxos call uses hardcoded parameters '1, None, 0' on line 206 - if these parameters (limit, filter, starting height) can overflow or be misinterpreted, can this cause incorrect UTXO detection results? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: check_is_miner()] [Network Partition] If burnchain.get_utxos() returns None due to network errors but the Bitcoin node is actually online, the retry logic (lines 202-215) may exhaust retries and panic unnecessarily - can transient network issues cause permanent node shutdown? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Genesis Tampering] Initial balances are loaded from config.initial_balances on lines 230-235 - if the config file is modified after deployment to include attacker addresses with large balances, can this create divergent genesis states across nodes? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [State Root Mismatch] The ChainStateBootData uses first_burnchain_block_hash from config on line 241 - if different nodes have different configured first block hashes, will they compute different genesis state roots and diverge permanently from the canonical chain? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Callback Exploitation] The post_flight_callback is set to None on line 240 - if there's code elsewhere that relies on this callback being called, can skipping it cause state initialization to be incomplete, leaving the node in an inconsistent state? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Closure Capture Bug] The get_bulk_initial_lockups closure captures use_test_genesis_data by move on line 246 - if this boolean is somehow corrupted or has different values across nodes, will lockup distributions differ, breaking consensus on who is stacking? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Balance Corruption] get_bulk_initial_balances on line 248 returns balances based on use_test_genesis_data - if test genesis data is accidentally used in production (or vice versa), can this create nodes with completely different initial STX distributions? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Namespace Hijacking] get_bulk_initial_namespaces on line 251 loads BNS namespaces - if test data includes different reserved namespaces than production, can this lead to namespace collision or unauthorized namespace control? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Name Front-running] get_bulk_initial_names on line 254 preregisters names - if test genesis has different preregistered names, can attackers register names in production that were reserved in test, causing unexpected name ownership? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Network Mismatch] StacksChainState::open_and_exec uses config.is_mainnet() and config.burnchain.chain_id on lines 258-259 - if these don't match (e.g., mainnet=true but testnet chain_id), what is the resulting state and can it lead to cross-chain replay attacks? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [MARF Option Tampering] The node.get_marf_opts() on line 262 can customize MARF behavior - if these options differ across nodes (e.g., different trie depth limits), can this cause nodes to accept/reject different block sizes, leading to forks? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Unwrap Panic] The unwrap() on line 264 will panic if chainstate opening fails - can an attacker corrupt the chainstate directory to force nodes to panic on boot, causing permanent DoS? (Medium)"
]