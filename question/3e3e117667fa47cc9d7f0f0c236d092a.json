[
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Division by Zero] Can the frac() constructor at line 37-39 cause a division by zero panic if denominator is 0, leading to a node crash during sortition probability calculations and consensus halt? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Integer Overflow] Does the left shift operation '(Uint256::from_u64(num) << 64)' at line 38 preserve all bits of the numerator, or can it silently overflow when num is near u64::MAX, causing incorrect ATC carryover calculations? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Consensus Divergence] Can the division operation at line 38 produce non-deterministic results across different CPU architectures or optimization levels, causing nodes to calculate different null miner probabilities? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Precision Loss] When numerator and denominator are both small values (e.g., 1 and 1000000), does the 64-bit fractional representation at line 38 lose precision in a way that affects sortition fairness? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::one()] [Bit Shift Overflow] Can the left shift 'Uint256::one() << 64' at line 48 overflow or produce incorrect results if Uint256 implementation changes, violating the invariant that one() equals exactly 1.0? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::one_sup()] [Arithmetic Underflow] Can the subtraction '(Uint256::one() << 64) - Uint256::from_u64(1)' at line 53 underflow or produce unexpected results if the shift operation fails? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::max()] [Bit Operations] Does the OR operation '(Uint256::from_u64(u64::MAX) << 64) | Uint256::from_u64(u64::MAX)' at line 58 correctly represent u64::MAX.u64::MAX, or can bit manipulation errors cause the maximum value to be mis-calculated? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::max()] [Integer Overflow] Can the left shift of u64::MAX at line 58 overflow when converted to Uint256, causing max() to return a value less than the true maximum and breaking overflow detection? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::ipart()] [Bit Shift Underflow] Can the right shift operation 'self.0 >> 64' at line 63 produce incorrect results for values less than 2^64, causing ipart() to return wrong integer parts? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::ipart()] [Type Conversion] Does the low_u64() call at line 63 correctly extract only bits 64-127, or can it return bits from the upper 128 bits if the value is overflowed? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::is_overflowed()] [Comparison Logic] Is the overflow check 'self.0 > Self::max().0' at line 68 sufficient to detect all overflow conditions, or can values equal to max() + small_epsilon pass through undetected? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::is_overflowed()] [Consensus Safety] If is_overflowed() returns false for an actually overflowed value due to comparison operator implementation, can this cause nodes to accept invalid ATC values and diverge? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Integer Overflow] The comment at line 73 claims 'this is always safe since u128::MAX + u128::MAX < Uint256::max()' but AtcRational uses u128 representation (bits 0-127), can two max AtcRational values overflow the addition before is_overflowed() check? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Overflow Detection] Can the overflow check at line 75-77 fail to detect overflow if the sum wraps around in Uint256 arithmetic, allowing overflowed values to be returned as Some()? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Consensus Divergence] If addition produces slightly different results on different platforms due to Uint256 implementation differences, can this cause sortition consensus failures? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Precision Preservation] Does addition correctly preserve the fractional part alignment (bits 0-63), or can bit positions shift causing precision loss in null miner probability calculations? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Return Semantics] If is_overflowed() is true, returning None at line 76 could cause unwrap() panics in calling code - is this the intended consensus-safe behavior or should it saturate? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Underflow Check] Does the underflow check 'self.0 < other.0' at line 83 correctly handle the case where self equals other (should return zero, not None)? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Unsigned Underflow] Can the subtraction 'self.0 - other.0' at line 86 underflow in Uint256 arithmetic if the comparison check has a bug, causing wrapped values to pass through? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Edge Case] When self.0 == other.0, does sub() return Some(zero()) or None, and is this behavior consistent with sortition logic expectations? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Precision Loss] Does subtraction of nearly-equal large values lose significant precision in the fractional bits, affecting ATC carryover accuracy? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Overflow Before Shift] The comment at line 91 claims safety, but can 'self.0 * other.0' overflow Uint256 before the right shift, especially when both operands use full 128-bit range? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Bit Shift Precision] Does the right shift '>> 64' at line 92 correctly normalize the product back to fixed-point format, or can it lose fractional precision critical for sortition? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Overflow Detection Timing] Is the overflow check at line 93-95 applied after the shift, meaning overflows in the multiplication itself might be missed? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Rounding Behavior] When shifting right by 64 bits at line 92, are fractional bits truncated or rounded, and does this create deterministic behavior across all nodes? (High)"
]