[
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: inner-stack-aggregation-commit()] [Signer Key Authorization] The consume-signer-key-authorization uses topic 'agg-commit' and period u1, but can this be replayed across different reward cycles with the same auth-id? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: inner-stack-aggregation-commit()] [Logged Partial State] The logged-partial-stacked-by-cycle map is set after deletion; if multiple commits happen for same key, does each overwrite the last, losing historical data? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-commit()] [Return Value Mismatch] The wrapper function returns (ok true) on success, discarding the pox-addr-index; can this cause issues for callers expecting the index for subsequent stack-aggregation-increase calls? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Reward Cycle Index Validation] If reward-cycle-index points to a valid entry but for a different pox-addr than provided, will the assertion at line 922 catch this, or can attacker increase wrong address? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Stacker Field Check] The assertion at line 918 requires stacker field to be none, but can an attacker call delegate-stack-stx() with stacker: none to create entries that look like delegated but aren't? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Double Increase] Can the same partial-stacked-by-cycle entry be used for multiple stack-aggregation-increase calls if map-delete at line 953 fails or is bypassed? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Total Overflow] When computing increased-entry-total (+ (get total-ustx existing-entry) partial-amount-ustx) and increased-cycle-total at lines 906-907, can overflow occur with large delegation pools? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Minimum Threshold Re-check] The assertion at line 914 checks threshold after increase, but can existing-entry have been below threshold before, allowing gradual accumulation below minimum? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Signer Key Mismatch] The assertion at line 929 requires existing-signer-key equals signer-key, but can this be bypassed by frontrunning the commit with a different signer-key? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Max Amount Validation] The assertion at line 926 checks (>= max-amount increased-entry-total), but uses increased-entry-total instead of partial-amount-ustx; can this allow larger increases than authorized? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Topic Authorization] Using topic 'agg-increase' with period u1, can this authorization be reused across multiple increase operations within the same cycle? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-aggregation-increase()] [Future Reward Cycle] The assertion at line 896 requires reward-cycle > current-pox-reward-cycle, but can setting it too far in future allow locking beyond MAX_POX_REWARD_CYCLES? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [Extend Beyond Maximum] If current lock-period plus extend-count exceeds MAX_POX_REWARD_CYCLES (u12), will the calculation at line 1184 (lock-period calculation) wrap or will check-pox-lock-period at line 1205 catch this? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [First Extend Cycle] The first-extend-cycle is calculated from unlock-height at line 1163, but if unlock-height is corrupted or manipulated, can stacker extend into past cycles? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [Reward Set Index Concatenation] The slice? operation at line 1216 extracts old-indexes starting from cur-cycle-index; if cur-cycle-index is negative or exceeds list length, will this fail silently or crash? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [First Reward Cycle Recalculation] The logic at lines 1165-1166 recalculates first-reward-cycle as max(cur-cycle, cur-first-reward-cycle), but can this cause index misalignment if stacker is already past their original first-reward-cycle? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [Zero Amount Authorization] The consume-signer-key-authorization is called with amount u0 at line 1181, allowing any signer-key to authorize extension; can attackers generate cheap authorizations to DoS? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [Delegation Check] The assertion at line 1201 checks is-none for get-check-delegation, but stacker might have delegated after initial stacking; can this block legitimate extensions? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [Unlock Height Calculation] The new-unlock-ht at line 1185 uses (+ u1 last-extend-cycle), but can off-by-one errors cause unlock at wrong cycle boundary? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [Already Delegated Check] If stacker has non-empty reward-set-indexes but is actually delegated (delegated-to is some), can the check at line 1173 be bypassed? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-extend()] [List Concatenation Overflow] When concatenating old-indexes and extended-reward-set-indexes at line 1216, if combined length exceeds u12, will unwrap-panic at line 1218 abort? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-increase()] [Increase Amount Validation] If increase-by is u0 or negative (though uint prevents negative), can the assertion at line 1109 be bypassed with u1 minimum to inflate locked amounts trivially? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-increase()] [Insufficient Unlocked Funds] The check at line 1112 compares amount-unlocked >= increase-by, but can a race condition allow concurrent spending of unlocked funds between check and actual increase? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-increase()] [First Increased Cycle] Setting first-increased-cycle to (+ cur-cycle u1) at line 1099, can transaction confirmation delay cause actual increase to apply to a different cycle than intended? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: stack-increase()] [Delegated Stacker Check] The assertion at line 1118 checks len(reward-set-indexes) > 0, but can a stacker with delegated-to: some but non-empty reward-set-indexes bypass this? (High)"
]