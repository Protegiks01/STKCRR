[
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_block_hash()] [Hex Decoding] If StacksBlockId::from_hex() fails due to invalid hex characters, does the error leak information about expected hash formats that could aid in crafting valid-looking but malicious block IDs? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_block_hash()] [Length Validation] Does from_hex() enforce exact 32-byte (64 hex char) length? Can attackers send shorter or longer hashes that are silently truncated or padded, leading to queries for unintended blocks? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_txid()] [Txid Format] Are Txid and StacksBlockId validated to have different lengths or formats? Can confusion between the two types lead to incorrect database lookups if a handler uses the wrong get_* function? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_clarity_name()] [Name Injection] Does ClarityName::try_from() reject names with special characters like '.', ':', or Unicode that could be used for injection attacks in downstream Clarity VM operations? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_consensus_hash()] [Hash Confusion] If ConsensusHash::from_hex() succeeds but the hash is all zeros or has a special sentinel value, can this trigger incorrect burnchain lookups or bypass PoX validation? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_burnchain_header_hash()] [Type Safety] Can BurnchainHeaderHash and ConsensusHash be confused if they have the same byte length? Could using the wrong helper function lead to incorrect burn block lookups affecting sortition validation? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_u32()] [Integer Overflow] Does parse::<u32>() handle strings like \\",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_u64()] [Large Numbers] Can extremely large u64 strings (e.g., \\",
  "[File: stackslib/src/net/httpcore.rs] [Function: request::get_u32()] [Negative Numbers] Does parse::<u32>() correctly reject negative numbers like \\",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestPreamble::set_canonical_stacks_tip_height()] [Header Injection] If height is formatted as format!(\\",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestPreamble::get_canonical_stacks_tip_height()] [Parse Failure] If parse::<u64>() fails for a malformed X-Canonical-Stacks-Tip-Height header, returning None, does the caller handle this gracefully or assume a default tip height that could lead to chain tip confusion? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestPreamble::get_request_id()] [ID Collision] If parse::<u32>() succeeds but the request ID is HTTP_REQUEST_ID_RESERVED (0), does this cause confusion with non-Stacks HTTP clients, allowing attackers to spoof reserved IDs? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestPreamble::set_request_id()] [ID Exhaustion] Is there any validation that request IDs don't overflow or collide? Can an attacker rapidly send requests with sequential IDs to exhaust the u32 space and cause ID reuse? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpResponsePreamble::set_canonical_stacks_tip_height()] [Response Header Injection] Can an attacker control the height value in a response to inject additional headers via newline characters in the formatted string, leading to header injection attacks? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpResponsePreamble::get_request_id()] [Missing Request ID Handling] If a response lacks X-Request-Id header (returning None), does the caller fall back to HTTP_REQUEST_ID_RESERVED? Can this cause mismatched request/response pairs if the client expects a specific ID? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestContents::for_specific_tip()] [Tip Injection] If tip is converted to string via format!(\\",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestContents::for_tip()] [Query Arg Pollution] The function calls take_query_arg() to remove existing 'tip' arg before adding. If take_query_arg() fails silently, can duplicate 'tip=' params accumulate, causing ambiguous tip resolution? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestContents::tip_request()] [Default Behavior] If get_query_args().get(\\",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestContents::get_with_proof()] [Boolean Coercion] The proof= param defaults to \\",
  "[File: stackslib/src/net/httpcore.rs] [Function: HttpRequestContents::get_with_proof()] [Proof Bypass] If an attacker sends proof=0, they skip MARF proof generation. Can this be exploited to save server CPU when querying sensitive data, enabling more efficient reconnaissance of chain state? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttpRequest::new_for_peer()] [Content Length Mismatch] If contents.content_length()? returns a value but the actual payload is larger, can this cause truncated writes or buffer overruns when sending the request? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttpRequest::new_for_peer()] [Query String Override] After decode_request_path(), the full_query_string is appended. If path already contains '?query', can this create double query strings like '/path?old?new' that confuse parsers? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttpRequest::new_for_peer()] [Path Canonicalization] The decoded_path is derived from decode_request_path(). If decoding fails, does new_for_peer() propagate the error, or can a partially decoded path be used, leading to misrouted requests? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttpRequest::duration_ms()] [Time Overflow] Uses get_epoch_time_ms() and saturating_sub(). Can extremely old requests with start_time from far past cause integer underflow if system time is adjusted, resulting in incorrect duration calculations? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttpRequest::send()] [Write Atomicity] Calls preamble.send() then contents.get_payload().send(). If the first succeeds but second fails, does this leave the connection in an inconsistent state with partial requests sent? (Medium)"
]