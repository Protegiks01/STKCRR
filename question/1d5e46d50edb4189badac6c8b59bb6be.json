[
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [Receipt Broadcast] run_loop::announce_boot_receipts on lines 265-270 broadcasts receipts to observers - if receipt ordering is non-deterministic, can observers see different event sequences and compute different derived states? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: boot_chainstate()] [PoX Constants Mismatch] The boot receipts use burnchain_config.pox_constants on line 268 - if these constants differ from what was used during chainstate initialization, can this cause inconsistent reward cycle calculations in event observers? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Genesis Atlas Poisoning] Genesis attachments are loaded from GenesisData on lines 287-290 - if an attacker can inject malicious zonefiles into the genesis data, can they permanently associate malicious content with genesis names, bypassing later validation? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Atlas DoS] All genesis zonefiles are loaded into memory as Attachment objects on line 289 - if genesis data contains extremely large zonefiles (before validation), can this cause OOM during node startup? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Config Duplication] The atlas_config is instantiated twice (lines 286 and 296) - if the second instantiation on line 296 has different settings than the first, which config is actually used by AtlasDB, and can this lead to validation inconsistencies? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [AtlasDB Corruption] AtlasDB::connect on line 300-304 uses expect() - if the Atlas DB is corrupted, will the node panic on startup, and can an attacker repeatedly corrupt the DB to prevent node recovery? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Bitcoin Indexer Bypass] make_bitcoin_indexer on line 306-307 can return different indexer types - if an attacker can influence which indexer is created, can they provide false burnchain data to the coordinator? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [RPC Port Extraction] The unwrap_or_else with panic! on line 312 will crash if rpc_bind cannot be parsed - can malformed config.node.rpc_bind cause DoS during coordinator startup? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Thread Stack Overflow] The coordinator thread uses BLOCK_PROCESSOR_STACK_SIZE on line 316 - if this is insufficient for deep block processing, can maliciously crafted large blocks cause stack overflow in the coordinator thread, crashing the node? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Cost Estimator Manipulation] make_cost_estimator() on line 322 creates estimator from config - if config contains manipulated cost parameters, can this cause the node to produce blocks with incorrect cost estimates, breaking consensus with other nodes? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Fee Estimator Manipulation] make_fee_estimator() on line 323 - if fee estimates are manipulated, can this cause a miner to produce blocks with fees that other nodes reject, or accept transactions other nodes would reject? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Txindex Inconsistency] ChainsCoordinatorConfig uses moved_config.node.txindex on line 326 - if some nodes have txindex enabled and others don't, can this cause divergent RPC responses that confuse clients, even if consensus is maintained? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: spawn_chains_coordinator()] [Coordinator Panic] The expect() on line 342 will panic if thread spawning fails - can resource exhaustion (too many threads) be exploited to prevent coordinator startup, DoSing the node? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start_prometheus()] [Monitoring Bypass] If monitoring_thread is already Some on line 349, the function returns early - can an attacker start a fake monitoring thread before start_prometheus() is called to prevent legitimate metrics collection? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start_prometheus()] [Thread Leak] If prometheus_bind is None on line 353, no monitoring thread is started - but if it's changed to Some later, the existing check prevents starting it, potentially leaking the monitoring_thread handle without cleanup. Can this cause resource leaks? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start_prometheus()] [Port Hijacking] The prometheus_bind address is used directly on line 360 - if an attacker can bind to this port first, can they intercept or poison metrics, or cause the monitoring thread to panic? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start_prometheus()] [Thread Spawn Failure] The expect() on line 362 will panic if thread creation fails - can an attacker exhaust thread resources to DoS the monitoring system and prevent the node from starting? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: get_reward_cycle_sortition_db_height()] [Canonical Tip Mismatch] If get_canonical_stacks_chain_tip_hash on line 374 returns a tip that doesn't exist in the sortition DB, the get_block_snapshot_consensus query on line 377 returns None - falling back to first snapshot on line 384. Can this cause reward cycle misalignment if the canonical tip is temporarily unavailable? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: get_reward_cycle_sortition_db_height()] [Expect Panic] The expect() calls on lines 375, 378, and 384 will panic if DB queries fail - can database corruption cause cascading node crashes when this function is called? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: get_reward_cycle_sortition_db_height()] [Reward Cycle Underflow] The block_height_to_reward_cycle on line 392 has an expect for 'snapshot preceeds first reward cycle' - if a snapshot somehow has a block height before the first reward cycle, can this panic crash nodes during startup? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: get_reward_cycle_sortition_db_height()] [Height Calculation Error] The reward_cycle_to_block_height on line 390 converts reward cycle back to height - if this conversion is not the inverse of block_height_to_reward_cycle, can this cause off-by-one errors in reward cycle boundaries? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: get_reward_cycle_sortition_db_height()] [First Snapshot Corruption] If get_first_block_snapshot on line 383 returns a corrupted or manipulated snapshot, can this cause all subsequent reward cycle calculations to be wrong, leading to consensus failure? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start()] [Double Start] The coordinator_channels.take() on line 412 expects channels to be Some - if start() is called twice, the second call will panic with 'already started'. Can an attacker trigger multiple start() calls to crash the node? (Low)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start()] [Termination Handler Race] The setup_termination_handler on line 417 has allow_err=true for prior runloop handlers - if multiple handlers are registered, can signal handling become non-deterministic, causing some nodes to shutdown while others continue? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/nakamoto.rs] [Function: start()] [Burnchain Shutdown] If instantiate_burnchain_state returns ShutdownInitiated on line 428, the function returns early - can an attacker trigger this during critical consensus moments to selectively shut down specific nodes? (High)"
]