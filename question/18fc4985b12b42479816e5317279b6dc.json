[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Integer Overflow] Can the addition `(+ signer-weight (default-to u0 (map-get? tally tally-key)))` overflow when multiple signers with maximum uint weights vote for the same aggregate public key, potentially wrapping to a small value that fails to meet the threshold? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Integer Overflow] Can the round-data vote-weight accumulation `(+ (get votes-weight current-round) signer-weight)` overflow when many signers vote in the same round, causing incorrect weight tracking and potential consensus failures? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: get-threshold-weight()] [Integer Overflow] Can the expression `(+ (* total-weight threshold-consensus) u99)` overflow for extremely large total-weight values, resulting in incorrect threshold calculations or arithmetic wrap-around? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: sum-weights()] [Integer Overflow] Can the fold operation `(fold sum-weights signers u0)` accumulate to a uint overflow when summing weights of all signers, causing incorrect total weight caching? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: burn-height-to-reward-cycle()] [Integer Underflow] Can `(- height (get first-burnchain-block-height pox-info))` underflow if height is less than first-burnchain-block-height, causing incorrect reward cycle calculations? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: reward-cycle-to-burn-height()] [Integer Overflow] Can `(* reward-cycle (get reward-cycle-length pox-info))` overflow for large reward-cycle values, resulting in incorrect burn height calculations? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: is-in-prepare-phase()] [Integer Arithmetic] Can the complex modulo expression with additions and subtractions produce unexpected results due to integer overflow in intermediate calculations? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: get-threshold-weight()] [Rounding Error] Does the integer division `(/ (+ (* total-weight threshold-consensus) u99) u100)` correctly implement ceiling division, or can off-by-one errors allow approval with slightly less than 70% weight? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Consensus Bypass] Can an attacker exploit the threshold check `(>= new-total threshold-weight)` by voting with multiple aggregate public keys in parallel to reach threshold on a malicious key before honest signers coordinate? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Race Condition] If threshold-weight is zero (when total-weight is zero), does `(>= new-total threshold-weight)` allow any key to be approved with a single vote? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: get-threshold-weight()] [Precision Loss] Can the hardcoded threshold-consensus value of u70 combined with integer division lose precision for small signer sets, allowing keys to be approved with insufficient support? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Consensus Split] If multiple aggregate public keys reach the threshold simultaneously in the same block (different transactions), which one gets approved and is the selection deterministic? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Double Voting] Does the duplicate vote check using `map-insert` on the votes map properly prevent a signer from voting multiple times for different keys in the same round? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Replay Attack] Can a signer vote in round N, then vote again for a different key in round N+1, potentially splitting votes and preventing consensus? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: is-novel-aggregate-public-key()] [Key Reuse] Does the check `(is-eq (default-to reward-cycle (map-get? used-aggregate-public-keys key)) reward-cycle)` correctly prevent key reuse, or can the default-to logic allow a key to be reused in the same reward cycle? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Key Reuse Timing] Is the used-aggregate-public-keys map updated before or after threshold checking, and can this ordering allow a key to be reused if voting transactions are processed in a specific order? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [State Inconsistency] If map-insert for used-aggregate-public-keys succeeds but aggregate-public-keys insertion fails, is the key permanently marked as used without being approved? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: update-last-round()] [Round Skip Attack] Does the check `(<= round (+ last-round u1))` allow an attacker to skip rounds by voting for round N+1 before round N completes, potentially invalidating ongoing votes? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: update-last-round()] [Round Validation] Can the first round for a reward cycle be any value, or must it be u0 or u1, and what prevents starting at an arbitrarily high round number? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Round Increment Bypass] If update-last-round returns an error for invalid round increments, does the entire vote transaction revert, or can state be partially modified? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: update-last-round()] [State Update] When a new round is set with `(map-set rounds reward-cycle round)`, does this invalidate or affect votes from previous rounds in the same reward cycle? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Voting Window] Does the check `(is-none (map-get? aggregate-public-keys reward-cycle))` properly enforce that voting only occurs before a key is approved, or can late votes still modify tally and round-data maps? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: is-in-voting-window()] [Window Validation] The function checks if last-cycle equals reward-cycle and is in prepare phase, but vote-for-aggregate-public-key doesn't call this function - is the voting window properly enforced? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: is-in-prepare-phase()] [Phase Calculation] Can the modulo arithmetic in prepare phase detection produce incorrect results at cycle boundaries, allowing or preventing votes at wrong times? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/signers-voting.clar] [Function: vote-for-aggregate-public-key()] [Cycle Mismatch] What prevents a signer from voting for a future reward cycle before the current cycle completes, potentially pre-approving keys? (High)"
]