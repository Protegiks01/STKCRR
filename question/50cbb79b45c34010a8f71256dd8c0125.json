[
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Zero Multiplication] Does mul() correctly handle multiplication by zero, returning Some(zero()) rather than None? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Associativity] Is multiplication associative in fixed-point arithmetic, or can (a * b) * c differ from a * (b * c) due to intermediate rounding? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::min()] [Comparison Correctness] Does the comparison 'self.0 < other.0' at line 101 correctly compare fixed-point values including fractional parts, or can it reverse order for close values? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::min()] [Copy Semantics] Do the Self() constructors at lines 102 and 104 create proper copies, or can they create aliased references causing mutation bugs? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::min()] [Equality Handling] When self.0 == other.0, which value is returned, and does this choice matter for determinism? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Overflow Risk] Can the comparison 'self.inner() >= Self::one().inner()' at line 128 fail to detect all cases where the value is â‰¥1.0, allowing invalid probabilities into sortition? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Bit Shift Overflow] Does the left shift '<< 192' at line 130 or line 132 overflow Uint256, corrupting the probability range for BurnSamplePoint? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Precision Scaling] The comment at line 125-127 mentions scaling to occupy upper 64 bits - does the '<< 192' operation at line 132 correctly achieve this, or is the bit count wrong? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Probability Range] If the value is exactly one(), returning 'Self::one_sup().into_inner() << 192' at line 130 - does this correctly map to the maximum probability, or create an off-by-one error? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Determinism] Can different nodes compute different sortition probabilities from the same AtcRational due to this conversion, causing consensus forks? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_inner()] [Ownership Transfer] Does into_inner() at line 119-121 properly transfer ownership of the inner Uint256, or can use-after-move bugs occur in calling code? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::inner()] [Reference Safety] Can the reference returned by inner() at line 114-116 outlive self, causing use-after-free if self is dropped? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::to_hex()] [Serialization] Does to_hex() at line 109-111 produce deterministic, canonical output across all platforms for the same value? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Array Bounds] Is there any code path that could index ATC_LOOKUP beyond index 1023, causing a panic or out-of-bounds read? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Table Correctness] Can the hardcoded values in ATC_LOOKUP at lines 149-1174 be incorrect due to generation errors, causing systematically wrong null miner probabilities? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Monotonicity] Must the ATC_LOOKUP values be monotonically decreasing (null miner advantage decreases as ATC increases) - if not, can this cause sortition logic errors? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Precision] Do all 1024 entries use the full 64-bit fractional precision, or are some entries rounded in a way that creates unfair advantage? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Boundary Values] Are the first entry (index 0, ATC=0.0) and last entry (index 1023, ATC~1.0) at lines 150 and 1173 correctly set to represent maximum and minimum null miner advantage? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Struct: AtcRational] [Invariant Violation] Can AtcRational be constructed with bits 128-255 non-zero, violating the invariant stated at line 26 and causing arithmetic to overflow? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Struct: AtcRational] [Representation] The comment at lines 23-26 specifies bit layout - can direct construction of AtcRational(Uint256) bypass this layout, creating invalid states? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Struct: AtcRational] [Copy Trait] Is AtcRational's Copy trait at line 33 safe given it wraps Uint256 - can copies alias internal buffers causing mutation races? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Struct: AtcRational] [Debug Trait] Does the Debug implementation expose internal Uint256 representation in a way that could leak sensitive mining data? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Denominator = 1] Does frac(x, 1) correctly produce integer x without fractional part, and is this used for miner commit amounts? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Numerator = 0] Does frac(0, d) correctly return zero() regardless of denominator d, and handle d=0 case safely? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Equal Values] When num == den, does frac(n, n) return exactly one(), or can rounding cause it to be slightly less? (High)"
]