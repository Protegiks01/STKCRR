[
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: fold-unlock-reward-cycle()] [State Consistency] If the stacker field doesn't match during the move operation, can the asserts! failure leave reward-cycle-pox-address-list in an inconsistent state with dangling entries? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: fold-unlock-reward-cycle()] [Integer Underflow] Can subtracting u1 from the list length cause underflow if len is zero, leading to incorrect index calculations in the move operation? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: fold-unlock-reward-cycle()] [Logic Error] When moving the last entry to the deleted position, can the moved entry's reward-set-indexes be incorrectly updated if moved-cycle-index calculation underflows? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: fold-unlock-reward-cycle()] [State Corruption] Can the replace-at? operation fail and return none if moved-cycle-index exceeds the list length, causing unwrap-panic to abort and leaving the stacking state corrupted? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: fold-unlock-reward-cycle()] [Integer Underflow] Can subtracting cycle-entry-total-ustx from the total-ustx underflow if the map values are inconsistent, causing a negative total to wrap around to maximum uint? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: handle-unlock()] [Access Control] Can handle-unlock be called by anyone since it's defined as private but may be exposed through other contract mechanisms, allowing unauthorized early unlocks? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: handle-unlock()] [State Consistency] If fold-unlock-reward-cycle returns an error partway through processing, can the reward set be left in a partially cleaned state with some but not all cycles updated? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: handle-unlock()] [State Consistency] After deleting stacking-state, can there still be entries in reward-cycle-pox-address-list pointing to the deleted stacker, violating invariant (1)? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Integer Overflow] Can adding first-reward-cycle and i overflow, causing the function to write to an incorrect reward-cycle and corrupting future cycle data? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Integer Overflow] Can adding amount-ustx to the existing total-ustx overflow, causing the reward cycle total to wrap to a small value and underrepresenting stacked amounts? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Integer Overflow] Can incrementing i cause overflow when i is at maximum uint, leading to an infinite loop in the fold operation? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [List Overflow] Can append to reward-set-indexes exceed the u12 maximum length if as-max-len? is not properly enforced, causing unwrap-panic to abort? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-reward-cycles()] [Validation] Can the assertion checking is-eq num-cycles (get i results) fail if the fold operation encounters an error condition, leaving partial state mutations? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-reward-cycles()] [Validation] Can the assertion checking is-eq num-cycles (len reward-set-indexes) fail due to off-by-one errors in cycle counting, indicating state corruption? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-addr-to-reward-cycles()] [Edge Case] If num-cycles is zero, do the assertions correctly handle the empty case or can they pass incorrectly allowing a zero-length lock? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-partial-stacked-to-ith-cycle()] [Integer Overflow] Can adding amount-ustx to current-amount overflow, causing partial stacked amounts to wrap around and underreport delegated stacking? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-partial-stacked-to-ith-cycle()] [Integer Overflow] Can incrementing reward-cycle overflow when processing maximum cycle counts, causing writes to incorrect or past reward cycles? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: add-pox-partial-stacked-to-ith-cycle()] [Logic Error] Does the >= comparison for cycle-index allow writes to cycle num-cycles, creating an off-by-one error that stacks to one additional cycle? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: get-stacking-minimum()] [Division by Zero] Can STACKING_THRESHOLD_25 be zero through misconfiguration, causing division by zero when calculating the minimum stacking amount? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: get-stacking-minimum()] [Integer Precision] Can division truncation cause the minimum to be lower than intended when stx-liquid-supply is not evenly divisible by the threshold? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: can-stack-stx()] [Validation Bypass] Can an attacker pass the >= check with amount-ustx equal to get-stacking-minimum but then have that minimum increase before the lock executes, allowing under-threshold stacking? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: can-stack-stx()] [Race Condition] Can get-stacking-minimum change between the check in can-stack-stx and the actual lock operation, causing time-of-check-time-of-use vulnerabilities? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: minimal-can-stack-stx()] [Validation] Can amount-ustx be set to u0 and pass the > check through integer overflow or wrapping, allowing zero-amount stacking? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: minimal-can-stack-stx()] [Logic Error] Can get-pox-rejection return a stale rejection if the map was not updated for the given reward cycle, allowing a stacker to bypass rejection checks? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: minimal-can-stack-stx()] [Validation] If check-pox-lock-period accepts lock periods outside MIN_POX_REWARD_CYCLES to MAX_POX_REWARD_CYCLES due to off-by-one errors, can attackers lock for invalid durations? (High)"
]