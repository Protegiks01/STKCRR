[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: validate-caller()] [Authorization Bypass] Can an attacker bypass the authorization check by calling through a malicious contract that manipulates contract-caller to match the recipient while tx-sender differs, given the condition checks 'is-eq (var-get recipient) contract-caller tx-sender'? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: validate-caller()] [Logic Error] Does the three-way equality check '(is-eq (var-get recipient) contract-caller tx-sender)' correctly prevent indirect contract-calls, or could it be satisfied when only two of the three values match due to Clarity's is-eq behavior? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: update-recipient()] [Authorization] If the recipient is updated to a compromised address, can the old recipient still claim funds before the update takes effect, creating a race condition where both old and new recipients withdraw? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: update-recipient()] [Validation Bypass] Can the is-standard check be bypassed by providing a principal that appears standard but resolves to a contract address, allowing funds to be locked in an unspendable contract? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: claim()] [Authorization] Can the authorization check be bypassed if contract-caller is set to the recipient address through a carefully crafted contract-call chain that manipulates the caller context? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Integer Overflow] Can the subtraction '(- burn-height DEPLOY_BLOCK_HEIGHT)' overflow if burn-height wraps around the uint maximum, potentially causing incorrect vesting calculations? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Integer Division] Does the integer division '(/ diff INITIAL_MINT_VESTING_ITERATION_BLOCKS)' consistently round down, and could accumulated rounding errors cause the vested amount to diverge from the intended 100M STX over 24 months? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Arithmetic Overflow] Can the multiplication '(* STX_PER_ITERATION iterations)' overflow when iterations becomes very large, causing vested-multiple to wrap around and return an incorrectly low vested amount? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Arithmetic] Can the addition '(+ INITIAL_MINT_IMMEDIATE_AMOUNT vested-amount)' overflow if vested-amount is manipulated or corrupted, causing total-amount to wrap and return an incorrect value? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-claimable-amount()] [Integer Underflow] Can the subtraction '(- INITIAL_MINT_AMOUNT (calc-total-vested burn-height))' underflow if calc-total-vested returns a value greater than INITIAL_MINT_AMOUNT due to a bug, causing reserved to wrap to a very large uint? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-claimable-amount()] [Integer Underflow] Can the subtraction '(- balance reserved)' underflow if reserved somehow exceeds balance, and if so, does the subsequent '(> balance reserved)' check prevent this or could it still cause issues in edge cases? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Off-by-One] Does the condition '(>= iterations INITIAL_MINT_VESTING_ITERATIONS)' correctly handle the case where iterations equals exactly 24, or could an off-by-one error cause the final vesting period to be skipped or double-counted? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Rounding Error] Given that STX_PER_ITERATION is calculated as '(/ INITIAL_MINT_VESTING_AMOUNT INITIAL_MINT_VESTING_ITERATIONS)', does the truncation from integer division cause a permanent loss of STX that can never be vested? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Invariant Violation] Can the total vested amount ever exceed INITIAL_MINT_AMOUNT (200M STX) due to the addition of INITIAL_MINT_IMMEDIATE_AMOUNT and vested-amount, violating the contract's fundamental vesting invariant? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Constant: STX_PER_ITERATION] [Calculation Error] Is the constant STX_PER_ITERATION = (100M / 24) calculated correctly at compile time, and does it match the intended vesting rate, or could integer division truncation cause the sum of all 24 periods to fall short of 100M? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Edge Case] What happens if burn-height equals DEPLOY_BLOCK_HEIGHT exactly - does the diff of zero cause iterations to be zero, and is the immediate amount correctly vested in this edge case? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-total-vested()] [Time Manipulation] If the burn-height advances faster or slower than expected Bitcoin blocks, can this cause the vesting schedule to complete earlier or later than the intended 24 months, violating SIP-031 specifications? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-claimable-amount()] [State Inconsistency] If the contract's STX balance falls below the reserved amount due to a bug or unexpected transfer, does the check '(> balance reserved)' correctly return u0, or could this cause downstream issues in the claim function? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-claimable-amount()] [Balance Check] Can stx-get-balance return an unexpected value (such as including locked STX or pending transfers) that causes claimable to be calculated incorrectly, allowing over-withdrawal? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: claim()] [Race Condition] If claim() is called twice in quick succession within the same block, can both calls see the same balance before the first stx-transfer completes, allowing double-withdrawal of the claimable amount? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-claimable-amount()] [Per-Tenure Mints] When per-tenure mints are added to the contract balance, can they be immediately claimed, or could there be a timing issue where they are counted in balance but incorrectly added to the reserved amount? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: claim()] [Reentrancy] Can the stx-transfer in claim() trigger a reentrancy attack if the recipient is a malicious contract that calls back into claim() before the first transfer completes, draining more funds than intended? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Function: calc-claimable-amount()] [Early Withdrawal] Can an attacker manipulate burn-height (via view of an old block state) to calculate a higher claimable amount than should be available at the current block height? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Constant: DEPLOY_BLOCK_HEIGHT] [Consensus Divergence] Can the conditional deployment height '(if is-in-mainnet u907740 burn-block-height)' cause consensus divergence between mainnet and testnet if nodes disagree on which network they are running? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/sip-031.clar] [Constant: DEPLOY_BLOCK_HEIGHT] [Initialization] If the contract is deployed at a burn-height different from DEPLOY_BLOCK_HEIGHT on testnet, does using the current burn-block-height cause immediate vesting of the entire amount, violating the intended schedule? (High)"
]