[
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Failed Response Handling] In run() lines 613-633, if handle_next_download_response() returns an error, the peer is deprioritized and marked dead, but the partial download state in the downloader is not rolled back. Could this cause corrupted tenure data to be processed later? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Finished Tenure Tracking] In run() lines 537, 594-596, 656, and 672-674, finished_tenures is populated and inserted into completed_tenures. If the same tenure is finished by multiple downloaders due to concurrency bugs, could completed_tenures.insert() silently deduplicate, hiding the duplicate download? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Chainstate Advancement Failure] In run() lines 541-548, try_advance_from_chainstate() errors are only logged but not acted upon. If this failure prevents the downloader from progressing, could the downloader remain stuck in an intermediate state, blocking other downloaders that depend on it? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: run()] [Inflight Check Bypass] In run() line 523, if neighbor_rpc.has_inflight(naddr) returns false but the peer actually has an inflight request that hasn't been registered yet, could a second request be sent to the same peer, causing protocol violations or peer bans? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: mark_failure()] [Saturation Attack] In mark_failure() lines 98-104, failure count is incremented with saturating_add(1). Once a tenure reaches u64::MAX failures, the counter saturates and no longer increments. Could an attacker exploit this to reset failure-based backoff logic by causing u64::MAX failures? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: mark_deprioritized()] [Time Manipulation] In mark_deprioritized() lines 108-116, the deprioritization expiry is set to get_epoch_time_secs() + PEER_DEPRIORITIZATION_TIME_SECS. If the system clock is adjusted backward, could previously deprioritized peers become immediately available, bypassing the intended backoff period? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: mark_deprioritized()] [Constant Time Exploit] The PEER_DEPRIORITIZATION_TIME_SECS constant is set to 60 seconds at line 56. Could an attacker deliberately trigger deprioritization of all honest peers, wait 60 seconds, and then monopolize all download slots with malicious peers? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: mark_failed_and_deprioritize_peer()] [Asymmetric Penalty] In mark_failed_and_deprioritize_peer() lines 119-127, both failure marking and deprioritization are applied together. If a peer experiences a transient network issue, it gets permanently penalized in the failure counter even after the 60-second deprioritization expires. Could this create bias against recovering peers? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Struct: NakamotoTenureDownloaderSet] [State Consistency] The struct maintains three separate tracking structures: completed_tenures, attempted_tenures, and attempt_failed_tenures at lines 74-78. If a tenure is in completed_tenures but has non-zero attempt_failed_tenures, could this inconsistency cause the tenure to be re-downloaded or skipped incorrectly? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Struct: CompletedTenure] [Hash Collision] CompletedTenure implements Hash and Eq at line 29, based on tenure_id, start_block, and end_block. If two different tenure downloads produce the same tenure_id but with different start/end blocks due to a fork or reorganization, could the HashSet deduplicate them incorrectly? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: From<&TenureStartEnd>] [Data Integrity] In the From<&TenureStartEnd> implementation at lines 36-44, fields are cloned from TenureStartEnd. If TenureStartEnd contains unvalidated or corrupted data from a malicious peer, could this propagate into completed_tenures and cause consensus divergence? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: From<&mut NakamotoTenureDownloader>] [Partial State Capture] In From<&mut NakamotoTenureDownloader> at lines 46-54, the CompletedTenure is created from the downloader's current state. If the downloader has not fully completed (is_done() is false), could an incomplete tenure be marked as completed? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Completed Tenure Removal] At lines 424-426, if tenure_info.processed is true, the tenure is removed from completed_tenures with completed_tenures.remove(). If this tenure was legitimately completed but not yet stored, could this cause it to be re-downloaded unnecessarily? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: num_downloaders()] [Count Accuracy] In num_downloaders() lines 173-177, the count is computed by folding over downloaders and checking is_some(). If downloaders contains many None slots due to cleared downloaders, could this count diverge significantly from num_scheduled_downloaders(), causing scheduling errors? (Low)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: num_scheduled_downloaders()] [Index Validation] In num_scheduled_downloaders() lines 180-188, the function iterates over self.peers and checks if self.downloaders.get(*idx) is Some(Some(_)). If an index in self.peers is out of bounds for self.downloaders, this returns None and is not counted. Could this undercount scheduled downloaders? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: inflight()] [State Machine Assumptions] In inflight() lines 206-221, a downloader is counted as inflight if it is not idle and not done. If a downloader is in an error state but neither idle nor done, could this cause the inflight count to include broken downloaders that will never complete? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: is_empty()] [False Positive] In is_empty() lines 224-236, the function returns true only if all downloaders are either None or is_done(). If a downloader is stuck in an error state with is_done() == false, could is_empty() return false forever, preventing the downloader set from being cleaned up? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: find_new_tenure_start_blocks()] [Block ID Collision] In find_new_tenure_start_blocks() lines 320-332, blocks are inserted into a HashMap keyed by block.block_id(). If two tenures have the same start block ID (e.g., due to a fork or reorganization), could the HashMap overwrite one with the other, causing dependent downloaders to receive the wrong block? (Critical)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: find_new_tenure_start_blocks()] [Unvalidated Block Data] In find_new_tenure_start_blocks(), the tenure_start_block is cloned directly from downloader at line 329 without validation. If the block was received from a malicious peer and not fully validated, could this propagate invalid block data to other downloaders? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloaders()] [Duplicate Prevention] In add_downloaders() lines 191-202, the function checks has_downloader(&naddr) before adding. However, if two threads call add_downloaders() concurrently with overlapping naddr sets, could this check race and allow duplicate downloaders for the same peer? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloaders()] [Iterator Consumption] In add_downloaders() line 193, iter is consumed via IntoIterator. If the iterator contains malicious or malformed (NeighborAddress, NakamotoTenureDownloader) pairs that cause has_downloader() or add_downloader() to panic, could this leave the downloader set in a partially updated state? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: has_downloader_for_tenure()] [Stale Downloader Check] In has_downloader_for_tenure() lines 335-349, the function only checks if tenure_id matches, but does not verify if the downloader is still active (not finished or errored). Could this return true for a tenure that has a finished/failed downloader, causing the tenure to be skipped incorrectly? (High)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: make_tenure_downloaders()] [Attempt Counter Overflow] In make_tenure_downloaders() lines 462-464, attempted_tenures tracks attempt counts with saturating_add(1). If the counter saturates at u64::MAX, does the calling code have logic to stop attempting the tenure, or could it retry indefinitely with a saturated counter? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: mark_failure()] [Failure Counter Overflow] In mark_failure() line 100, (*failures).saturating_add(1) prevents overflow, but if a tenure reaches u64::MAX failures, should the tenure be permanently blacklisted? Currently, no such logic exists. Could this allow infinite retries of undownloadable tenures? (Medium)",
  "[File: stacks-core/stackslib/src/net/download/nakamoto/tenure_downloader_set.rs] [Function: add_downloader()] [Silent Failure] In add_downloader() lines 140-142, if self.downloaders.get_mut(*idx) returns None, an error is logged but the function returns early without inserting the downloader anywhere. Could this silently drop download requests? (Medium)"
]