[
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Integer Overflow] Can the saturating_mul(8).div_ceil(5) size calculation at line 183 result in an undersized buffer allocation if input_bytes.len() approaches usize::MAX, leading to out-of-bounds writes during encoding? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Bit Manipulation Error] In the carry bit calculation at lines 189-194, can an attacker craft input bytes such that carry_bits exceeds the expected range [0,7], causing incorrect bit extraction and non-deterministic encoding? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Array Index Out of Bounds] At line 192, can the expression `C32_CHARACTERS[c32_value as usize]` access beyond array bounds if c32_value >= 32 due to incorrect bit masking in low_bits_to_take calculation? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Carry Overflow] At line 194, when computing `carry = current_value >> (8 - carry_bits)`, can carry_bits ever be >= 8, causing a right shift by zero or negative amount and producing undefined behavior? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Array Index Out of Bounds] At line 198, after the carry_bits >= 5 branch, can the masked c32_value still exceed 31, causing out-of-bounds access to C32_CHARACTERS array? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Array Index Out of Bounds] At line 205, when carry_bits > 0, can the final `carry as usize` exceed 31 if previous bit manipulation left high bits set, causing invalid array access? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Leading Zero Handling] In the loop at lines 209-214 that removes leading zeros, can an all-zero input cause result.pop() to drain the entire vector, and then attempt to push back a non-existent character, leading to incorrect encoding? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Non-Deterministic Encoding] Can two different byte sequences produce identical C32 encodings due to incorrect leading zero handling between lines 209-223, violating address uniqueness requirements? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Unwrap Panic] At line 226, the String::from_utf8(result).unwrap() assumes all bytes are valid UTF-8. Can previous logic insert non-ASCII bytes from C32_CHARACTERS array, causing a panic during address generation in consensus-critical code? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode()] [Empty Input Handling] What is the behavior when input_bytes is empty? Does the function return an empty string, \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode()] [Input Validation Bypass] The ASCII check at line 231 uses is_ascii(), but does c32_decode_ascii() perform any additional validation that could be bypassed by passing non-ASCII UTF-8 sequences that pass the is_ascii() check? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Character Mapping Ambiguity] At lines 240-244, the C32_CHARACTERS_MAP lookup accepts both uppercase and lowercase, plus O→0, L→1, I→1. Can an attacker exploit this normalization to create address collisions or cause consensus divergence if different nodes normalize differently? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Array Index Out of Bounds] At line 241, when accessing C32_CHARACTERS_MAP.get(*x as usize), can a byte value >= 128 cause None to be returned, but what happens if the input contains bytes exactly at boundary values that might bypass validation? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Length Validation] The validation at line 246 checks if input_str.len() != iter_c32_digits.len(), but can an attacker craft input with valid-looking prefixes and invalid suffixes that partially decode, leading to state confusion? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Integer Overflow] At line 254, can saturating_mul(5).div_ceil(8) overflow or produce incorrect result buffer size for extremely long input strings, leading to truncation of decoded data? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Carry Accumulation] At lines 260-261, carry is a u16 and accumulates via `carry += (*current_5bit as u16) << carry_bits`. Can this overflow if input contains many consecutive maximum values (31), corrupting the decoded output? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Bit Extraction Error] At line 264, when extracting the low 8 bits via `(carry & ((1 << 8) - 1)) as u8`, can prior overflow in carry cause incorrect bytes to be extracted, leading to non-deterministic decoding? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Residual Carry Handling] At lines 270-272, when carry_bits > 0 after the loop, is it possible for carry to contain more than 5 bits, causing data beyond the intended payload to be included in the result? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Leading Zero Reconstruction] The leading zero handling at lines 275-289 mirrors encoding. Can mismatched zero-counting between encode and decode create non-bijective mappings where encode(decode(x)) != x? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Round-Trip Consistency] If an attacker provides a C32 string with mixed case and ambiguous characters (O/o/0, L/l/1, I/i/1), will c32_encode(c32_decode(input)) produce the canonical form, or can this cause consensus nodes to have different address representations? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: double_sha256_checksum()] [Checksum Collision] Using only 4 bytes (32 bits) of the double-SHA256 output at line 297 provides 2^32 checksum space. What is the practical collision probability for an attacker generating addresses with matching checksums to steal funds? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: double_sha256_checksum()] [Truncation Risk] The slice [0..4] at line 297 takes the first 4 bytes. Could a hash collision attack exploit the truncation to create different addresses with identical checksums, bypassing address validation? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: double_sha256_checksum()] [Empty Input] What checksum is computed for empty data? Can this lead to a predictable checksum that an attacker could exploit to generate valid-looking but malformed addresses? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Version Validation] At line 301, version >= 32 is rejected. However, version is u8 (0-255). Can an attacker use version values 32-255 in transaction serialization that bypass this check at a different layer, causing consensus divergence? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Version Integrity] The version is prepended to check_data at line 305 but then separately encoded at line 314. Can a mismatch between these two version usages cause the checksum to validate for the wrong version, enabling address substitution attacks? (Critical)"
]