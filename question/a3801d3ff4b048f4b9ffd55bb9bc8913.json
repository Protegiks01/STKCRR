[
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_tenure_change_tx()] [Nonce Manipulation] Can an attacker cause a nonce collision by manipulating the `nonce` parameter passed to generate_tenure_change_tx(), potentially allowing tenure change transaction replay or rejection? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_tenure_change_tx()] [Chain ID Mismatch] If the `chain_id` from config differs from the actual burnchain chain_id, could this allow cross-chain tenure change replay attacks between mainnet and testnet? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_tenure_change_tx()] [Transaction Version] Does the function validate that the TransactionVersion (Mainnet vs Testnet) matches the burnchain configuration before signing, or could mismatched versions cause consensus issues? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_tenure_change_tx()] [Signature Bypass] If keychain.sign_as_origin() fails silently or the signature is malformed, could an unsigned tenure change transaction be broadcast and accepted by nodes? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_tenure_change_tx()] [Anchor Mode] Is TransactionAnchorMode::OnChainOnly properly enforced for tenure changes, or could an attacker modify this to attempt off-chain tenure manipulation? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_coinbase_tx()] [Nonce Race] Can concurrent calls to generate_coinbase_tx() with the same nonce lead to duplicate coinbase transactions in the same tenure, violating the single-coinbase-per-tenure invariant? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_coinbase_tx()] [Recipient Validation] Does get_coinbase_recipient() properly validate the recipient PrincipalData, or could malformed contract principals cause consensus divergence when processing coinbase payouts? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_coinbase_tx()] [VRF Proof Tampering] Can an attacker modify the VRF proof between generation and coinbase transaction creation, allowing them to claim rewards for a sortition they didn't actually win? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_coinbase_tx()] [Epoch Validation] If get_coinbase_recipient() returns Some() for epochs < Epoch21, does the block builder reject it, or could this create a consensus fork between nodes with different epoch interpretations? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: generate_coinbase_tx()] [CoinbasePayload Zeroing] The CoinbasePayload uses [0u8; 32] - could an attacker exploit this fixed value to grind for hash collisions or manipulate block hashes predictably? (Medium)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: make_vrf_proof()] [Mock Mining Key Leakage] Does VRF_MOCK_MINER_KEY have sufficient entropy, or could predictable mock mining keys allow an attacker to compute valid proofs without actual VRF key registration? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: make_vrf_proof()] [Sortition Hash Manipulation] Can an attacker manipulate burn_election_block.sortition_hash before it's used in proof generation, allowing them to generate proofs for arbitrary sortitions? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: make_vrf_proof()] [Key Height Mismatch] If registered_key.target_block_height doesn't match the actual burn block height, could this allow mining with expired or future VRF keys, bypassing sortition rules? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: make_vrf_proof()] [Proof Verification Bypass] When make_vrf_proof() returns None, does the caller properly abort mining, or could an unverified block be produced without a valid VRF proof? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: make_vrf_proof()] [Mock vs Real Mode Confusion] Can an attacker force mock_mining mode in production by manipulating config, allowing them to bypass VRF proof requirements? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: load_block_parent_info()] [Parent Not Found] If the parent tenure ID is valid but the header isn't in the database yet, does the function properly distinguish between 'not yet processed' and 'invalid parent', avoiding premature mining? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: load_block_parent_info()] [Canonical Tip Mismatch] Can the canonical Stacks tip change between loading it and loading the parent header, creating a TOCTTOU issue where the miner builds on a stale fork? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: load_block_parent_info()] [Tenure Tip Discovery] If find_highest_known_block_in_my_tenure() returns a block that's later orphaned, could the miner continue building invalid blocks in that tenure? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: load_block_parent_info()] [Epoch2 vs Nakamoto Boundary] When mining the first Nakamoto block after an Epoch2 block, does the parent lookup correctly handle the transition, or could this cause consensus issues at the epoch boundary? (Critical)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: load_block_parent_info()] [Nonce Query Race] If the miner's account nonce is queried but the account receives a transaction before mining completes, could this lead to nonce conflicts and rejected tenure change/coinbase transactions? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: ParentStacksBlockInfo::lookup()] [Burn Tip TOCTTOU] The function checks burn_chain_tip against check_burn_block, but can the tip change immediately after this check, allowing mining on stale sortition data? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: ParentStacksBlockInfo::lookup()] [Late Block Exemption] When reason.is_late_block() is true, the burn tip staleness check is skipped - can an attacker exploit this to mine arbitrarily late blocks on very old sortitions? (Medium)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: ParentStacksBlockInfo::lookup()] [Parent Tenure Block Count] If parent_tenure_blocks is miscalculated, could this lead to incorrect tenure change transactions that validators reject, causing the miner to waste resources? (High)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: ParentStacksBlockInfo::lookup()] [Stacks Tip vs Last Tenure Block] When stacks_tip_header != last_parent_tenure_header, the function returns NewParentDiscovered - could this be triggered by normal reorgs, causing excessive mining interruptions? (Medium)",
  "[File: stacks-core/stacks-node/src/nakamoto_node/miner.rs] [Function: ParentStacksBlockInfo::lookup()] [Same Tenure Detection] The check for stacks_tip_header.consensus_hash == parent_tenure_header.consensus_hash determines if we're in the same tenure - could hash collisions cause incorrect tenure detection? (Low)"
]