[
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_lookup_function()] [Fixed Cost Risk] Why is function lookup fixed at u16 - can complex function resolution exceed this cost? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_bind_name()] [Fixed Cost Risk] Is u256 sufficient for all name binding operations, or can deeply nested scopes exceed this cost? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_user_function_application()] [Cost Underestimation] Can the linear formula (n * 26 + 140) be bypassed by functions with expensive setup but cheap per-argument costs? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_let()] [Cost Formula] Is (n * 146 + 862) correct for let bindings - could deeply nested or recursive let expressions exceed this? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_if()] [Fixed Cost Risk] Why is if fixed at u200 regardless of branch complexity - can attackers nest expensive operations in branches? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_asserts()] [Fixed Cost Risk] Is u158 sufficient for assert operations that may involve complex predicate evaluation? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_map()] [Cost Formula] The cost (n * 1210 + 3314) is very high - is this based on worst-case or average-case performance? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_filter()] [Fixed Cost Risk] Why is filter fixed at u460 when it should depend on list size and predicate complexity? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_len()] [Fixed Cost Risk] Is u486 appropriate for len() on all collection types, or do some types require O(n) traversal? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_element_at()] [Fixed Cost Risk] Is u619 sufficient for element-at which may require list traversal for non-indexed collections? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_index_of()] [Cost Underestimation] The linear formula (n * 1 + 243) seems too cheap for index-of which requires O(n) comparison operations? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_fold()] [Fixed Cost Risk] Why is fold fixed at u483 when it should scale with list size and accumulator function cost? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_list_cons()] [Cost Formula] Can the formula (n * 14 + 198) underestimate costs for constructing large lists with complex element types? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_tuple_get()] [Complexity Mismatch] Does nlogn accurately model tuple-get which should be O(log n) with binary search or O(1) with hash lookup? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_tuple_merge()] [Cost Formula] Is (n * 4 + 646) sufficient for tuple merge operations that may need to rebuild entire structures? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_tuple_cons()] [Integer Overflow] Can the nlogn formula overflow when constructing tuples with maximum field counts? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_add()] [Cost Formula] Why does addition have formula (n * 12 + 156) - does n represent bit width, and is this cost adequate for 128-bit integers? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_sub()] [Cost Consistency] Sub has identical formula to add (n * 12 + 156) - is this intentional or should underflow checking cost more? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_mul()] [Cost Formula] Is (n * 14 + 157) sufficient for multiplication which can be O(nÂ²) for large integers? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_div()] [Cost Formula] Division formula (n * 14 + 157) matches mul - but division is typically more expensive and requires zero-check? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_geq()] [Fixed Cost Risk] Are all comparison operations (geq, leq, le, ge) correctly priced at u166, or do some types require more expensive comparison? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_mod()] [Fixed Cost Risk] Is u168 sufficient for modulo operations which may involve division-like algorithms? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_pow()] [Fixed Cost Risk] Why is pow fixed at u170 when exponentiation is O(log exponent) at minimum and can be very expensive? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_sqrti()] [Fixed Cost Risk] Is u167 appropriate for integer square root across all input ranges? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs-2-testnet.clar] [Function: cost_log2()] [Fixed Cost Risk] Is u161 correct for log2 computation regardless of input size? (Low)"
]