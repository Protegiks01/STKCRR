[
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::add_hardcoded()] [Unauthorized DNS Override] The add_hardcoded() method (line 121-123) allows arbitrary insertion of DNS responses without authentication. If this method is exposed through any RPC or configuration interface, can an attacker inject malicious IP addresses for critical hostnames (e.g., Bitcoin nodes, seed nodes) to redirect network traffic? (Critical)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::resolve()] [Hardcoded Lookup Priority] At line 126-128, hardcoded entries are checked first before real DNS resolution. Can an attacker who gains write access to the hardcoded HashMap (e.g., via race condition or deserialization attack) permanently hijack all DNS lookups for specific hostnames, causing persistent man-in-the-middle attacks? (Critical)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSClient::queue_lookup()] [Malformed Hostname] queue_lookup() accepts an arbitrary string for the host parameter (line 253-254). Can an attacker provide a hostname with special characters, excessive length, or embedded nulls that cause to_socket_addrs() to exhibit undefined behavior or trigger CVEs in the underlying libc getaddrinfo()? (High)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::resolve()] [Port Number Validation] The port field in DNSRequest (line 32) is u16, allowing values 0-65535. Does passing port 0 to to_socket_addrs() cause undefined behavior, and can an attacker exploit this to cause DNS resolution failures for legitimate services? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::thread_main()] [Infinite Loop Without Exit Condition] The thread_main() loop at line 211 runs indefinitely until the inbound channel breaks (line 219-222). If the DNSClient is dropped but the inbound channel remains open due to reference counting, does the resolver thread run forever, consuming CPU and preventing clean shutdown? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::thread_main()] [Query Processing After Channel Break] When drain_inbox() returns an error at line 219, the loop breaks immediately. Can this leave unprocessed queries in the VecDeque that will never receive responses, causing the DNSClient to wait indefinitely on poll_lookup() calls? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSRequest::new()] [Timeout Arithmetic] When calculating timeout as get_epoch_time_ms() + duration (typical usage pattern), can an attacker provide a very large duration value that causes u128 overflow, wrapping the timeout to a small value and causing immediate timeout? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::drain_inbox()] [Cast to u64] At line 168, queries.len() is cast to u64 for comparison with max_inflight. On 32-bit systems, can the usize-to-u64 cast cause incorrect overflow detection if VecDeque grows larger than expected? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSClient::clear_all_requests()] [Manual Cleanup Requirement] The clear_all_requests() method (line 343-345) must be called manually to free HashMap memory. If client code never calls this method (e.g., during long-running node operation), does the HashMap grow indefinitely, eventually causing memory exhaustion? (High)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSClient::poll_lookup()] [Single-Use Removal] poll_lookup() removes the request from the HashMap at line 334-338, making each lookup single-use. If an attacker repeatedly calls queue_lookup() for the same host:port, can they cause redundant DNS resolutions that waste resolver CPU, even though the result should be cached? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Structs: DNSResolver/DNSClient] [Unsynchronized Mutable State] DNSResolver (line 85-94) and DNSClient (line 98-103) both contain mutable state accessed from separate threads. Are there any data races between the resolver thread modifying its internal state and the client thread accessing channels, especially during shutdown sequences? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSClient::try_recv()] [Time-of-Check-Time-of-Use] Between clear_timeouts() at line 279 and the loop processing responses at line 282-311, can a request's timeout status change, causing try_recv() to accept a response for a request that has just timed out, leading to inconsistent state? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::handle_query()] [None Return Semantics] When queries is empty, handle_query() returns None (line 196-198). Does the caller thread_main() correctly handle the case where all inflight queries have been processed, or can this cause busy-waiting or missed requests? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSClient::try_recv()] [num_recved Counter] The num_recved counter (line 281) is incremented only for non-timed-out responses (line 288). Does this mean that timed-out responses are not counted, potentially causing the function to return 0 even though it processed responses, leading to incorrect caller assumptions? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSClient::queue_lookup()] [Send Error Mapping] At line 255-257, send() errors are mapped to net_error::LookupError. Does this lose information about whether the error was Disconnected vs Full, preventing the caller from distinguishing between resolver crash and temporary congestion? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::drain_inbox()] [TrySendError Handling] At line 162 and 175, only TrySendError::Disconnected is checked, but TrySendError can also be Full. Does ignoring the Full variant mean overflow/timeout errors are silently dropped when the outbound channel is full, causing lost error notifications? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::thread_main()] [Request Processing Order] The VecDeque processes requests in FIFO order (pop_front at line 194), but drain_inbox() can skip requests that are timed out or exceed max_inflight. Can an attacker send a mix of short-timeout and long-timeout requests to cause legitimate requests to be starved behind timed-out ones? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::thread_main()] [max_inflight Loop Iteration] At line 225, the resolver processes up to max_inflight queries per iteration. If max_inflight is set to a very large value (e.g., u64::MAX), can the resolver spend excessive time resolving queries without checking for new inbound requests, causing request queue backup? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Struct: DNSRequest] [Host String Allocation] The host field (line 31) is a String with no length limit. Can an attacker provide an extremely long hostname (e.g., millions of characters) that causes excessive memory allocation, especially when cloned multiple times throughout the request lifecycle? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResponse::error()] [Error String Construction] Error messages are constructed as Strings (e.g., line 76-79) and can be attacker-controlled via failed DNS lookups. Can maliciously-crafted DNS responses inject extremely long error strings that cause memory exhaustion when stored in DNSResponse objects? (Low)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::new()] [max_inflight Parameter] The max_inflight parameter (line 106) is u64, allowing values up to 2^64-1. Can setting this to an extremely large value cause the drain_inbox() loop (line 157) to iterate billions of times, freezing the resolver thread for extended periods? (Medium)",
  "[File: stacks-core/stackslib/src/net/dns.rs] [Function: DNSResolver::new()] [Channel Buffer Size Mismatch] The inbound and outbound channels both use a fixed capacity of 1024 (line 107-108), but max_inflight is configurable. If max_inflight > 1024, can the resolver queue more requests than the outbound channel can hold, causing response drops when sending? (Medium)"
]