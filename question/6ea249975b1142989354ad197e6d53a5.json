[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_at_block()] [I/O Cost Validation] Does cost_at_block with runtime u1327 and read_count u1, read_length u1 properly account for loading historical block context? Could accessing old block data require more I/O? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_block_info()] [Cost Model Error] Is u6321 for block_info adequate? This is 5x more expensive than at_block - what makes current block info retrieval more expensive than historical block context switching? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_burn_block_info()] [Cost Model Error] Why is burn_block_info u96479, which is 15x more expensive than regular block_info? Could this extreme cost be exploited for DoS by filling blocks with burn block queries? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_load_contract()] [I/O Accounting Error] With read_count: u3 for associated metadata loads, does this accurately reflect the number of database reads? Could loading large contracts require additional metadata fetches? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_create_map()] [Write Cost Validation] Does write_count: u1 and write_length: (linear n u1 u1) correctly account for creating a map entry with n bytes? Should initialization not require additional writes? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_create_var()] [Write Cost Error] Why does create_var have write_count: u2 while create_map has write_count: u1? What is the second write for - metadata storage? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_create_nft()] [Cost Consistency] Is the cost formula for create_nft (linear n u1 u1570) with write_count u1 consistent with create_map and create_var? Should NFT metadata require different accounting? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_create_ft()] [Write Cost Validation] Why is create_ft constant runtime u1831 with write_count u2, while create_nft has linear runtime? What are the two writes - supply tracking and metadata? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_fetch_entry()] [I/O Cost Validation] Does fetch_entry with (linear n u1 u1025) runtime and read_length (linear n u1 u1) properly charge for fetching entries of size n from storage? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_set_entry()] [I/O Accounting Error] With read_count: u1 and write_count: u1, does set_entry account for read-modify-write semantics? Could updating existing entries require additional reads for validation? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_fetch_var()] [Cost Inconsistency] Why is fetch_var (linear n u1 u468) so much cheaper than fetch_entry (linear n u1 u1025)? Should variable and map entry fetching not have similar costs? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_set_var()] [Write Accounting] Does set_var correctly account for both read_count u1 and write_count u1? Should reading the old value before writing be mandatory? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_contract_storage()] [Cost Model Validation] Is (linear n u11 u7165) with very high base cost u7165 appropriate for contract storage operations? What makes this 10x more expensive than set_var? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_stx_balance()] [I/O Cost Validation] Does stx_balance with runtime u4294 and read_count u1, read_length u1 adequately account for balance lookups? Could account state require multiple reads? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_stx_transfer()] [I/O Accounting Error] With read_count u1 and write_count u1, does stx_transfer properly account for reading and updating two account balances (sender and receiver)? Should this be read_count u2, write_count u2? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_stx_account()] [Cost Inconsistency] Why is stx_account (u4654) slightly more expensive than stx_balance (u4294) when both read account data? What additional operation does stx_account perform? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_stx_transfer_memo()] [Cost Consistency] Is stx_transfer_memo (u4709) only u69 more expensive than regular stx_transfer (u4640)? Does this adequately account for memo storage and validation? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ft_mint()] [I/O Accounting Error] With read_count u2 and write_count u2, does ft_mint correctly account for reading/writing both the recipient balance and total supply? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ft_transfer()] [I/O Accounting Error] Does ft_transfer with read_count u2, write_count u2 properly account for sender balance read, receiver balance read, and both balance writes? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ft_balance()] [Cost Model Validation] Is ft_balance (u479) constant runtime appropriate? Does fetching FT balances truly cost the same regardless of token implementation? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ft_get_supply()] [Cost Consistency] Why is ft_get_supply (u420) cheaper than ft_balance (u479) when both perform storage reads? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_ft_burn()] [Cost Consistency] Why does ft_burn have identical cost (u549) to ft_transfer? Should burning not be simpler since it only updates one balance and supply? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_nft_mint()] [Cost Model Validation] Does (linear n u9 u575) correctly scale with NFT asset identifier size n? Could complex NFT metadata require more than linear cost? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_nft_transfer()] [Cost Consistency] Why do nft_mint and nft_transfer have nearly identical formulas (linear n u9 u572 vs u575)? Should minting not be more expensive due to uniqueness checking? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_nft_owner()] [Cost Model Validation] Is (linear n u9 u795) appropriate for NFT owner lookup? Why is this more expensive than nft_transfer (u572)? (Medium)"
]