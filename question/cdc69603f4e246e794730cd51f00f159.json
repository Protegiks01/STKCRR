[
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: get_epoch_time_secs()] [Panic/Consensus Divergence] The function calls .expect('Time went backwards') when duration_since(UNIX_EPOCH) fails. If system time is manually set backwards on a validator node, could this panic cause consensus divergence where some nodes continue processing while others crash? What happens to block validation timing? (Critical)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: get_epoch_time_secs()] [Time Manipulation] If this function is used for consensus-critical timestamp generation (e.g., block timestamps, transaction expiry), can an attacker with control over system time create blocks or transactions with manipulated timestamps that violate protocol timing invariants? (Critical)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: get_epoch_time_ms()] [Integer Overflow] The function returns as_millis() as u128. If this value is later cast to u64 for consensus-critical logic without overflow checks, could timestamp values beyond u64::MAX (year 584554) cause silent truncation and consensus divergence? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: get_epoch_time_ms()] [Panic/DoS] The function panics with 'Time went backwards' on system time errors. If this is called in a P2P message handler or RPC endpoint, can an attacker trigger node crashes by causing system time checks to fail through timing manipulation or NTP attacks? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: get_epoch_time_nanos()] [Precision Inconsistency] If consensus-critical code mixes epoch time in seconds, milliseconds, and nanoseconds without proper conversion checks, could rounding errors or unit confusion lead to off-by-one errors in PoX reward cycle boundaries or tenure timing? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: get_epoch_time_nanos()] [Feature-gated Testing Code] This function is only available under test/testing features. If production code accidentally calls this and it's compiled without the feature, does this cause compilation errors or undefined behavior? Could this lead to different behavior between test and production builds? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: sleep_ms()] [DoS/Deadlock] If sleep_ms() is called within consensus-critical validation paths (e.g., block validation, transaction verification), can an attacker craft inputs that trigger excessive sleep calls, causing DoS through validation delays or missed block deadlines? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: sleep_ms()] [Tenure Timing] If this function is used for backoff or retry logic in burnchain operations or sortition, could improper sleep durations cause nodes to miss critical tenure windows or sortition deadlines, affecting PoX consensus? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Struct: HexError] [Error Handling] The BadLength variant stores usize but the error description hardcodes 'non-64 length'. If consensus-critical hex parsing uses HexDeser with variable-length expectations (not just 64 chars), could misleading error messages mask validation bypasses where wrong-length inputs are incorrectly accepted? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Struct: HexError] [Type Confusion] The HexError enum only handles BadLength and BadCharacter cases. If try_from_hex implementations in other modules fail to validate semantic correctness (e.g., accepting leading zeros, invalid checksums), could malformed hex strings pass HexError checks but violate protocol invariants? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Trait: HexDeser] [Implementation Safety] The HexDeser trait is defined here but implemented elsewhere. If implementations fail to perform constant-time comparisons or proper bounds checking, could timing attacks or buffer overflows occur in hash/key deserialization used for signature verification or VRF proof validation? (Critical)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Trait: HexDeser] [Ambiguous Parsing] The trait provides no specification for case sensitivity (uppercase vs lowercase hex). If different implementations have inconsistent case handling, could this lead to consensus divergence where nodes accept/reject the same hex-encoded transaction differently? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: serialize_json_to_file()] [Path Traversal] The function accepts any AsRef<Path> without validation. If called with untrusted input (e.g., from RPC or config), could an attacker use '../' sequences to write JSON data to arbitrary filesystem locations, potentially overwriting consensus-critical state files or chainstate databases? (Critical)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: serialize_json_to_file()] [Race Condition] File::create() can overwrite existing files without atomic rename. If this is used for writing chainstate checkpoints or MARF state roots, could concurrent writes or crashes during serialization corrupt the file and cause state root mismatches or failed chain recovery? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: serialize_json_to_file()] [Disk Space DoS] The function performs no size checks before serialization. If called with very large serde_json objects (e.g., malicious RPC responses, bloated mempool state), could this exhaust disk space and crash the node or prevent new block storage? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: serialize_json_to_file()] [Error Propagation] The function returns std::io::Error but provides no context about serialization vs write failures. If consensus-critical data fails to serialize (e.g., NaN in floats, infinite recursion), could silent failures lead to missing state persistence without node alerts? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: serialize_json_to_file()] [Non-deterministic Serialization] serde_json may serialize HashMap-based structures in non-deterministic order. If this is used for consensus-critical state snapshots (e.g., MARF tries, contract state), could non-deterministic ordering cause different state root hashes across nodes? (Critical)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: deserialize_json_from_file()] [Path Traversal] The function accepts any AsRef<Path>. If file paths are constructed from untrusted input (RPC parameters, config files), could an attacker read arbitrary files including private keys, node secrets, or other sensitive consensus data? (Critical)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: deserialize_json_from_file()] [Unbounded Memory Allocation] The function reads the entire file into memory via BufReader. If called on a maliciously large file (symlinked to /dev/zero, or crafted JSON bombs with deep nesting), could this cause OOM and node crash during startup or RPC handling? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: deserialize_json_from_file()] [Type Confusion Attack] serde_json deserialization uses type parameter J but provides no runtime validation. If an attacker can control the JSON file contents and the expected type differs from actual data (e.g., expecting config but getting malicious transaction list), could this bypass validation checks and inject malicious data into consensus logic? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: deserialize_json_from_file()] [Symlink Attack] File::open() follows symlinks. If an attacker can create symlinks in directories used for config or state (e.g., /tmp), could they redirect deserialization to read sensitive files or cause the node to parse malformed data from attacker-controlled locations? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: deserialize_json_from_file()] [Schema Mismatch] The function provides no version checking or schema migration. If consensus-critical data structures change between releases and old JSON files are loaded, could this cause deserialization errors that crash the node or worse, silent corruption where old/new fields are misinterpreted? (High)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: cargo_workspace()] [Command Injection] The function calls std::process::Command with env!('CARGO'). If the CARGO environment variable is manipulated at compile time, could an attacker inject arbitrary commands that execute during test builds, potentially compromising the build environment or injecting malicious test data? (Medium)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: cargo_workspace()] [Path Traversal] The function joins relative_path to the workspace root without validation. If test code calls this with untrusted input containing '../' sequences, could tests read or write files outside the workspace, potentially affecting other projects or system files? (Low)",
  "[File: stacks-core/stacks-common/src/util/mod.rs] [Function: cargo_workspace()] [Panic on Failure] The function uses .expect() on command output, UTF-8 parsing, and parent directory lookup. If any of these fail during test execution (e.g., non-UTF8 paths, missing cargo), could this cause test harness crashes that mask other test failures or prevent CI/CD from detecting real bugs? (Low)"
]