[
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: finish_block()] [Validation Bypass] If insert_microblock_pubkey_hash fails, the function returns InvalidStacksBlock error, but the miner rewards and unlocks have already been applied - can this create a state where rewards are granted but the block is rejected? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_microblocks_transactions()] [Fee Overflow] Fees are accumulated using fees.checked_add(u128::from(tx_fee)).expect() which panics on overflow - can an attacker construct a microblock stream with transaction fees that sum to more than u128::MAX to crash the node? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_block_transactions()] [Receipt Size DoS] The function tracks total_size and checks it against MAX_RECEIPT_SIZES (50MB), but tx_receipt.size() can fail and return an error - can an attacker craft transactions that cause size() to fail unpredictably, bypassing the limit check? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: find_next_staging_block()] [PoX Fork Validation] Blocks are checked against sortition snapshot pox_valid flag and orphaned if invalid - but can a block that was valid on one PoX fork be incorrectly orphaned when evaluated on a different fork after a PoX reorg? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: find_next_staging_block()] [Parent Validation Race] The query checks if parent exists in block_headers, but doesn't verify the parent is in the same PoX fork - can this allow attaching blocks to parents from different PoX forks, causing consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: make_scheduled_miner_reward()] [Unauthorized Payment] In epochs >= Epoch21, the recipient is extracted from coinbase_tx.try_as_coinbase() - can an attacker craft a malformed coinbase transaction that passes try_as_coinbase() but contains an invalid recipient principal, leading to unauthorized fund transfer? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: make_scheduled_miner_reward()] [Payment Address Confusion] The MinerPaymentSchedule stores both address (miner_addr) and recipient - if recipient is a contract principal but address is the origin address, can this create confusion in payment processing where funds go to the wrong destination? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_matured_miner_reward()] [Epoch Check Bypass] The function checks evaluated_epoch >= StacksEpochId::Epoch21 to use miner_reward.recipient, otherwise uses miner_reward.address - can a manipulated evaluated_epoch cause funds to be sent to the wrong recipient? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_matured_miner_rewards()] [Coinbase Double Count] The function adds miner_share.coinbase to coinbase_reward, then iterates users_share and adds each reward.coinbase - but parent_share.total() is asserted to equal parent_share.tx_fees_streamed_produced only - can this create a discrepancy in coinbase accounting? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: get_parent_matured_miner()] [Missing Parent Panic] If parent block not found in DB and it's not the genesis block (parent_consensus_hash != FIRST_BURNCHAIN_CONSENSUS_HASH), the function panics with CORRUPTION message - can this panic be triggered by a valid but unexpected blockchain state, causing nodes to crash? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_stx_unlocks()] [Unlock Replay] The function fetches lockups from the boot contract for the current block_height - if multiple Stacks blocks are processed at the same burn height, can unlocks be processed multiple times, inflating the STX supply? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_stx_unlocks()] [Integer Overflow] The total_minted value is accumulated with += amount where amount is u128 - can crafted unlock schedules cause total_minted to overflow u128, corrupting the liquid supply tracking? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: get_coinbase_reward()] [Reward Calculation] The function delegates to epoch.coinbase_reward() - can differences in epoch boundary interpretation cause nodes to calculate different coinbase amounts, leading to consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_matured_miner_reward()] [Balance Overflow] The snapshot.credit(miner_reward_total) can fail if the resulting balance exceeds storage limits - but the error handling in as_transaction may not properly roll back all state changes if credit fails midway through reward processing? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_epoch_transition()] [Epoch Ordering Violation] The while loop checks current_epoch < sortition_epoch.epoch_id and panics if current_epoch > sortition_epoch - but can a corrupted clarity DB state cause current_epoch to equal sortition_epoch when a transition is expected, skipping the transition entirely? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: process_epoch_transition()] [Partial Transition] Each epoch transition calls initialize_epoch_X methods that return receipts - if one initialization partially succeeds then fails, are the receipts and state changes properly rolled back, or can this leave the chain in an inconsistent inter-epoch state? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: block_crosses_epoch_boundary()] [Database Query Failure] The function queries epoch_transitions table and returns bool - if the query fails due to database corruption, does the .expect() cause a crash, or can it return incorrect false, allowing invalid microblock confirmation across epochs? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: check_and_handle_reward_start()] [Reward Cycle Off-By-One] The function uses PoxConstants::static_block_height_to_reward_cycle and returns early if pox_reward_cycle <= 1 - can this skip necessary unlock processing for reward cycle 1 in networks where Epoch 2.1 activates during cycle 1? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: check_and_handle_reward_start()] [Early Return Race] The function checks is_before_reward_cycle and returns Ok(vec![]) if true - but can this check race with sortition DB updates, causing unlock events to be skipped if checked at exactly the cycle boundary? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: check_and_handle_reward_start()] [Handled Flag Bypass] The handled_pox_cycle_start check returns early if true - but if the clarity DB transaction is rolled back after setting this flag, can subsequent blocks skip necessary reward cycle processing? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: get_stacking_and_transfer_and_delegate_burn_ops()] [Epoch Mismatch] Different logic paths for different epochs (2.05 vs 2.1+ vs 2.5+) - can a disagreement about the current epoch between nodes cause different sets of burn ops to be processed, leading to consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: get_stacking_and_transfer_and_delegate_burn_ops_v210()] [Duplicate Processing] The function filters out processed_burnchain_txids from ancestor blocks - but if the txid set is incomplete due to a database error, can burn ops be processed twice, leading to double-stacking or double-transfers? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: get_stacking_and_transfer_and_delegate_burn_ops_v210()] [Search Window Overflow] The search_window calculation uses saturating_sub and try_into - if the conversion to u8 fails due to overflow, what is the behavior, and can this cause burn ops to be skipped? (High)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: delete_orphaned_epoch_data()] [Cascading Orphan] The function marks a block as orphaned and its children, then deletes microblock data - but if a child block was already being processed in another thread, can the race cause the child to be accepted while its parent is orphaned? (Critical)",
  "[File: stackslib/src/chainstate/stacks/db/blocks.rs] [Function: delete_orphaned_epoch_data()] [File Truncation Race] The function calls free_block which truncates the block file to zero - if another thread is reading the block file simultaneously, can this cause read corruption or crash? (High)"
]