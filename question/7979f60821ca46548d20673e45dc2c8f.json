[
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Termination Bypass] Can an attacker manipulate expected_num_rounds or round_index to prevent the run loop from terminating, causing the node to run indefinitely even in test scenarios meant to stop? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Tenure Skip] When leader_tenure is None at line 171, no artifacts are produced. Can an attacker force repeated None tenures (by manipulating sortition outcomes or state) to effectively halt chain progress while still incrementing round_index? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [State Injection] Can invoke_new_tenure() at lines 159-164 modify the tenure state (transactions, block contents) after it's initialized but before run() executes, bypassing mempool and validation rules? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Tenure Execution] Can tenure.run() at lines 165-169 return None due to errors but still leave partial state changes in the chainstate, causing state corruption when the artifacts are missing? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Chain Stall] When artifacts_from_tenure is None at line 201, the code continues without processing any tenure. Can repeated None artifacts cause the chain to stall while burnchain keeps advancing, creating an unbounded gap between burnchain and Stacks chain height? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Consensus Divergence] If tenure artifacts are None but burnchain_tip advances and a new sortition occurs, can nodes diverge on whether to process the missing tenure or skip to the next one? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [State Inconsistency] When continuing at line 201 due to missing artifacts, does the chain_tip remain unchanged while burnchain_tip advances, creating an inconsistent state where callbacks receive mismatched burnchain and chain tips? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Sortition After Skip] If artifacts are None and we continue, can the node still win the next sortition and initialize a new tenure at line 229, building on a chain tip that doesn't include the skipped tenure? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Validation Bypass] At lines 176-181, artifacts are committed without validation (same issue as line 102). Can an attacker in the run loop commit blocks with invalid state transitions, incorrect VRF proofs, or manipulated transaction outcomes? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Race Condition] Can commit_artifacts() at line 176 race with burnchain.sync() at line 184, causing artifacts to be committed to a stale burnchain state or missing the latest sortition? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Double Commit] If commit_artifacts() fails partially (commits block but fails to update indexes), can the same artifacts be committed again in the next iteration, causing duplicate block processing or state corruption? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Sync Error Propagation] burnchain.sync() can return BurnchainControllerError. Does this error properly indicate all failure modes (network issues, invalid blocks, reorganization), or can certain errors be silently ignored leading to state inconsistency? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Chain Reorganization] If burnchain.sync() detects a Bitcoin reorganization, does the code properly handle unwinding Stacks chain state and reprocessing blocks, or can stale burnchain_tip values persist? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Sync State Consistency] Can new_burnchain_tip at line 184 have a height less than or equal to the previous burnchain_tip (during reorganization or stalls), and does the code correctly handle non-monotonic burnchain height? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Panic DoS] At lines 194-196, another panic occurs if process_burnchain_state() returns (None, _). Can legitimate burnchain events (empty blocks, reorganizations, missing VRF keys) trigger this panic? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Sortition State] Is won_sortition at line 195 deterministic based on burnchain state, or can different nodes compute different sortition outcomes for the same burnchain_tip, causing consensus divergence? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Multiple Winners] Can multiple nodes simultaneously believe they won_sortition for the same round, leading to competing tenure attempts and potential double-spend or chain fork scenarios? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Validation Bypass] The comment at line 204 states 'We should have some additional checks here, and ensure that the previous artifacts are legit.' What specific validation is missing for artifacts.anchored_block before process_tenure()? Can invalid blocks pass through? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [State Root Validation] Does process_tenure() at lines 207-213 verify that the state root hash in artifacts.anchored_block matches the computed state after processing all transactions, or can state root mismatches be committed? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Consensus Hash Binding] Is the consensus_hash from last_sortitioned_block at line 209 properly bound to the anchored block's header, or can blocks be processed with incorrect consensus hash bindings? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Microblock Ordering] Does process_tenure() validate that artifacts.microblocks are properly sequenced, signed by the tenure leader, and don't conflict with the anchored block? (High)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Atlas DB Injection] Can make_atlas_db() at line 205 return a corrupted or tampered atlas database that affects attachment resolution during tenure processing? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Chain Tip Race] Can chain_tip be updated at line 207 based on artifacts while another thread is reading chain_tip via callbacks, creating TOCTOU (time-of-check-time-of-use) vulnerabilities? (Medium)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Fork Choice] If process_tenure() discovers a higher-weight fork during processing, does chain_tip get updated to point to the canonical tip, or can it point to a stale branch? (Critical)",
  "[File: stacks-core/stacks-node/src/run_loop/helium.rs] [Function: start()] [Genesis Consistency] The genesis chain_tip is created with ChainTip::genesis() using BurnchainHeaderHash::zero() at line 66. Can this zero hash cause collisions or confusion with actual burnchain blocks? (Medium)"
]