[
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-pox-lock-period()] [Constants] If MIN_POX_REWARD_CYCLES or MAX_POX_REWARD_CYCLES are misconfigured or undefined, can the boundary checks fail and allow arbitrary lock periods? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-pox-lock-period()] [Edge Case] Can lock-period equal to exactly MIN_POX_REWARD_CYCLES or MAX_POX_REWARD_CYCLES be rejected due to incorrect use of > or < instead of >= or <=? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [Integer Overflow] Can adding u1 to current-pox-reward-cycle overflow, causing first-reward-cycle to wrap to zero and stack to past cycles? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [Validation Bypass] Can specifying a start-burn-ht in the distant future bypass the is-eq check if the subtraction in burn-height-to-reward-cycle wraps due to overflow? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [Access Control] Can check-caller-allowed return true for an expired allowance if the expiry logic in that function has off-by-one errors? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [State Consistency] Can get-stacker-info return none while the user actually has active stacking state if the expiry check has logic errors? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [State Consistency] Can get-check-delegation return none while delegation-state still has an entry, creating inconsistent delegation checks? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [Balance Check] Can stx-get-balance return a stale value, allowing a user to stack more than they have if concurrent transactions spend the balance? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [Integer Overflow] Can adding first-reward-cycle and lock-period overflow when calculating unlock-burn-height, causing STX to unlock much earlier than intended? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [State Consistency] If add-pox-addr-to-reward-cycles fails partway through, can the reward cycles be left in an inconsistent state with partial additions? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-stx()] [State Consistency] After map-set stacking-state succeeds, if the node fails to execute the actual lock, can the stacker be marked as locked without STX actually being locked? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: delegate-stx()] [Validation] Can amount-ustx be set to u0, allowing delegation of zero STX and bypassing minimum delegation requirements? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: delegate-stx()] [Validation] Can until-burn-ht be set to a value less than current burn-block-height, creating an immediately expired delegation? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: delegate-stx()] [Access Control] Can check-caller-allowed be bypassed if the allowance-contract-callers map is manipulated through race conditions? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: delegate-stx()] [Validation] Can the match on pox-addr fail to check hashbytes length, allowing delegation to invalid address formats? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: delegate-stx()] [State Consistency] Can get-check-delegation return none while a valid delegation exists if the expiry logic is incorrect? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: delegate-stx()] [Logic Error] Can a user create multiple delegations to different delegates by exploiting race conditions in the is-none check? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [State Consistency] Can unwrap! on map-get partial-stacked-by-cycle cause denial of service if an attacker commits before any partial stacking is done? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [Access Control] Can check-caller-allowed be bypassed through reentrancy if the same function is called recursively? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [Validation Bypass] Can can-stack-stx checks be bypassed if reward-cycle is in the past, allowing commitment of already-finished cycles? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [State Consistency] Can add-pox-addr-to-ith-reward-cycle with num-cycles u1 create inconsistencies if the cycle is already fully populated? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [List Access] Can element-at return none and cause unwrap-panic if reward-set-indexes is empty due to a bug in add-pox-addr-to-ith-reward-cycle? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [State Consistency] After map-delete partial-stacked-by-cycle, can a second commit for the same pox-addr/reward-cycle succeed and double-count the stacked amount? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: inner-stack-aggregation-commit()] [State Consistency] Can logged-partial-stacked-by-cycle overwrite previous values, losing history of aggregate commits? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: stack-aggregation-increase()] [State Consistency] Can unwrap! on map-get partial-stacked-by-cycle fail if the partial amount was already committed, leaving no way to increase the commitment? (High)"
]