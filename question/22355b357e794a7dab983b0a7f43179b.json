[
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stx()] [Already Stacking Check Removed] Since the comment states delegate-stx no longer requires the delegator to not be stacking, can a direct stacker delegate simultaneously, and does this create state conflicts in stacking-state map? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stx()] [Already Delegated Check] The assertion at line 674 checks is-none for existing delegation, but get-check-delegation can return none if delegation expired; can an expired delegation be treated as no delegation, allowing re-delegation without revocation? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Delegation Timing Attack] Can a delegate call delegate-stack-stx() for a stacker whose delegation is about to expire (until-burn-ht check at line 992), locking STX that will outlive the delegation period? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Partial Stacking Accumulation] If add-pox-partial-stacked() is called but stack-aggregation-commit() is never invoked, do the partial amounts remain locked without earning rewards, enabling a griefing attack? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [First Reward Cycle Calculation] With first-reward-cycle set to (+ u1 (current-pox-reward-cycle)), can a transaction mined at cycle boundary N be treated as cycle N+1, causing misalignment with unlock-burn-height calculation? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Already Stacked Check] The assertion at line 999 checks is-none for get-stacker-info, but this returns none if lock expired; can a stacker with expired lock be re-stacked by delegate without cleanup, causing reward-set-indexes corruption? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Balance Check Race] Can the balance check (>= (stx-get-balance stacker) amount-ustx) at line 1003 pass, but the actual lock fail if stacker's balance decreases between check and lock due to concurrent transactions? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Delegated-To Field] The stacking-state is set with delegated-to: (some tx-sender), but if delegate permissions are revoked before stack-aggregation-commit(), can partial amounts be committed by the original delegate? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Empty Reward Set Indexes] Setting reward-set-indexes to empty list means stacker is delegating, but if delegate never commits, will auto-unlock fail since there are no indexes to clear from reward cycles? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: delegate-stack-stx()] [Unlock Height Calculation] The unlock-burn-height is calculated as reward-cycle-to-burn-height((+ (current-pox-reward-cycle) u1 lock-period)), but can this mismatch the actual lock if current-pox-reward-cycle changes during transaction execution? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-reward-cycles()] [Reward Set Index Mismatch] If fold over add-pox-addr-to-ith-reward-cycle produces fewer indexes than num-cycles due to fold early termination, will the assertion at line 425 trigger ERR_STACKING_UNREACHABLE incorrectly? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-reward-cycles()] [Index List Overflow] The reward-set-indexes list has max length u12, but if num-cycles exceeds 12, will unwrap-panic at line 404 crash the contract or will as-max-len? silently truncate? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-reward-cycles()] [Invariant Violation] If the function succeeds in adding to some reward cycles but fails partway, will partial state be committed, violating the atomic operation expectation? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-reward-cycles()] [Stacker Principal Binding] The function passes (some stacker) to add-pox-addr-to-ith-reward-cycle, but if stacker is delegating, should this be none instead to match delegation semantics? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Cycle Bounds Check] If (get i params) equals or exceeds (get num-cycles params), the function returns unchanged params but increments i in next-i calculation; can this cause infinite loops or missed cycles? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Total Stacked Overflow] When adding (get amount-ustx params) to existing total-ustx at line 392, can integer overflow occur if multiple large stackers target the same reward cycle? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Reward Index Append] If append-reward-cycle-pox-addr returns an index, but unwrap-panic on as-max-len? at line 404 fails due to list length exceeding u12, will this abort all stacking operations? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: add-pox-addr-to-ith-reward-cycle()] [Signer Key Propagation] The signer parameter is passed through but never validated for uniqueness within a reward cycle; can multiple stackers use the same signer key, breaking DKG? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: append-reward-cycle-pox-addr()] [Race Condition] If get-reward-set-size returns size N, but another transaction inserts at index N concurrently, will map-set at line 338 overwrite the concurrent insertion? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: append-reward-cycle-pox-addr()] [Length Increment] The function increments len by u1 at line 343, but if map-set to reward-cycle-pox-address-list fails silently, will len be incorrect? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: append-reward-cycle-pox-addr()] [Return Value Usage] The function returns sz (the index before increment), but can callers mistakenly use this as the post-increment index, causing off-by-one errors in reward-set-indexes? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: inner-stack-aggregation-commit()] [Partial Stacked Cleanup] After map-delete of partial-stacked-by-cycle at line 839, if the transaction reverts, will the partial amounts be lost permanently? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: inner-stack-aggregation-commit()] [Reward Cycle Timing] If reward-cycle parameter is current-pox-reward-cycle or past cycle, can delegate commit to already-active cycles, gaining unfair reward distribution? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: inner-stack-aggregation-commit()] [Minimum Threshold] The can-stack-stx check at line 817 verifies minimum threshold, but partial-stacked amounts may have been accumulated below minimum; can this bypass minimum enforcement for delegated stacking? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-4.clar] [Function: inner-stack-aggregation-commit()] [Stacker Field None] The add-pox-addr-to-ith-reward-cycle is called with stacker: none at line 827; does this mean delegates cannot be identified in reward-cycle-pox-address-list, breaking accountability? (Medium)"
]