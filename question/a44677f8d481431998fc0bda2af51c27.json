[
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: StacksWorkScore::initial()] [Genesis Mismatch] Could the hardcoded initial work score (burn: 0, work: 1) mismatch the actual genesis block state, causing fork choice inconsistencies when comparing chains starting from different genesis assumptions? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: StacksWorkScore::genesis()] [Work Score Underflow] Does the genesis() work score of (burn: 0, work: 0) properly handle chain comparisons, or could it underflow in fork choice arithmetic that assumes work >= 1, leading to incorrect canonical chain selection? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: StacksWorkScore::consensus_deserialize()] [Integer Overflow] Can consensus_deserialize() accept u64::MAX values for burn or work that cause overflow in subsequent work score comparisons or additions, enabling work score manipulation attacks? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Struct: StacksWorkScore] [Comparison Invariant] Do the burn and work fields maintain the invariant that higher work scores represent more valid chains, or could an attacker craft scores where burn and work conflict, causing non-deterministic fork choice? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: StacksBlockId::new()] [Hash Order Dependency] Does the order of hashing (block_hash then consensus_hash) in StacksBlockId::new() match all other block ID computations system-wide, or could order inconsistencies cause the same block to have different IDs in different contexts? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: StacksBlockId::first_mined()] [Genesis Constant Mismatch] Could the first_mined() ID derived from FIRST_BURNCHAIN_CONSENSUS_HASH and FIRST_STACKS_BLOCK_HASH mismatch actual genesis block data, causing chainstate initialization failures or consensus divergence? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Struct: TenureBlockId] [Type Confusion] Can the TenureBlockId newtype wrapper be incorrectly used interchangeably with StacksBlockId, causing tenure-change blocks to be processed as regular blocks or vice versa, violating consensus rules? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFSeed::initial()] [Genesis VRF Mismatch] Does the hardcoded initial VRF seed (all zeros) match the actual genesis block VRF data, or could mismatches cause sortition validation failures in early blocks? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFSeed::from_proof()] [VRF Validation Bypass] Does from_proof() validate the VRFProof before computing the seed, or could an attacker provide invalid proofs that produce valid-looking seeds, bypassing VRF verification and enabling unauthorized block production? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFSeed::is_from_proof()] [Timing Side Channel] Could the vector comparison in is_from_proof() leak timing information about VRF seeds through byte-by-byte comparison, enabling side-channel attacks to extract VRF proof data? (Medium)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFSeed::from_proof()] [Determinism] Is the Sha512Trunc256Sum hash of VRFProof bytes deterministic across all implementations and platforms, or could endianness or serialization differences cause nodes to derive different seeds from the same proof? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BlockHeaderHash::to_hash160()] [Hash Downgrade] Does converting BlockHeaderHash to Hash160 preserve sufficient entropy, or could the SHA256 to Hash160 conversion enable collision attacks where different blocks map to the same Hash160? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BlockHeaderHash::from_serializer()] [Serialization Non-determinism] Could consensus_serialize() produce different byte sequences for the same logical object across implementations, causing from_serializer() to generate different block header hashes and consensus divergence? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BlockHeaderHash::from_serialized_header()] [Hash Collision] Does from_serialized_header() validate the header structure before hashing, or could malformed headers produce valid-looking hashes that bypass header validation later? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BurnchainHeaderHash::from_bitcoin_hash()] [Endianness Bug] Does the from_bytes_be() conversion in from_bitcoin_hash() correctly handle Bitcoin's big-endian storage, or could endianness confusion cause burnchain block misidentification and sortition failures? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BurnchainHeaderHash::to_bitcoin_hash()] [Endianness Asymmetry] Is the reverse() operation in to_bitcoin_hash() the exact inverse of from_bitcoin_hash(), or could asymmetric conversions cause burnchain hash corruption when round-tripping through Bitcoin APIs? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BurnchainHeaderHash::from_bitcoin_hash()] [Unwrap Panic] Could the unwrap() in from_bytes_be() panic if Bitcoin hash sizes ever differ from 32 bytes, causing DoS when processing burnchain data from unexpected sources? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BurnchainHeaderHash::zero()] [Invalid Hash] Is the all-zeros burnchain hash (zero()) a valid sentinel value, or could it collide with actual Bitcoin block hashes or cause validation failures in sortition logic? (Medium)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: BurnchainHeaderHash::from_test_data()] [Test Data Leakage] Could from_test_data() accidentally be called in production code, generating predictable burnchain hashes that bypass burn block validation and enable sortition manipulation? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFProof::consensus_deserialize()] [Invalid Proof Acceptance] Does from_slice() in consensus_deserialize() validate the VRF proof structure, or could invalid proofs be deserialized and stored, later causing verification failures that fork the chain? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFProof::consensus_deserialize()] [Buffer Overflow] Could the fixed 80-byte read in consensus_deserialize() cause buffer overflows or underflows if VRF_PROOF_ENCODED_SIZE is inconsistent with VRFProof::from_slice() expectations? (High)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: VRFProof::consensus_serialize()] [Non-deterministic Encoding] Does to_bytes() produce a deterministic canonical encoding of VRF proofs, or could different valid encodings of the same proof cause consensus divergence in block validation? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: (ConsensusHash, BurnchainHeaderHash)::consensus_serialize()] [Order Dependency] Is the serialization order (consensus_hash then burn_header_hash) consistent system-wide, or could order mismatches cause deserialization to swap the fields, corrupting sortition data? (Critical)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Function: (ConsensusHash, BurnchainHeaderHash)::consensus_deserialize()] [Partial Read] Could read failures after reading consensus_hash but before burn_header_hash leave the tuple in a partially-read inconsistent state that corrupts subsequent deserialization? (Medium)",
  "[File: stacks-core/stacks-common/src/types/chainstate.rs] [Struct: TrieHash + PoxId] [State Root Manipulation] Can an attacker manipulate TrieHash computation to match a malicious PoxId's expected state root, bypassing MARF validation and injecting fake chainstate that violates PoX reward cycles? (Critical)"
]