[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_bitwise_left_shift()] [Cost Model Error] Is constant u167 sufficient for left shift? Could shifting by large amounts (near max bit-width) or shifting large integers consume more resources? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_bitwise_right_shift()] [Cost Model Error] Why do left shift and right shift have identical constant costs u167? Is the implementation truly symmetric, or could arithmetic vs logical shifts have different costs? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_hash160()] [Cost Model Validation] Is (linear n u1 u188) correct for HASH160 over n bytes? Does this match the actual implementation's per-byte cost and setup overhead? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_sha256()] [Cost Model Validation] Does (linear n u1 u100) accurately reflect SHA256 performance? Could the coefficient u1 be too low for the per-byte hashing cost? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_sha512()] [Cost Inconsistency] Why does SHA512 have base cost u176 with (linear n u1 u176) while SHA256 has base cost u100? Should SHA512 not be more expensive per byte due to 64-bit operations? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_sha512t256()] [Cost Underestimation] Is (linear n u1 u56) with very low base cost u56 correct for SHA512/256? Should this not have similar costs to regular SHA512? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_keccak256()] [Cost Model Validation] Does (linear n u1 u127) accurately represent Keccak256 cost? Could the coefficient be too low compared to the actual Keccak-f permutation cost? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_secp256k1recover()] [Cost Model Error] Is constant u8655 sufficient for secp256k1 signature recovery? Could the elliptic curve operations consume variable time based on signature properties, and is worst-case accounted for? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_secp256k1verify()] [Cost Model Error] Why is secp256k1verify (u8349) slightly cheaper than secp256k1recover (u8655)? Should signature verification not have similar cost to recovery since both require point multiplication? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_print()] [Cost Underestimation] Does (linear n u15 u1458) adequately charge for printing n bytes? Could serialization of complex nested structures be undercharged? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_some_cons()] [Cost Consistency] Why do cost_some_cons, cost_ok_cons, and cost_err_cons all have identical constant costs u199? Is wrapping different types truly identical in cost? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_default_to()] [Cost Model Error] Is constant u268 for default_to appropriate? Could evaluating the default value or checking the option consume variable cost? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_unwrap_ret()] [Cost Inconsistency] Why do cost_unwrap_ret (u274) and cost_unwrap_err_or_ret (u302) have different costs when both perform unwrapping and early return? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_try_ret()] [Cost Model Error] Is constant u240 for try_ret adequate regardless of the wrapped value's size or the early-return logic complexity? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_match()] [Cost Model Error] Why is match cost constant u264 when pattern matching could involve complex arm evaluation and value extraction? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_or()] [Cost Consistency] Do cost_or and cost_and correctly use identical formulas (linear n u3 u120)? Could short-circuit evaluation make costs asymmetric? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_append()] [Cost Underestimation] Is (linear n u73 u285) sufficient for append? Could appending to large sequences require memory reallocation or copying that exceeds linear cost? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_concat()] [Cost Underestimation] Does (linear n u37 u220) adequately charge for concatenating sequences of total length n? Could quadratic behavior occur if implementations repeatedly reallocate memory? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_as_max_len()] [Cost Model Error] Why is as_max_len constant u475 when checking maximum length constraints could depend on the actual sequence length n? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_slice()] [Cost Model Error] Is constant u448 for slice correct? Should the cost not depend on the slice length or position within the sequence? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_replace_at()] [Cost Underestimation] Does (linear n u1 u561) adequately account for replacing elements at index positions? Could this require sequence traversal or reconstruction? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_contract_call()] [Cost Model Error] Why is contract_call only u134 when calling contracts involves significant overhead for context switching, argument marshaling, and execution setup? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_contract_of()] [Cost Model Error] Is u13400 for contract_of justified? This is 100x more expensive than contract_call - what makes retrieving the contract principal so expensive? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_principal_of()] [Cost Model Error] Is u984 for principal_of appropriate? Could public key to principal derivation consume variable time based on key properties? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/costs-3.clar] [Function: cost_as_contract()] [Cost Model Error] Why is as_contract only u138 when it changes execution context? Should this not be more expensive? (Low)"
]