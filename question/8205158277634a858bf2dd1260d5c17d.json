[
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: parse_script()] [Parser Edge Case] Does accepting non-minimal pushdata via script.iter(false) allow an attacker to craft multiple canonical representations of the same Bitcoin transaction, potentially causing consensus divergence between nodes that normalize scripts differently? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: parse_script()] [DoS] Can an attacker submit a Bitcoin transaction with deeply nested or malformed script instructions that cause script.iter(false) to consume excessive CPU or memory during parsing, leading to node resource exhaustion? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: parse_script()] [Consensus] Does the non-minimal pushdata acceptance create ambiguity in transaction identification, allowing the same logical transaction to be parsed differently by nodes using minimal vs non-minimal encodings? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_p2pkh_script_sig()] [Array Bounds] Can an attacker provide an instructions slice with length != 2 that bypasses the early return check at line 45-47, potentially causing panics in subsequent .get(0) and .get(1) calls? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_p2pkh_script_sig()] [Type Confusion] If instructions.len() == 2 but the first instruction is PushBytes containing valid public key data and the second is also valid public key data, does the function incorrectly accept this as P2PKH when it should be rejected? (Medium)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_p2pkh_script_sig()] [Signature Validation Bypass] Does the function at lines 52-69 validate that data1 (the signature) has valid DER encoding and length, or can an attacker supply arbitrary bytes that get stored without validation? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_p2pkh_script_sig()] [Public Key Validation] At line 55, when BitcoinPublicKey::from_slice(data2) succeeds, are all public key formats (compressed, uncompressed, hybrid) properly validated for curve membership and non-infinity? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_p2pkh_script_sig()] [Consensus] Does accepting both compressed and uncompressed public keys in P2PKH scripts at line 55-64 create transaction malleability if different encodings of the same key produce different transaction hashes? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_p2pkh_script_sig()] [Key Reuse] Does the function at lines 58-63 allow an attacker to reuse the same public key across multiple transactions without any tracking, enabling address reuse attacks that violate privacy assumptions? (Medium)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Integer Validation] At line 87, if num_sigs is usize::MAX or a very large value, can this cause integer overflow when checking num_sigs < 1 or when comparing against pubkey_pushbytes.len()? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Multisig Threshold] The check at line 87 validates num_sigs < 1 || pubkey_pushbytes.len() < num_sigs, but can an attacker craft num_sigs == 0 and pubkey_pushbytes.len() == 0 to bypass this check and create a 0-of-0 multisig? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Array Allocation] At line 99, if pubkey_pushbytes.len() is extremely large (e.g., close to usize::MAX), can Vec::with_capacity cause OOM or allocation failures that aren't handled gracefully? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Public Key Validation] In the loop at lines 101-116, if BitcoinPublicKey::from_slice fails for a malformed key but inspect_err at line 109-112 only logs a warning, does this create partial validation states? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Type Confusion] At line 102, if pk_bytes is not Instruction::PushBytes (e.g., it's an opcode), the function returns None at line 105, but can specially crafted instruction sequences bypass this check? (Medium)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Duplicate Keys] Does the function at lines 101-116 check for duplicate public keys in the keys vector, or can an attacker create a 2-of-3 multisig using the same key three times to effectively control the address alone? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Segwit Flag] At lines 122-126, the in_type is set based on the segwit boolean, but is there validation that segwit transactions actually contain witness data, or can non-segwit txs be mislabeled? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_pubkey_pushbytes()] [Resource Exhaustion] If pubkey_pushbytes contains 16 entries (the Bitcoin multisig maximum), does the public key validation at lines 108-113 perform expensive elliptic curve operations that could be exploited for DoS? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_witness_pubkey_vecs()] [Integer Validation] At line 137, the check num_sigs < 1 || pubkey_vecs.is_empty() || pubkey_vecs.len() < num_sigs can be bypassed if num_sigs overflows during cast, allowing invalid threshold schemes? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_witness_pubkey_vecs()] [Witness Data Validation] At line 151, BitcoinPublicKey::from_slice(&payload[..]) parses witness data as a public key, but are there checks that the witness vector entries have valid lengths before slicing? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_witness_pubkey_vecs()] [Empty Vector] If pubkey_vecs contains empty Vec<u8> elements, does the slice &payload[..] at line 151 cause out-of-bounds access or does from_slice handle empty inputs safely? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_witness_pubkey_vecs()] [Type Assignment] At lines 161-166, the function hardcodes in_type as BitcoinInputType::SegwitP2SH regardless of whether it's P2WPKH or P2WSH, can this cause type confusion in downstream validation? (Medium)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_witness_pubkey_vecs()] [Duplicate Keys in Witness] Does the loop at lines 150-159 check for duplicate public keys in witness data, allowing an attacker to create effective 1-of-3 multisigs using three copies of one key? (Critical)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_witness_pubkey_vecs()] [Capacity Pre-allocation] At line 148, Vec::with_capacity(pubkey_vecs.len()) allocates based on untrusted input length, can extremely large values cause memory exhaustion? (Medium)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_multisig_redeem_script()] [Instruction Parsing] At line 177, if multisig_script is PushBytes containing malicious data, can the Script::from at line 179 and parse_script at line 180 be exploited to cause parser confusion? (High)",
  "[File: stackslib/src/burnchains/bitcoin/bits.rs] [Function: from_bitcoin_multisig_redeem_script()] [Minimum Length] The check at lines 182-188 requires multisig_instructions.len() < 4, but can an attacker craft exactly 4 instructions that bypass validation while not forming a valid multisig? (Medium)"
]