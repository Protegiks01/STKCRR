[
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Identity] Does add(&zero()) correctly preserve the original value without precision loss? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Zero Result] Does sub(&self) return Some(zero()) rather than None, and is this behavior tested? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Identity] Does mul(&one()) return the original value exactly, without any bit shifts corrupting the result? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Annihilation] Does mul(&zero()) return Some(zero()), and can this be optimized away in a consensus-unsafe manner? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [Floating Point] Does the division at line 38 use only integer arithmetic, or can floating-point instructions be generated by the compiler causing non-determinism? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Carry Propagation] Can carry bits propagate differently on different CPU architectures during addition at line 74, causing consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Instruction Selection] Can the compiler emit different multiplication instructions (e.g., SIMD vs scalar) on different platforms, producing different results at line 92? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Conversion Determinism] Does the << 192 operation at line 132 produce identical results on 32-bit vs 64-bit architectures? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Initialization Order] Is the ATC_LOOKUP array initialized deterministically at compile-time, or can runtime initialization order cause different values on different nodes? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::frac()] [MEV Attack] Can a malicious miner craft numerator and denominator values that cause integer overflow in frac(), crashing nodes and winning by default? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [DoS Attack] Can an attacker cause add() to repeatedly return None on overflowing values, forcing expensive recomputation in sortition logic? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Probability Manipulation] Can a miner manipulate their commit amount to create mul() inputs that overflow, forcing null miner to win unfairly? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Sortition Bias] Can the >= comparison at line 128 be exploited to force probabilities to maximum value, biasing sortition outcomes? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Constant: ATC_LOOKUP] [Table Poisoning] If an attacker could modify ATC_LOOKUP values through a supply chain attack, could they guarantee null miner wins or losses? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::is_overflowed()] [Expensive Check] Does calling max() at line 68 for every overflow check cause performance issues if called in tight loops during block validation? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Computational Cost] Can the 256-bit multiplication at line 92 be exploited in a DoS attack by crafting transactions that force many expensive mul() operations? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::into_sortition_probability()] [Branch Prediction] Does the conditional at line 128 create a side-channel timing leak that reveals ATC values to network observers? (Low)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::to_f64()] [Test-Only Code] Is the to_f64() function at lines 1186-1190 properly gated with #[cfg(test)], or could production code use it and introduce floating-point non-determinism? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::from_f64_unit()] [Test-Only Code] Is from_f64_unit() at lines 1194-1206 only callable in tests, or could a production code path accept f64 inputs and break consensus determinism? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::to_f64()] [Floating Point Conversion] Does the f64 conversion at lines 1187-1189 correctly represent the fixed-point value, or can precision loss corrupt test validation? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::from_f64_unit()] [Range Check] Does the panic at line 1196 for values outside [0.0, 1.0) properly protect against invalid test inputs, or can >= 1.0 values slip through? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::from_f64_unit()] [Scaling Accuracy] Does the scaling multiplication at line 1201 correctly convert f64 fractional values to the 64-bit fixed-point representation? (High)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::add()] [Maximum Addition] Can adding two max() values cause Uint256 to overflow before the is_overflowed() check detects it at line 75? (Critical)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::sub()] [Minimum Subtraction] Does subtracting one() from one() correctly return Some(zero()), or can precision loss make it return a non-zero value? (Medium)",
  "[File: stackslib/src/chainstate/burn/atc.rs] [Function: AtcRational::mul()] [Square Operation] When computing self.mul(&self), can intermediate overflow occur even if the final result fits in AtcRational range? (High)"
]