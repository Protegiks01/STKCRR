[
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: open()] [Race Condition] Can concurrent calls to open() on the same database path result in table creation races or duplicate row insertions despite the table_exists check, potentially corrupting the singleton estimate row? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: open()] [Initialization] The decay_rate is hardcoded to 0.5. Can an attacker exploit this fixed value to manipulate fee estimates by timing their high-fee transactions to coincide with blocks that will have maximum decay impact? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: instantiate_db()] [SQL Injection] Although parameterized queries are used elsewhere, does the CREATE_TABLE statement at line 20-26 properly prevent any SQL injection if the table name or schema could be influenced by external input? (Low)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: db_already_instantiated()] [Logic Error] Can the table_exists check return false positives if the table exists but is corrupted or has an incorrect schema, leading to skipped initialization that breaks fee estimation? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Constant: SINGLETON_ROW_ID] [Invariant Violation] Is there any enforcement that only row ID 1 exists in the database? Could multiple rows be inserted breaking the singleton pattern and causing non-deterministic fee estimates? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Division by Zero] At line 200-205, the fee_rate calculation divides by scalar_cost. While there's a check for scalar_cost >= 1, can scalar_cost ever be 0 before this check, and what happens if the max(1, scalar_cost) logic is bypassed? (High)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Floating Point Precision] The fee_rate calculation at line 200 converts u64 fee to f64. Can precision loss during this conversion or the division operation lead to incorrect fee rate estimates for very large fee values (near u64::MAX)? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Edge Case] At line 206-210, fee rates less than 1.0 or non-finite are replaced with 1.0. Could an attacker craft transactions with fees/costs that intentionally trigger this saturation to skew the percentile calculations? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Logic Error] The filter_map at lines 153-211 filters out None values. If all transactions in a block return None (e.g., only Coinbase and Burn transactions), does the empty all_fee_rates vec at line 219 correctly handle this case without panicking? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Integer Overflow] When calculating scalar_cost via metric.from_cost_and_len(), can the ExecutionCost components overflow during the dot product calculation, resulting in incorrect scalar values that underestimate fees? (High)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Cost Accounting] For TokenTransfer transactions at lines 161-181, hardcoded ExecutionCost values are used (write_length from STXBalance, runtime: 4640). Can these hardcoded values become outdated across Stacks epochs, leading to incorrect fee rate estimates? (High)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Type Confusion] The STXBalance::LockedPoxThree variant is hardcoded at lines 163-167 for calculating stx_balance_len. Can different PoX versions (Pox1, Pox2, Pox4) have different serialization lengths, making this calculation incorrect for other epochs? (High)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Filter Bypass] Coinbase transactions return None at line 185, excluding them from fee estimation. Could an attacker craft a transaction that appears as a Coinbase to bypass fee estimation while actually executing contract logic? (Critical)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Inconsistent Treatment] PoisonMicroblock, ContractCall, SmartContract, and TenureChange all use tx_receipt.execution_cost at line 194. Can TenureChange transactions, which are consensus-critical, manipulate their execution_cost to skew fee estimates? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Missing Validation] The match at lines 154-159 extracts payload, fee, and tx_size from TransactionOrigin::Stacks but returns None for TransactionOrigin::Burn. Can malformed Burn transactions be crafted to be processed as Stacks transactions? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Off-by-One Error] The highest_index calculation at line 221 uses measures_len - max(1, measures_len / 20). For measures_len = 20, this gives index 19, but for measures_len = 19, does this correctly represent the 95th percentile or is it off by one? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Index Out of Bounds] At lines 225-233, get() is called with highest_index, median_index, and lowest_index. For very small blocks with 1-2 transactions, can these indices exceed the vector bounds despite the measures_len > 0 check? (High)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Integer Division] The median_index at line 222 uses measures_len / 2. For measures_len = 1, this gives index 0. For measures_len = 2, this also gives index 0. Is this the correct median behavior or should it be (measures_len - 1) / 2? (Low)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Percentile Manipulation] An attacker who can submit multiple transactions in a block could manipulate the 5th/50th/95th percentiles. If 20+ transactions with identical high fee rates are submitted, does this disproportionately influence the high estimate? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: notify_block()] [Sort Instability] The sort_by at line 213 uses partial_cmp with an expect() that assumes no NaN/infinite values. If the filter at line 206 fails to catch a non-finite value, could this panic and halt fee estimation? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: update_estimate()] [Arithmetic Overflow] The decay calculation at lines 84-86 multiplies f64 FeeRateEstimate values by decay_rate and (1 - decay_rate). Can these operations overflow or underflow f64 limits for extreme fee rate values, producing infinite or NaN results? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: update_estimate()] [Floating Point Instability] The comment at lines 88-90 mentions 'integer math' causing edge effects when estimate < decay_rate, but the code uses f64. Is this comment outdated, and are there still edge effects with floating point arithmetic? (Low)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: update_estimate()] [Minimum Saturation] Lines 91-105 saturate estimates at 1.0. If the true market fee rate is below 1 microSTX per scalar unit, does this saturation create incorrect pricing signals that reject valid low-fee transactions? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: update_estimate()] [State Initialization] At line 109, NoEstimateAvailable returns new_measure.clone() as the first estimate. Can the very first block processed by a node have anomalous fee rates that permanently skew estimates due to high decay_rate (0.5)? (Medium)",
  "[File: stackslib/src/cost_estimates/fee_scalar.rs] [Function: update_estimate()] [Error Handling] At lines 110-113, any EstimatorError other than NoEstimateAvailable logs a warning and returns early without updating. Could a persistent database error freeze fee estimates at stale values indefinitely? (High)"
]