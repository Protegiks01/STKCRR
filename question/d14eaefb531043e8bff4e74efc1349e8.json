[
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: set-burnchain-parameters()] [Authorization Bypass] Can an attacker call set-burnchain-parameters multiple times by racing the configured flag check at line 38, allowing manipulation of reward cycle lengths and first burnchain block height after initialization? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: set-burnchain-parameters()] [Parameter Validation] Does set-burnchain-parameters validate that first-burn-height, prepare-cycle-length, reward-cycle-length, and rejection-fraction are non-zero and within reasonable bounds, or can zero/extreme values cause division-by-zero or overflow in burn-height-to-reward-cycle at line 158? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: set-burnchain-parameters()] [Consensus Divergence] Can conflicting burnchain parameters be set across different nodes if the configured flag at line 33 has a race condition, leading to nodes calculating different reward cycles from the same burn height? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: burn-height-to-reward-cycle()] [Arithmetic Underflow] Can burn-height-to-reward-cycle at line 158 underflow when height is less than first-burnchain-block-height, causing incorrect reward cycle calculations or runtime abort that could be weaponized for DoS? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: reward-cycle-to-burn-height()] [Arithmetic Overflow] Can reward-cycle-to-burn-height at line 162 overflow when multiplying cycle by pox-reward-cycle-length, causing wrapping to incorrect burn heights that misalign reward distribution? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: burn-height-to-reward-cycle()] [Division Edge Case] If pox-reward-cycle-length at line 30 is set to zero during configuration, does the division at line 158 cause runtime abort or incorrect calculation? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: get-stacker-info()] [Lock Expiration] Can the expiration check at line 173 have an off-by-one error where (<= (+ first-reward-cycle lock-period) current-cycle) returns none one cycle too early, allowing premature re-stacking or double-spending locked STX? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: get-stacker-info()] [State Inconsistency] If a stacker's lock period has expired but stacking-state map entry remains, can this stale data be used to bypass checks in delegate-stack-stx at line 601 or stack-stx at line 456? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: check-caller-allowed()] [Authorization Bypass] In check-caller-allowed at line 183-193, if until-burn-ht is none and unwrap! at line 191 returns true, does this create a permanent authorization that cannot be revoked, allowing unauthorized stacking operations? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: check-caller-allowed()] [Logic Inversion] At line 191, the condition (< burn-block-height until-burn-ht) returns false when authorization should be active - is this inverted logic that makes expired authorizations valid and active ones invalid? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: allow-contract-caller()] [Permission Escalation] Can allow-contract-caller at line 417 be called by a malicious contract to authorize itself, bypassing the tx-sender == contract-caller check at line 419 through reentrancy or delegation? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: disallow-contract-caller()] [Authorization Revocation] Does disallow-contract-caller at line 407 properly revoke authorization, or can a malicious contract re-authorize itself immediately after revocation? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: allow-contract-caller()] [Timestamp Manipulation] Can until-burn-ht in allow-contract-caller at line 423 be set to a very high value (near uint max) to create effectively permanent authorization that bypasses intended expiration? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: get-check-delegation()] [Expiration Check] In get-check-delegation at line 198-199, if until-burn-ht is none, does the match return false when it should allow permanent delegation, or vice versa? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: delegate-stx()] [Delegation Override] Can delegate-stx at line 499 override an existing non-expired delegation by calling map-set at line 518 without checking if a valid delegation already exists to a different delegate? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: delegate-stx()] [Already Stacked Check] Does the check at line 510 properly prevent delegation while already stacking, or can get-stacker-info return none for expired locks allowing delegation of still-locked STX? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: delegate-stx()] [Amount Validation] Does delegate-stx validate that amount-ustx at line 499 is greater than zero and less than or equal to the delegator's balance, or can zero/excessive amounts be delegated? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: delegate-stx()] [PoX Address Validation] If pox-addr is provided at line 502, is it validated using check-pox-addr-version before being stored at line 523, or can invalid addresses be delegated? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: revoke-delegate-stx()] [Double Revocation] Can revoke-delegate-stx at line 485 be called multiple times on an already-revoked delegation, potentially causing state inconsistency or being used for griefing? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: stack-stx()] [Start Burn Height Validation] At line 448, can the start-burn-ht validation be bypassed by providing a burn height that is in the current cycle but maps to next cycle due to reward cycle boundary timing? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: stack-stx()] [First Reward Cycle] Is first-reward-cycle calculated correctly at line 444 as (+ u1 (current-pox-reward-cycle)), or can this cause stacking to start in the wrong cycle during prepare phase? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: stack-stx()] [Already Delegated Check] At line 460, if get-check-delegation returns none for an expired delegation, can a user stack-stx while delegation state map still contains their entry, causing state confusion? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: stack-stx()] [Balance Check Race] Between the balance check at line 464 and the actual lock, can an attacker transfer STX out to make stx-get-balance insufficient, causing the lock to fail or lock negative amounts? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: stack-stx()] [Double Stacking] If map-set at line 474 overwrites an expired stacking-state entry, can the old lock-period and first-reward-cycle be exploited to claim rewards twice? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox.clar] [Function: stack-stx()] [Unlock Height Calculation] Is unlock-burn-height at line 482 calculated correctly as reward-cycle-to-burn-height(first-reward-cycle + lock-period), or is there an off-by-one error that unlocks too early/late? (High)"
]