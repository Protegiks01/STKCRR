[
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Frequency Weight] Can frequency be weighted in downstream sortition logic, and if so, can miners exploit this by creating many short UTXO chains instead of one long chain? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [u8 Limit] Since frequency is u8, it maxes at 255, but can mining_commitment_window ever exceed this, and if so, what happens to the excess commits? (Low)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: BurnSamplePoint::zero()] [Zero Burn Impact] The zero() method at lines 96-105 creates a sample point with all zeros, but can this be inserted into burn distributions to dilute effective burns or manipulate sortition ranges? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Range Initialization] Range_start and range_end are initialized to Uint256::zero() at lines 321-322, but can these remain zero if make_sortition_ranges fails or is not called, causing sortition selection to fail? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: prometheus_update_miner_commitments()] [Side Channel] Can the prometheus metrics updates at lines 335-357 leak information about miner identities or burn amounts that could be exploited for front-running or targeted attacks? (Low)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: prometheus_update_miner_commitments()] [Range Calculation] The range_total calculation at line 350 computes (burn.range_end - burn.range_start), but can this overflow or underflow if ranges are incorrectly ordered? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [HashMap Determinism] Are the HashMap iterations at lines 204-212 deterministic across nodes, or can different hash seeds cause different iteration orders and consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Remove Side Effects] The remove() calls at lines 231 and 235 modify the HashMap during iteration over linked commits, but can this cause unexpected behavior if multiple commits reference the same txid? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Vec Allocation] The commits_with_priors Vec allocation at line 184 can be large if many miners participate, but can an attacker cause DoS by forcing allocation of excessive memory? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Linked Commits Init] The linked_commits vector at line 190 is initialized with None values, but can these remain None in critical positions causing incorrect burn calculations? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [First Commit] The first linked_commit is set at lines 191-194 with rel_block_height = window_size - 1, but is this always the correct position for the most recent commit? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Linking Logic] When a referenced_op is found at line 250, it's inserted at position (window_size - 1 - rel_block_height), but can this calculation place commits at incorrect positions? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Test: make_mean_min_median_sunset_in_window()] [Sunset Transition] The test shows malformed commits around sunset boundaries (lines 576-577), but does the production code handle these correctly, or can they cause consensus issues? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Test: missed_block_commits()] [Missed Commit Impact] The test shows missed commits reducing effective burns to 0 (lines 738-739), but can attackers abuse missed commits to reduce competitors' effective burns? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Window Size 1] When window_size is 1 (prepare phase or post-sunset), can the logic handle this edge case correctly, or does it cause issues with median calculation and UTXO chaining? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [u128 Conversion] The conversion from u64 burn_fee to u128 at line 269 is safe, but can the reverse conversion when assigning to BurnSamplePoint cause issues if median exceeds u64::MAX? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Uint256::max() Usage] The Uint256::max() constant is used at lines 372, 393, but can operations with this maximum value cause overflow in multiplication with Uint512? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Most Recent Burn] The most_recent_burn assignment at line 277 takes all_burns[0], but is all_burns guaranteed to have at least one element? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Range Start Assignment] Each sample's range_start is set to last_sample_range_end at line 389, but can rounding errors cause range_start to not equal the previous range_end, creating gaps? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Range Continuity] If two miners have identical burn amounts, can their ranges have zero width or overlap, causing unfair sortition distribution? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Last Sample] Does the iteration ensure that the last sample's range_end equals Uint256::max() exactly, or can accumulated rounding leave the final range slightly short? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Struct: BurnSamplePoint] [Burns Invariant] The burns field is supposed to equal min(median_burn, most_recent_burn), but can this invariant be violated through arithmetic overflow or incorrect updates? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Struct: BurnSamplePoint] [Range Ordering] Should range_start always be less than range_end, and if so, is this enforced, or can incorrect calculations violate this invariant? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Struct: BurnSamplePoint] [Candidate Consistency] Is the candidate field guaranteed to be the most recent commit in the UTXO chain, or can linking logic errors associate the wrong commit? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Median Manipulation] Can a cartel of miners coordinate to keep the median artificially low by strategically spacing their burns across the window, reducing effective costs for all cartel members? (High)"
]