[
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPrivateKey::new()] [Weak Randomness] Can an attacker predict VRF private keys if the thread_rng() source is compromised or seeded predictably, allowing them to precompute valid VRF proofs and manipulate leader election? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPrivateKey::from_hex()] [Input Validation] Does from_hex() properly validate hex string length before calling hex_bytes(), and could malformed input cause panic or incorrect key generation leading to consensus divergence? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPrivateKey::from_bytes()] [Key Validation] Does from_bytes() validate that the input is exactly 32 bytes and represents a valid Ed25519 scalar, or can out-of-range values create invalid private keys that produce non-deterministic proofs? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPrivateKey::from_bytes()] [Error Handling] When SigningKey::try_from() fails, does returning None leak information about which byte ranges are invalid, potentially enabling side-channel attacks on key material? (Medium)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPrivateKey::as_bytes()] [Memory Safety] Does as_bytes() return a reference to internal key material without zeroing on drop, potentially leaving private keys in memory after deallocation that could be recovered by attackers? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPrivateKey::to_bytes()] [Constant-Time] Is to_bytes() constant-time with respect to the private key value, or does it leak timing information that could enable key recovery through side-channel analysis? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 95-99] [Timing Attack] The PartialEq implementation for VRFPrivateKey is marked as non-constant-time and test-only, but could this comparison be accidentally used in production code paths where timing leaks reveal private key equality? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPublicKey::from_private()] [Key Derivation] Does from_private() correctly derive the public key using the verifying_key() method, and could any edge cases in the SigningKey produce invalid or low-order public keys? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPublicKey::from_bytes()] [Point Validation] Does from_bytes() properly check that pubkey_bytes decompresses to a valid Edwards point that is NOT a small-order point, preventing attackers from submitting crafted public keys that break VRF security? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 159-160] [Point Decompression] The code manually calls CompressedEdwardsY.decompress() before VerifyingKey::from_bytes() even though the docs say from_bytes performs the check - could a library version mismatch cause this redundant check to be bypassed, accepting invalid points? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPublicKey::from_bytes()] [Canonical Encoding] Does from_bytes() reject non-canonical point encodings where multiple byte representations map to the same point, which could enable proof malleability or consensus splits? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPublicKey::from_bytes()] [Length Validation] Does from_bytes() validate that pubkey_bytes is exactly 32 bytes before calling try_into(), and what happens if shorter or longer inputs are provided? (Medium)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFPublicKey::from_hex()] [Hex Decoding] Can from_hex() handle hex strings with odd lengths, leading/trailing whitespace, or uppercase/lowercase inconsistencies that might cause the same public key to have multiple representations? (Medium)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 61-64] [Equality Check] Does the PartialEq implementation for VRFPublicKey properly handle the case where two different point encodings represent the same curve point, or could this cause consensus divergence? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 75-78] [Ordering] Does the Ord implementation use deterministic byte-wise comparison that matches serialization order, ensuring that VRFPublicKey ordering in sorted collections is consensus-consistent across implementations? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 81-84] [Hashing] Does the Hash implementation hash the canonical byte representation, and could non-canonical encodings of the same point produce different hash values in HashMaps? (Medium)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 40-53] [Serde Deserialization] Does the serde Deserialize implementation for VRFPublicKey properly validate the hex string and reject invalid inputs, or could malformed JSON/TOML cause panics during config loading? (Medium)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 213-221] [Struct Fields] The VRFProof struct contains Gamma (EdwardsPoint), c (ed25519_Scalar), and s (ed25519_Scalar) - are all three fields validated for canonical encoding and valid curve arithmetic to prevent malleability? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFProof::check_c()] [Scalar Constraint] The check_c() function verifies that the upper 16 bytes of c are zero - what happens if this constraint is violated, and could attackers craft proofs with non-zero upper bytes that pass verification but cause consensus divergence? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 252-262] [Range Check] Does check_c() correctly validate that only bytes [16..32] must be zero, and could an off-by-one error allow c scalars with the 16th byte set to non-zero values? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFProof::new()] [Constructor Validation] Does VRFProof::new() reject proofs where check_c() fails, preventing construction of invalid proofs that could be serialized and cause consensus issues? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 264-267] [Empty Proof] The empty() function returns a proof with all bytes set to 1 - is this proof guaranteed to be invalid for all possible inputs, and could it ever accidentally verify, enabling a denial-of-service attack? (Medium)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Function: VRFProof::from_slice()] [Deserialization Length] Does from_slice() correctly reject inputs that are not exactly 80 bytes, preventing buffer overruns or underruns during proof parsing? (High)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 288-299] [Gamma Validation] Does from_slice() properly validate that Gamma decompresses to a valid Edwards point AND check that it's not a small-order point, preventing attackers from crafting proofs with torsion components that break verification? (Critical)",
  "[File: stacks-core/stacks-common/src/util/vrf.rs] [Lines: 296-298] [Small Order Check] The code checks gamma.is_small_order() and returns None if true - but is this check performed AFTER cofactor clearing, and could small-order Gamma values slip through if cofactor multiplication is applied later? (Critical)"
]