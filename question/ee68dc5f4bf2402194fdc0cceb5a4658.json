[
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: add_connecting()] [Race Condition] Can a malicious peer exploit a race condition by rapidly connecting and disconnecting to cause the same neighbor key to be added multiple times with different event IDs, leading to event ID leakage or connection tracking inconsistencies? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: remove_connecting()] [State Inconsistency] If remove_connecting() is called without a corresponding unpin_connection(), does this leak pinned event IDs that will never be cleaned up, causing resource exhaustion over time? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: remove_connecting_error()] [Resource Leak] Can an attacker trigger repeated connection failures to fill the connecting HashMap without proper cleanup, then exploit the unpinning logic to cause event ID tracking corruption? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: get_connecting()] [TOCTOU] Is there a time-of-check-time-of-use vulnerability where get_connecting() returns an event ID that becomes invalid before it's used in neighbor_connect_and_handshake(), allowing stale event IDs to be processed? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_connect_and_handshake()] [Race Condition] Between lines 156-160, if is_registered() returns false but the peer connects on a different thread before connect_peer() is called at line 184, can this cause duplicate connection attempts with different event IDs? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_connect_and_handshake()] [State Transition Error] At lines 162-170, if network.is_connecting(event_id) returns true but the connection completes immediately after, does the function return Ok(None) causing the caller to miss the successful connection? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_connect_and_handshake()] [Logic Error] At lines 206-216, when AlreadyConnected error is caught, the code calls remove_connecting() on alt_nk and then handshakes with alt_nk - but what if alt_nk is not in the connecting map? Does this cause silent failures? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_session_begin_only()] [Authentication Bypass] At lines 253-260, when a peer is already connected on an inbound connection, the code attempts to establish an outbound connection but then immediately tries to handshake at line 259 - can this bypass the neighbor_pubkh validation that was checked at line 246? (Critical)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_session_begin_only()] [Logic Error] At lines 248-271, if can_register_peer_with_pubkey() returns AlreadyConnected but get_p2p_convo() returns None at line 253, the error at line 274 is returned but the connecting state is never cleaned up - can this leak connections? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_handshake()] [Error Handling] At lines 117-123, when sign_for_neighbor() fails, the peer is marked as dead via add_dead() - but what if the signing failure is transient? Could legitimate peers be permanently marked dead due to temporary signing errors? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_handshake()] [DoS] At lines 125-143, if send_neighbor_message() fails and marks the peer as dead, can a malicious peer cause legitimate neighbors to be marked dead by disrupting message delivery through network manipulation? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: pin_connection()] [Resource Exhaustion] Can an attacker cause unbounded growth of the events HashSet by repeatedly triggering add_connecting() calls that pin event IDs but never complete connection, exhausting memory? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: clear_pinned_connections()] [Resource Management] At line 594, when events HashSet is replaced with an empty one, are there any outstanding references to the old event IDs that could cause use-after-free or dangling reference issues? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: add_connecting()] [Invariant Violation] At lines 531-533, event_id is inserted into connecting HashMap and then pinned - but if pin_connection() is called multiple times for the same event_id, does the HashSet ensure uniqueness or could this cause issues? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: unpin_connection()] [Logic Error] If unpin_connection() is called for an event_id that was never pinned, does this silently succeed and potentially mask bugs where connection cleanup is not properly paired? (Low)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: is_pinned()] [TOCTOU] If is_pinned() is checked and returns true, but another thread unpins the connection before it's used, can this cause logic errors in connection management? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: PeerNetworkComms::new()] [Initialization] Are the empty HashSets and HashMaps initialized with appropriate capacity hints? Could an attacker exploit the initial allocation strategy to cause excessive reallocation overhead during the first few connections? (Low)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: add_dead()] [State Pollution] Can an attacker spam the dead_connections HashSet by triggering connection failures for many different neighbor keys, causing memory exhaustion and making legitimate dead peer tracking ineffective? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: add_broken()] [State Pollution] Similarly, can broken_connections HashSet be flooded with entries by triggering protocol violations, and does this HashSet have any size limits to prevent DoS? (High)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: take_dead_neighbors()] [Concurrency] At line 653, the HashSet is replaced with mem::replace() - is this atomic? Can another thread add a dead neighbor between the take and the replacement, causing that neighbor to be lost? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: take_broken_neighbors()] [Concurrency] At line 657, same question as above - can concurrent calls to add_broken() and take_broken_neighbors() result in lost entries? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: add_dead()] [Duplicate Detection] At lines 560-564, inserting into a HashSet means duplicates are silently dropped - can an attacker exploit this by triggering the same DropNeighbor repeatedly to mask more serious violations? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: add_broken()] [Duplicate Detection] At lines 574-578, same question - can duplicate broken neighbor entries mask important information about the severity or frequency of protocol violations? (Medium)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: reset()] [State Cleanup] At lines 439-444, reset() calls take_dead_neighbors() and take_broken_neighbors() but ignores the return values - could this cause issues if the caller expects to process these neighbors before clearing them? (Low)",
  "[File: stacks-core/stackslib/src/net/neighbors/comms.rs] [Function: neighbor_send_only()] [Signature Security] At line 331, sign_for_neighbor() is called but there's no validation that the signature was created successfully or that the message payload hasn't been tampered with - can this be exploited? (High)"
]