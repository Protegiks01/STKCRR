[
  "[File: stackslib/src/core/mempool.rs] [Function: will_admit_tx()] [Consensus Divergence] Can an attacker craft a transaction that passes mempool admission checks but fails consensus validation during block assembly, causing miners to produce invalid blocks that diverge from honest nodes? (Critical)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Tenure Resolution Bypass] If resolve_tenure is set to false in testing but accidentally used in production, could transactions be indexed to incorrect tenure-start blocks in Nakamoto epoch, breaking mempool sync semantics and causing consensus divergence? (Critical)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [State Race Condition] Between checking for prior_tx conflicts and inserting the new transaction, could another thread insert a conflicting transaction, violating the unique nonce constraints and causing database errors or silent overwrites? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Replace-by-Fee Logic Error] When prior_tx.tx_fee equals the new tx_fee, the transaction is rejected even if it's a replace-across-fork scenario. Could this allow an attacker to permanently block valid transactions by submitting equal-fee transactions on competing forks? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Nonce Conflict Detection] The code checks origin_nonce OR sponsor_nonce conflicts separately but doesn't validate that a transaction cannot conflict on both dimensions. Could a transaction with matching origin AND sponsor nonces to different prior transactions bypass conflict detection? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: are_blocks_in_same_fork()] [Fork Detection Error] If get_ancestor_block_height returns None for both directions, the function returns false (different forks). Could a database corruption or missing block cause valid same-fork transactions to be treated as cross-fork, enabling improper replace-by-fee? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: tx_submit()] [Coinbase Height Mismatch] If NakamotoChainState::get_block_header fails to return a header but consensus_hash is not FIRST_BURNCHAIN_CONSENSUS_HASH, could transactions be accepted with coinbase_height=0, breaking bloom filter pruning and garbage collection logic? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: submit()] [Blacklist Race Condition] Between checking is_tx_blacklisted and calling tx_submit, could another thread remove the transaction from the blacklist, allowing temporarily blacklisted transactions to be re-submitted? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: submit()] [Fee Estimation Bypass] If the cost estimator returns EstimatorError::NoEstimateAvailable, fee_rate is set to None. Could an attacker flood the mempool with transactions lacking fee estimates to bypass fee-based sorting in the GlobalFeeRate strategy? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: miner_submit()] [Admission Check Bypass] The miner_submit function sets do_admission_checks=false. Could a compromised or malicious miner submit invalid transactions (poison microblocks) that violate consensus rules, causing nodes to accept invalid mempool state? (Critical)",
  "[File: stackslib/src/core/mempool.rs] [Function: order_nonces()] [Nonce Comparison Logic] The function returns Ordering::Greater if origin_actual > origin_expected, but doesn't check if sponsor_actual matches sponsor_expected when origin matches. Could transactions with valid origin but invalid sponsor nonces be incorrectly cached for retry? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Nonce Cache Poisoning] The NonceCache is populated from clarity_tx and nonce_conn. If these sources return inconsistent nonces due to concurrent block processing, could the cache contain stale values causing valid transactions to be skipped? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Ordering::Less Drop] When order_nonces returns Ordering::Less, the transaction is immediately dropped with continue. Could an attacker submit transactions with intentionally low nonces to permanently occupy mempool slots, as these are never retried? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Ordering::Greater Caching] In GlobalFeeRate strategy, transactions with nonces too high are pushed to candidate_cache. If the cache fills up, subsequent high-nonce transactions are silently dropped. Could this cause high-fee transactions to never execute? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Nonce Increment Race] After TransactionEvent::Success, nonces are incremented in the cache but not immediately flushed to the database. Could concurrent iterations read stale nonces from the DB, causing the same transaction to be considered multiple times? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Sponsored Transaction Nonce] The code increments sponsor nonce only if tx.auth.is_sponsored(). Could a malformed transaction claim to be sponsored in the mempool metadata but not in tx.auth, causing nonce desynchronization? (Critical)",
  "[File: stackslib/src/core/mempool.rs] [Function: flush_considered_txs()] [Foreign Key Constraint Violation] The function ignores constraint violations when inserting to considered_txs table. Could this mask legitimate database corruption or allow transactions deleted from mempool to remain in considered_txs indefinitely? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Struct: MemPoolTxMetadata] [Last Known Nonce Fields] The last_known_origin_nonce and last_known_sponsor_nonce fields are described as no longer used starting schema 6. Could legacy code paths still read these fields, causing inconsistent nonce validation? (Low)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [RBF Fee Comparison] The replace-by-fee check uses strict inequality (tx_fee > prior_tx.tx_fee). Could an attacker prevent transaction replacement by repeatedly submitting transactions with incrementally higher fees, forcing victims to pay exponentially increasing fees? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Cross-Fork Replace Logic] Replace-across-fork is allowed even when new tx_fee <= prior_tx.tx_fee. Could an attacker exploit chain reorgs to replace high-fee transactions with low-fee ones on competing forks, griefing legitimate users? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Replace Reason Initialization] replace_reason is initialized to REPLACE_BY_FEE before checking if replacement will occur. Could the wrong drop reason be broadcast in event_observer if the logic flow changes, misleading monitoring systems? (Low)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Sponsor vs Origin Conflict] When checking for prior_tx, the code first checks origin address+nonce, then sponsor. If both exist but with different txids, which prior_tx is used for comparison? Could this create ambiguous replacement scenarios? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: try_add_tx()] [Bloom Counter Update Timing] update_bloom_counter is called before the INSERT OR REPLACE SQL. If the SQL fails after bloom counter update, could the bloom filter become inconsistent with actual mempool contents? (High)",
  "[File: stackslib/src/core/mempool.rs] [Enum: MemPoolDropReason] [Event Observer Notification] When a transaction is replaced, event_observer.mempool_txs_dropped is called with the drop reason. Could incorrect drop reasons cause downstream systems to make wrong policy decisions (e.g., not resubmitting TOO_EXPENSIVE txs)? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: update_bloom_counter()] [First Transaction Check] The code checks if any transaction exists at coinbase_height to determine if bloom filter window advanced. Could rapid transaction arrival cause multiple threads to all prune the same height, creating redundant work or race conditions? (Low)"
]