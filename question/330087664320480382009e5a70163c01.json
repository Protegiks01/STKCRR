[
  "[File: stackslib/src/burnchains/db.rs] [Function: get_schema_version()] [Consensus Divergence] If the db_config table exists but contains non-integer version values, can the CAST(version AS INTEGER) at line 506 cause different nodes to return different schema versions, leading to consensus divergence when applying migrations? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: create_or_migrate()] [Consensus Divergence] Can the migration logic at lines 593-626 cause consensus divergence if two nodes race to apply migrations concurrently, where one node's transaction commits between another node's version check and migration application? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: create_or_migrate()] [Off-by-One Error] At line 598, if current_db_version equals migration.version - 1 but the migration fails partway through, can a subsequent restart attempt to re-apply the same migration, potentially causing duplicate entries or corrupted state? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Function: create_or_migrate()] [State Corruption] The migration check at lines 598-606 requires exact version ordering (X+1 after X). If a migration script at line 612 partially succeeds but the version update fails, can the database be left in an inconsistent state that prevents future migrations? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: create_or_migrate()] [Consensus Divergence] After applying a migration at line 612, the version verification at lines 616-623 checks if the new version matches migration.version. Can a malicious migration script insert a different version number, causing nodes to diverge on which migrations have been applied? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: create_or_migrate()] [Consensus Divergence] The comparison at lines 628-644 checks if current_db_version matches SCHEMA_VERSION. If SCHEMA_VERSION is updated in a new release but old nodes haven't upgraded, can this cause nodes to reject the same database state differently? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Constant: BURNCHAIN_DB_MIGRATION_V2_TO_V3] [Data Loss] The migration at lines 310-330 drops the affirmation_maps table after copying data. If the INSERT INTO at line 322 fails for some rows due to constraint violations, can affirmation map data be permanently lost? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Constant: BURNCHAIN_DB_SCHEMA_2] [Foreign Key Violation] The schema at line 237 defines a foreign key on block_hash to burnchain_db_block_headers, but no ON DELETE cascade is specified. Can orphaned ops remain in burnchain_db_block_ops if a header is deleted, causing query inconsistencies? (Medium)",
  "[File: stackslib/src/burnchains/db.rs] [Constant: BURNCHAIN_DB_SCHEMA_2] [Consensus Divergence] The empty affirmation map inserted at line 294 uses affirmation_id=0 with empty string. If different nodes have different interpretations of empty affirmation maps, can this cause consensus divergence in reward cycle validation? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: connect()] [Race Condition] The database creation logic at lines 524-544 checks for file existence and creates the directory if needed. Can two nodes racing to create the same database at the same path cause one to fail or create duplicate schema entries? (Medium)",
  "[File: stackslib/src/burnchains/db.rs] [Function: apply_blockstack_txs_safety_checks()] [Consensus Divergence] The sort at line 152 uses partial_cmp().unwrap() on vtxindex values. If two operations somehow have the same vtxindex, can the sort order be non-deterministic across nodes, causing different transaction orderings? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: apply_blockstack_txs_safety_checks()] [DoS] The panic at lines 159-163 triggers on duplicate vtxindex. Can an attacker craft a burnchain block with duplicate vtxindexes to crash all nodes that process it, causing network-wide DoS? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: apply_blockstack_txs_safety_checks()] [DoS] The panic at lines 171-175 triggers on block height mismatch. Can a corrupted database state cause valid blocks to be rejected with panics, preventing nodes from syncing? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Function: apply_blockstack_txs_safety_checks()] [Validation Bypass] If blockstack_txs is empty at line 143, the function returns without validation. Can this allow insertion of invalid block data when no operations are present? (Medium)",
  "[File: stackslib/src/burnchains/db.rs] [Function: apply_blockstack_txs_safety_checks()] [Integer Overflow] The vtxindex comparison at line 152 uses partial_cmp(). If vtxindex values approach u32::MAX, can overflow in subsequent operations cause incorrect ordering or wraparound? (Medium)",
  "[File: stackslib/src/burnchains/db.rs] [Function: set_anchor_block()] [PoX Reward Corruption] The INSERT OR REPLACE at line 376 for anchor_blocks allows overwriting an existing reward cycle's anchor block. Can a malicious block commit replace a previously set anchor block, stealing rewards from the legitimate anchor block? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: set_anchor_block()] [Consensus Divergence] The UPDATE at line 382 sets anchor_block based on burn_block_hash and txid. If multiple nodes receive the same block commits in different orders, can they set different anchor blocks for the same reward cycle? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: set_anchor_block()] [Race Condition] Between the INSERT OR REPLACE at line 376 and the UPDATE at line 382, can another transaction modify block_commit_metadata, causing the UPDATE to target the wrong block commit? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Function: set_anchor_block()] [Data Corruption] If the UPDATE at line 388 affects zero rows (block commit doesn't exist), the function still returns Ok(()). Can this silently fail to set an anchor block, causing reward cycle inconsistencies? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Function: clear_anchor_block()] [PoX Reward Corruption] The UPDATE at line 406 sets anchor_block to NULL for all commits in a reward cycle. Can this be called incorrectly to clear a legitimate anchor block, causing reward distribution failures? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: clear_anchor_block()] [Orphaned Data] After clearing anchor_block at line 406, the corresponding entry in the anchor_blocks table (line 376) is not deleted. Can this leave orphaned reward cycle entries that violate foreign key expectations? (Medium)",
  "[File: stackslib/src/burnchains/db.rs] [Function: is_anchor_block()] [Consensus Divergence] The query at line 864 checks if anchor_block IS NOT NULL. Can a block commit with anchor_block=0 (valid reward cycle 0) be incorrectly treated as not being an anchor block? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Function: has_anchor_block()] [Off-by-One Error] The query at line 870 checks for exact reward_cycle match. Can off-by-one errors in reward cycle calculations cause this to return false for legitimate anchor blocks? (High)",
  "[File: stackslib/src/burnchains/db.rs] [Function: get_anchor_block_commit_metadatas()] [Consensus Divergence] The query at line 879 returns all anchor blocks for a reward cycle without ordering. If multiple anchor blocks exist (due to forks), can different nodes process them in different orders? (Critical)",
  "[File: stackslib/src/burnchains/db.rs] [Function: get_canonical_anchor_block_commit_metadata()] [Fork Selection Error] The canonical selection at lines 895-901 checks if header.block_hash matches metadata.burn_block_hash. If the indexer returns headers from a different fork, can this select a non-canonical anchor block? (Critical)"
]