[
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Memory Allocation] At line 305, vec![version] creates a new vector. For high-throughput scenarios, can repeated allocation/deallocation in address generation cause DoS through memory pressure? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Data Concatenation] The checksum is computed over [version || data] at line 307, but encoded data is [data || checksum] at line 310. Can an attacker exploit this ordering difference to create checksum collisions by manipulating the boundary between data and checksum? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Unwrap Panic] At line 317, String::from_utf8(c32_string).unwrap() assumes UTF-8 validity. If c32_encode returns bytes > 127 due to a bug, this will panic. Should this be a try-conversion with proper error handling? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Empty Data] What happens when data is empty but version is valid? Does the function generate a valid address with only a version and checksum, and could this be exploited to create minimal-size addresses for DoS? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Input Validation] The ASCII check at line 322 is duplicated from c32_decode(). Can an attacker bypass the check by providing input that becomes non-ASCII after the split_at operation at line 330? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Length Validation] At line 326, input must be at least 2 characters. However, at line 333, data_sum_bytes must be at least 5 bytes. Can an attacker provide 2-4 character inputs that pass the first check but fail later, causing different error paths on different nodes? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Split Point Attack] At line 330, split_at(1) separates version from data. Can an attacker craft multi-byte UTF-8 sequences (despite ASCII check) that cause split_at to split within a character, leading to decoding errors? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Checksum Length Assumption] At line 337, the code assumes the last 4 bytes are the checksum. If data_sum_bytes.len() == 5, then data_bytes is 1 byte. Can extremely short addresses be created that pass validation but violate protocol assumptions about minimum address size? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Version Decoding] At line 339, the version is decoded from the C32 string. Can the version character decode to a value >= 32, contradicting the c32_check_encode() check, and if so, what happens to the checksum validation? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Checksum Comparison Timing] At line 343, the checksum comparison uses !=. Is this comparison constant-time? Can timing side-channels allow an attacker to brute-force checksums by measuring validation time for partially correct checksums? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Endianness Handling] At lines 344-352, checksums are reconstructed into u32 with explicit bit shifts. Are these operations endian-independent? Can different architectures produce different checksum validations, causing consensus splits? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Error Information Leakage] The BadChecksum error at line 354 returns both computed and expected checksums. Does this provide attackers with information to craft collision attacks more efficiently? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Version Extraction] At line 357, version is extracted as check_data[0]. If check_data is empty due to a decoding bug in c32_decode_ascii, can this cause a panic or return an incorrect version? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Prefix Validation] At line 366, the function strips the first character (assumed to be 'S') without validating it. Can addresses with prefixes other than 'S' be decoded, causing consensus issues if some nodes enforce prefix checking and others don't? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Length Check] The check at line 363 requires c32_address_str.len() <= 5 to fail. However, the minimum valid address would be \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Slice Bounds] At line 366, &c32_address_str[1..] creates a slice starting at index 1. If the string contains multi-byte UTF-8 characters (despite the ASCII check), can this cause a panic or create malformed input to c32_check_decode? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Case Sensitivity] The function doesn't normalize the 'S' prefix. Can lowercase 's' addresses be decoded, and if so, does this create non-canonical address representations that cause consensus divergence? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address()] [Format String Injection] At line 372, the format!() macro concatenates \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address()] [Empty Input] If data is empty and version is 0, what address is generated? Does \\",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address()] [Version Propagation] The version parameter is passed to c32_check_encode() but there's no validation here. Can invalid versions pass through and only fail in c32_check_encode(), creating inconsistent error handling across the codebase? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Constant: C32_CHARACTERS] [Alphabet Integrity] The C32_CHARACTERS alphabet at line 21 excludes O, I, L to prevent ambiguity. However, the mapping table at lines 49-178 maps these characters anyway. Can an attacker exploit this design choice to create visually similar addresses that decode to different values? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Constant: C32_CHARACTERS_MAP] [Mapping Correctness] The C32_CHARACTERS_MAP includes mappings for O→0, L→1, I→1 at lines 123, 126, 129 (uppercase) and 155, 158, 161 (lowercase). Can these normalization rules be exploited to create phishing addresses that appear similar to legitimate addresses? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Constant: C32_CHARACTERS_MAP] [Out of Bounds Prevention] The map is sized for 128 ASCII characters. Can an attacker provide high-ASCII (128-255) characters that index beyond the map, or are these safely handled by the .get() calls in decoding? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Constant: C32_CHARACTERS_MAP] [Case Folding] The map treats uppercase and lowercase as equivalent. Are there any Unicode normalization attacks where characters appear as ASCII uppercase/lowercase but are actually different codepoints? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_encode() / c32_decode()] [Round-Trip Determinism] Can c32_decode(c32_encode(data)) ever return data' != data due to leading zero handling edge cases, and if so, does this violate consensus requirements for address uniqueness? (Critical)"
]