[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: set-burnchain-parameters()] [Access Control] Can an attacker call set-burnchain-parameters() multiple times by exploiting a race condition before the 'configured' flag is set to true, potentially allowing conflicting burnchain parameters to be established across different nodes? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: set-burnchain-parameters()] [Input Validation] Can an attacker pass zero or extremely small values for prepare-cycle-length or reward-cycle-length, causing division by zero or arithmetic errors in burn-height-to-reward-cycle calculations throughout the contract? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: set-burnchain-parameters()] [Integer Overflow] Can passing u115792089237316195423570985008687907853269984665640564039457584007913129639935 (max uint) for first-burn-height cause overflow when added to cycle lengths in reward-cycle-to-burn-height, leading to incorrect cycle boundaries? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: set-burnchain-parameters()] [Consensus Divergence] If different nodes call set-burnchain-parameters() with different rejection-fraction values before 'configured' is set, could this create permanent consensus divergence in is-pox-active calculations across the network? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: set-burnchain-parameters()] [State Corruption] Can an attacker manipulate begin-2-1-reward-cycle to be less than the actual current reward cycle, causing historical reward cycles to be treated as future cycles and breaking reward distribution logic? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: burn-height-to-reward-cycle()] [Runtime Abort] When height is less than first-burnchain-block-height, the function intentionally runtime-aborts - can this be exploited to DoS the contract by passing heights from past forks or reorganizations? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: reward-cycle-to-burn-height()] [Integer Overflow] Can passing a very large cycle value cause (* cycle (var-get pox-reward-cycle-length)) to overflow, wrapping around and returning an incorrect burn height that breaks unlock timing? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: current-pox-reward-cycle()] [Burn Block Manipulation] If burn-block-height can be manipulated or read inconsistently during contract execution, could this cause different parts of the contract to use different 'current' cycles within a single transaction? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Data Vars] [Immutability] After configured is set to true, the pox-rejection-fraction can still be read but not modified - can this create issues if the threshold needs to change for emergency protocol updates? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Constants] [Address Version] The MAX_ADDRESS_VERSION_BUFF_32 is set to u6 - if Bitcoin adds new address types beyond p2tr (version 0x06), will this require a hard fork to support them, potentially locking funds during the transition? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: stacking-state] [Invariant Violation] Can an attacker create a stacking-state entry where (len reward-set-indexes) != lock-period, violating invariant (5) and causing reward distribution to skip or double-count cycles? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: stacking-state] [State Corruption] Can reward-set-indexes contain duplicate index values for the same reward cycle, causing fold-unlock-reward-cycle to delete the wrong entry when moving the last entry? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: stacking-state] [Invariant Violation] If stacking-state.pox-addr differs from reward-cycle-pox-address-list.pox-addr (violating invariant 4), can this allow an attacker to receive rewards at a different address than registered? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: reward-cycle-pox-address-list] [Orphaned Entry] Can an entry exist in reward-cycle-pox-address-list with 'some stacker' that points to a non-existent or expired stacking-state entry, violating invariant (1) and breaking unlock logic? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: reward-cycle-pox-address-list] [Index Corruption] Can the 'index' field in reward-cycle-pox-address-list become non-sequential (e.g., 0, 1, 3, 5) after multiple fold-unlock operations, causing get-reward-set-pox-address to miss entries? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: reward-cycle-total-stacked] [Arithmetic Underflow] If fold-unlock-reward-cycle subtracts cycle-entry-total-ustx from total-ustx but the values are inconsistent, can total-ustx underflow and wrap to a huge value, breaking threshold checks? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: reward-cycle-total-stacked] [Overflow] Can repeatedly calling add-pox-addr-to-ith-reward-cycle cause total-ustx to overflow u128 max, wrapping around and making is-pox-active incorrectly return true when PoX should be disabled? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: partial-stacked-by-cycle] [Double Spend] If partial-stacked-by-cycle is not deleted after delegate-stack-stx but before stack-aggregation-commit, can the same STX be committed twice to different reward addresses? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: partial-stacked-by-cycle] [State Leak] Can logged-partial-stacked-by-cycle grow unboundedly as delegators repeatedly commit and re-stack, eventually causing storage exhaustion or expensive iteration? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: delegation-state] [Expiry Check] In get-check-delegation, if until-burn-ht is exactly equal to burn-block-height, does the comparison (> burn-block-height until-burn-ht) incorrectly allow an expired delegation to be used? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: allowance-contract-callers] [Time Manipulation] In check-caller-allowed, if burn-block-height can be manipulated to be less than expires-at, can an expired contract caller allowance be reactivated to perform unauthorized stacking? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: stacking-rejection] [Overflow] Can repeatedly calling reject-pox with maximum STX balances cause the 'amount' field to overflow, wrapping to a small value and making PoX incorrectly appear active? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: stacking-rejectors] [Double Voting] Can a user call reject-pox, transfer their STX to another address, and call reject-pox again, effectively voting twice in the same reward cycle? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: get-stacker-info()] [Race Condition] If get-stacker-info checks (+ first-reward-cycle lock-period) against current-pox-reward-cycle at the boundary between cycles, can this race condition cause valid stackers to be incorrectly reported as expired? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: get-reward-set-size()] [Default Value] If reward-cycle-pox-address-list-len returns none, default-to returns u0 - can this mask corruption where entries exist but the length map was deleted? (Medium)"
]