[
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_preamble()] [Preamble Size Tracking] Increments num_preamble_bytes by buf.len() if body not found. Can an attacker send preambles just under HTTP_PREAMBLE_MAX_ENCODED_SIZE in multiple calls to accumulate huge preambles and bypass size limits? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_preamble()] [Underflow Looping] Returns UnderflowError if body_start is None. If called repeatedly with small buffers, does num_preamble_bytes grow unbounded, and can this cause memory exhaustion before hitting HTTP_PREAMBLE_MAX_ENCODED_SIZE check? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_preamble()] [BoundReader Enforcement] Uses BoundReader with HTTP_PREAMBLE_MAX_ENCODED_SIZE. If cursor.position() at body_start is beyond this limit, does read_next() fail cleanly, or can excess data be read into memory before bounds are checked? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_preamble()] [Preamble Type Confusion] StacksHttpPreamble::consensus_deserialize() can return Request or Response. If an attacker sends a Request when Response is expected (or vice versa), does set_preamble() catch this mismatch? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::stream_payload()] [State Validation] Checks payload_len(preamble).is_some() and returns InvalidState. Can an attacker manipulate preamble fields to flip this check mid-stream and cause InvalidState errors that reset connection? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::stream_payload()] [Request Streaming] Returns InvalidState if preamble is a Request (HTTP requests can't be chunk-encoded). Can an attacker send a Request with Transfer-Encoding: chunked to trigger this check and probe for implementation details? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::stream_payload()] [Handler Index Validation] Checks request_handler_index.is_none() && !allow_arbitrary_response. If an attacker can cause handler index to be cleared (via reset()) mid-response, can this trigger Unsolicited HTTP response errors? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::stream_payload()] [Arbitrary Response Parsing] For allow_arbitrary_response=true and no handler_index, uses RPCArbitraryResponseHandler. Can this bypass response validation that specific handlers perform, accepting malformed data? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::stream_payload()] [Error Context Loss] On consume_data() failure, inspect_err() calls reset() but the error is propagated. Does the caller know that state was reset, or can retry logic fail due to lost context? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_payload()] [Buffer Bounds] For Request preamble, uses buf.get(0..len). If buf.len() < len, returns InvalidState. Should this be UnderflowError instead, since it indicates insufficient data rather than invalid state machine state? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_payload()] [Error Conversion] For Request parsing, converts NetError::Http into StacksHttpMessage::Error. If the original error was a network timeout, does wrapping it as HTTP error lose critical timeout context for retry logic? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_payload()] [Method Not Allowed Headers] For 405 errors, constructs extra_headers with Allow. If methods.join(\\",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_payload()] [Response Length Mismatch] For Response preamble with known length, uses buf.len() as bytes consumed. If preamble.content_length doesn't match buf.len(), can this cause subsequent reads to start at wrong offsets? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::read_payload()] [Status Code Handling] For responses with status_code >= 400, returns StacksHttpMessage::Error. Can 3xx redirects (e.g., 301, 302) be incorrectly treated as errors when they should trigger redirect logic? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_handle_request()] [Handler Index Lookup] Uses request.response_handler_index or find_response_handler(). If response_handler_index is stale (points to a removed handler), can this cause out-of-bounds access in request_handlers[index]? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_handle_request()] [Handler Mutation] Calls request_handler.try_handle_request() which takes &mut self. Can concurrent requests to the same handler cause race conditions if handlers maintain mutable state? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_handle_request()] [Restart Timing] Calls request_handler.restart() after try_handle_request(). If restart() fails or panics, does the handler remain in a dirty state for the next request? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_handle_request()] [Error Response Construction] On NetError::Http, constructs error response with e.into_http_error(). If into_http_error() returns a generic error that loses detail, can attackers trigger errors without leaving useful logs? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_handle_request()] [Irrecoverable Error Propagation] For non-HTTP NetErrors, logs warn! and returns Err(e). Does the caller close the connection, or can the state machine continue processing requests after irrecoverable errors? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_handle_request()] [405 Method Not Allowed] If find_allowed_methods() returns non-empty, constructs 405 response with Allow header. Can this leak information about internal endpoints not meant to be publicly exposed? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_parse_response()] [Handler Index Bounds] Indexes request_handlers.get(request_handler_index) and expects it to exist. If request_handler_index is out of bounds, the expect() panics. Can attackers trigger this via race conditions? (High)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_parse_response()] [Error Response Bypass] Checks preamble.status_code >= 400 and calls try_parse_error_response(). Can responses with status_code in 200-399 range but malformed body bypass validation in parser.try_parse_response()? (Medium)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_parse_error_response()] [Status Code Range] Checks if status_code < 400 || > 599 and returns DeserializeError. Can codes exactly 400 or 599 trigger edge case bugs in error payload parsing? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_parse_error_response()] [Content Type Assumption] Only handles Text and JSON content types. If an error response has content_type=Bytes, it returns DeserializeError. Can attackers send Bytes errors to cause parsing failures and hide error details? (Low)",
  "[File: stackslib/src/net/httpcore.rs] [Function: StacksHttp::try_parse_error_response()] [BoundReader Limit] Uses BoundReader with MAX_MESSAGE_LEN. If error body exceeds this, does from_reader() fail gracefully with ReadError, or can it cause truncation that loses error message detail? (Low)"
]