[
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [DoS - Large Push Data] OP_PUSHDATA4 allows pushing up to 2^32-1 bytes - could an attacker craft a Bitcoin script with OP_PUSHDATA4 claiming to push 4GB of data to cause memory exhaustion or DoS when the script parser attempts to allocate buffers for the claimed push data length? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_PUSHNUM_NEG1] OP_PUSHNUM_NEG1 (0x4F) pushes [0x81] to represent -1 (line 199) - is this correctly classified as Class::PushNum(-1) in the classify() method (line 599), and do script execution engines correctly interpret 0x81 as the two's complement representation of -1? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Function: classify()] [Logic Error - OP_RESERVED Handling] OP_RESERVED (0x50) is documented as 'Synonym for OP_RETURN' (line 201) and is classified as ReturnOp (line 589), but it falls between OP_PUSHNUM_NEG1 and OP_PUSHNUM_1 - could script validation logic accidentally treat OP_RESERVED as a valid push operation instead of an immediate script failure? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_PUSHNUM Range] OP_PUSHNUM_1 through OP_PUSHNUM_16 (0x51-0x60) push values 1-16 - the classify() arithmetic '1 + *self as i32 - All::OP_PUSHNUM_1 as i32' (line 603) must produce correct values - could an off-by-one error cause OP_PUSHNUM_16 to push 17 instead of 16, breaking script execution expectations? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Static: OP_TRUE] [Consensus - Alias Correctness] OP_TRUE is defined as an alias for OP_PUSHNUM_1 (line 650) - is this alias used consistently throughout the codebase, or could confusion between OP_TRUE and OP_PUSHNUM_1 lead to validation inconsistencies where scripts are evaluated differently depending on which variant is used? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Function: classify()] [Consensus - IllegalOp Completeness] The classify() method checks 17 specific opcodes as IllegalOp (OP_VERIF, OP_VERNOTIF, OP_CAT, OP_SUBSTR, OP_LEFT, OP_RIGHT, OP_INVERT, OP_AND, OP_OR, OP_XOR, OP_2MUL, OP_2DIV, OP_MUL, OP_DIV, OP_MOD, OP_LSHIFT, OP_RSHIFT) - are all Bitcoin disabled opcodes correctly enumerated, or could a missed disabled opcode be executed by miners, causing consensus divergence? (Critical)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_VERIF/OP_VERNOTIF] OP_VERIF (0x65) and OP_VERNOTIF (0x66) are marked to 'Fail the script unconditionally, does not even need to be executed' (lines 243-245) - does the script validator correctly fail scripts containing these opcodes before execution, or could they be executed in non-executed IF branches, potentially violating consensus rules? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - String Operations] OP_CAT (0x7E), OP_SUBSTR (0x7F), OP_LEFT (0x80), OP_RIGHT (0x81) are disabled string manipulation opcodes (lines 296-302) that must cause immediate script failure - could these ever be executed due to misclassification or version-dependent behavior, potentially reintroducing removed functionality? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - Bitwise Operations] OP_INVERT (0x83), OP_AND (0x84), OP_OR (0x85), OP_XOR (0x86) are disabled bitwise operations (lines 306-312) - were these correctly disabled in Bitcoin consensus, and could their classification as IllegalOp be bypassed by script version flags or witness program types? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - Arithmetic Operations] OP_2MUL (0x8D), OP_2DIV (0x8E), OP_MUL (0x95), OP_DIV (0x96), OP_MOD (0x97), OP_LSHIFT (0x98), OP_RSHIFT (0x99) are disabled arithmetic/shift operations (lines 326-350) - could an attacker exploit any timing or implementation differences in how different nodes detect and reject these disabled opcodes? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Function: classify()] [Consensus - ReturnOp Handling] The classify() method marks OP_RESERVED (0x50), OP_VER (0x62), OP_RETURN (0x6A), OP_RESERVED1 (0x89), OP_RESERVED2 (0x8A), and all opcodes >= 0xBA as ReturnOp - must script execution immediately terminate with failure when any ReturnOp is executed, or could there be conditional execution contexts where ReturnOp doesn't fail the script? (Critical)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_RETURN Usage] OP_RETURN (0x6A) is used for provably unspendable outputs and data storage (line 254) - does the classification as ReturnOp correctly prevent OP_RETURN scripts from ever being validated as spendable, or could an attacker construct a multi-output transaction where OP_RETURN outputs are incorrectly validated? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - Reserved Opcodes] OP_RESERVED (0x50), OP_RESERVED1 (0x89), OP_RESERVED2 (0x8A) are marked as synonyms for OP_RETURN (lines 201, 318, 320) - is this classification consistent with Bitcoin consensus rules where reserved opcodes must cause immediate failure, and could nodes disagree on whether these are equivalent to OP_RETURN? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_VER Handling] OP_VER (0x62) is marked as a synonym for OP_RETURN (line 237) - was OP_VER intended for version checking and later disabled, and could its classification cause unexpected behavior if old scripts containing OP_VER are encountered? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_RETURN_186-255] The enum defines OP_RETURN_186 through OP_RETURN_255 (lines 418-556) as explicit variants all marked as 'Synonym for OP_RETURN' - why are these undefined opcode values given explicit enum variants instead of being handled generically, and could this create maintenance issues if new opcodes are assigned in this range? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_IF/OP_NOTIF] OP_IF (0x63) and OP_NOTIF (0x64) implement conditional execution (lines 239-241) - are these classified correctly as Ordinary opcodes that require script state tracking for IF/ELSE/ENDIF nesting, and could mishandling of nested conditionals lead to script evaluation errors? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_ELSE] OP_ELSE (0x67) is documented to 'Execute statements if those after the previous OP_IF were not, and vice-versa. If there is no previous OP_IF, this acts as a RETURN' (lines 247-248) - does the script validator correctly track IF nesting depth and fail scripts where OP_ELSE appears without matching OP_IF? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_ENDIF] OP_ENDIF (0x68) must match with OP_IF/OP_NOTIF (line 250) - could an attacker craft scripts with mismatched IF/ENDIF pairs to cause script parsing to enter an inconsistent state, potentially leading to different validation outcomes on different nodes? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_VERIFY] OP_VERIFY (0x69) is documented to 'If the top value is zero or the stack is empty, fail; otherwise, pop the stack' (line 252) - does this opcode correctly handle the empty stack case, and could off-by-one errors in stack depth checking cause incorrect script validation? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_TOALTSTACK/OP_FROMALTSTACK] OP_TOALTSTACK (0x6B) and OP_FROMALTSTACK (0x6C) move elements between main and alt stacks (lines 256-258) - could scripts manipulate the alt stack to bypass stack depth limits, hide malicious data, or cause stack underflow errors in script validation? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_2DROP/OP_2DUP/OP_3DUP] Stack manipulation opcodes OP_2DROP (0x6D), OP_2DUP (0x6E), OP_3DUP (0x6F) operate on multiple stack elements (lines 260-264) - could incorrect implementation of these multi-element operations cause stack corruption, off-by-one errors in element counting, or expose elements that should remain hidden? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_2OVER/OP_2ROT/OP_2SWAP] Complex stack operations OP_2OVER (0x70), OP_2ROT (0x71), OP_2SWAP (0x72) manipulate pairs of elements (lines 266-272) - are the documented behaviors ('xxAB -> ABxxAB', 'xxxxAB -> ABxxxx', 'ABCD -> CDAB') correctly implemented in script executors, and could implementation bugs cause elements to be lost or duplicated? (Medium)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_PICK/OP_ROLL] OP_PICK (0x79) and OP_ROLL (0x7A) use the top stack element as an index to copy or move Nth elements (lines 286-288) - could an attacker provide negative indices or out-of-bounds indices to cause stack underflow, read uninitialized memory, or corrupt the stack state? (High)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_DEPTH] OP_DEPTH (0x74) pushes the current stack size onto the stack (line 276) - could this opcode be used to leak information about script execution state, or could incorrect depth counting lead to validation inconsistencies across nodes with different stack implementations? (Low)",
  "[File: stacks-core/stacks-common/src/deps_common/bitcoin/blockdata/opcodes.rs] [Enum: All] [Consensus - OP_IFDUP] OP_IFDUP (0x73) duplicates the top stack element unless it is zero (line 274) - must this opcode correctly distinguish between zero (empty byte array) and OP_FALSE (0x00 byte), and could confusion between these representations cause validation errors? (Medium)"
]