[
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: check-pox-addr-version()] [Version Overflow] Can passing a version buffer with leading zero bytes (e.g., 0x0007) bypass the MAX_ADDRESS_VERSION check via buff-to-uint-be, allowing invalid Bitcoin address types? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: check-pox-addr-hashbytes()] [Length Validation] If version is 0x04 (MAX_ADDRESS_VERSION_BUFF_20) but hashbytes is 32 bytes, does the check-pox-addr-hashbytes incorrectly fail when it should succeed for native segwit? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: check-pox-addr-hashbytes()] [Edge Case] For version 0x05 or 0x06, if hashbytes has exactly 20 bytes instead of 32, can this pass validation but create an invalid Bitcoin address that burns rewards? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: check-pox-addr-hashbytes()] [Length Check] The function checks (len hashbytes) but hashbytes is always (buff 32) - can padding with zeros bypass the length check, creating addresses with actual length < 20 or != 32? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Type: pox-addr] [Buffer Truncation] If hashbytes is defined as (buff 32) but only 20 bytes are significant, can the trailing 12 bytes contain arbitrary data that creates address collisions when truncated? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: minimal-can-stack-stx()] [Address Validation Order] Does minimal-can-stack-stx validate pox-addr before checking that the stacker hasn't rejected PoX, potentially wasting gas on invalid addresses? (Low)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: delegate-stx()] [Partial Validation] delegate-stx only validates pox-addr version but not hashbytes length - can this allow delegation with malformed addresses that fail later during delegate-stack-stx? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Constants] [Version Gap] Address versions 0x00-0x06 are defined, but what if Bitcoin implements 0x07-0xFF in the future - will all STX locked to forward-compatible addresses be permanently burned? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: check-pox-addr-version()] [Type Confusion] Can passing a version buff with non-standard encoding cause buff-to-uint-be to return an unexpected value that bypasses MAX_ADDRESS_VERSION? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: check-pox-addr-hashbytes()] [Boolean Logic] The nested if-then-else structure returns false for versions > MAX_ADDRESS_VERSION_BUFF_32 - can version 0xFF with any hashbytes length pass validation? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Map: reward-cycle-pox-address-list] [Address Deduplication] The contract doesn't deduplicate pox-addr entries - can an attacker register the same Bitcoin address multiple times in one cycle to increase their reward share beyond their actual stake? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: append-reward-cycle-pox-addr()] [Address Collision] If two different stackers use identical pox-addr tuples, does the contract correctly attribute rewards, or can one stacker claim another's rewards? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Off-by-One] The first-reward-cycle is calculated as (+ u1 (current-pox-reward-cycle)) - if called at the exact cycle boundary, can this cause stacking to start in cycle N+2 instead of N+1? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Start Height Validation] If start-burn-ht is the last block of the current cycle, does the check (is-eq first-reward-cycle specified-reward-cycle) incorrectly reject valid stacking attempts? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Balance Check Race] The balance check (>= (stx-get-balance tx-sender) amount-ustx) occurs before locking - can the sender transfer funds between the check and lock, causing insufficient funds but still creating stacking state? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Delegation Check] The check (is-none (get-check-delegation tx-sender)) uses get-check-delegation which validates expiry - can an attacker stack-stx with an expired delegation still in the map? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Already Stacked Check] get-stacker-info returns none if lock has expired - can this allow re-stacking in the same cycle if the previous lock just expired this block? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Minimum Threshold] can-stack-stx checks the stacking minimum at call time, but if liquid supply increases during the lock period, can the stacker fall below minimum and become invalid for future cycles? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Unlock Height Calculation] The unlock-burn-height is calculated as (reward-cycle-to-burn-height (+ first-reward-cycle lock-period)) - is this off-by-one, causing unlock at the start of the cycle instead of the end? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Reward Set Index] add-pox-addr-to-reward-cycles asserts that num-cycles equals (get i results) - can fold iteration issues cause this assertion to fail even with valid inputs? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [State Atomicity] If add-pox-addr-to-reward-cycles succeeds but map-set stacking-state fails, can this create orphaned reward cycle entries without corresponding stacker state? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Return Value] The function returns unlock-burn-height to the node for locking - if this value is calculated incorrectly, does the node enforce a different unlock height than the contract expects? (Critical)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Lock Period Maximum] check-pox-lock-period validates lock-period <= MAX_POX_REWARD_CYCLES (12) - but can add-pox-addr-to-reward-cycles handle exactly 12 cycles without list size errors? (High)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [Caller Permission] check-caller-allowed permits contract-caller if allowance exists - can a malicious contract repeatedly call stack-stx to DOS the stacker's account? (Medium)",
  "[File: stacks-core/stackslib/src/chainstate/stacks/boot/pox-2.clar] [Function: stack-stx()] [PoX Rejection] minimal-can-stack-stx checks (is-none (get-pox-rejection tx-sender first-reward-cycle)) - can a user stack-stx and then reject-pox in the same transaction to game the system? (High)"
]