[
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Range Gap] Can there be gaps between range_end of one sample and range_start of the next, leaving parts of the [0, 2^256-1] space uncovered and causing some VRF hashes to match no candidate? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Accumulator Overflow] Can burn_acc at line 391 overflow when adding sample_step.burns, even though it's Uint512, if an attacker submits enough burns to exceed 2^512? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Last Range End] The last sample's range_end should equal Uint256::max(), but does the fixed-point division guarantee this, or can it be slightly less, creating a gap at the end of the range space? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_sortition_ranges()] [Uint512 to Uint256 Conversion] Can the to_uint256() conversion at line 393 lose precision or overflow when the upper 256 bits of the Uint512 result are non-zero? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: get_total_burns()] [Overflow Detection] The try_fold at lines 413-417 checks for overflow with checked_add, but can it miss overflow cases where u128 burns exceed u64::MAX during the u64::try_from conversion at line 415? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: get_total_burns()] [u128 to u64 Conversion] If any sample_point.burns exceeds u64::MAX, the try_from at line 415 returns None, but is this the correct behavior, or should it saturate or error more explicitly? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: get_total_burns()] [Fold Accumulation] Can the fold operation accumulate burns in a different order on different nodes if burn_dist is not deterministically ordered, causing None to be returned inconsistently? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: get_total_burns()] [Empty Distribution] If burn_dist is empty, the function returns Some(0), but can downstream code handle a zero total_burns value, or does it cause division by zero in make_sortition_ranges? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: LinkedCommitIdentifier::burn_fee()] [Missed Commit Burns] Missed commits always return burn_fee of 1 at line 82, but can an attacker spam missed commits to manipulate median calculations since they're included in all_burns at line 269? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: LinkedCommitIdentifier::spent_txid()] [UTXO Reference] Can the spent_txid reference at lines 68 and 70 be manipulated to point to non-existent txids, causing the UTXO chain validation to incorrectly succeed or fail? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: LinkedCommitIdentifier::spent_output()] [Output Index] Can the spent output index at lines 75 and 77 be manipulated to bypass the expected_chained_utxo check by using values that happen to match the expected index for different commit types? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: LinkedCommitIdentifier::txid()] [Txid Collision] If two different LinkedCommitIdentifiers (one Missed, one Valid) share the same txid, can this cause HashMap collisions in cur_commits_map or cur_missed_map that lead to incorrect chaining? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Median Even Window] For even window_size at lines 281-284, the median is (sorted_burns[w/2] + sorted_burns[w/2-1]) / 2, but can this cause bias if attackers know the window size and strategically place burns at specific positions? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Median Odd Window] For odd window_size at line 286, the median is sorted_burns[w/2], but does this correctly handle window_size of 1 without panicking during indexing? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Sorted Burns] The sorted_burns vector at line 280 is created by cloning all_burns, but can the sort() operation at line 280 be non-deterministic across different platforms or Rust versions, causing consensus divergence? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Burn Value Influence] Can a miner manipulate their effective burn by submitting very high burns in early blocks and low burns in recent blocks, exploiting the min(median, most_recent) formula to cap their cost while maintaining median influence? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: sanity_check_window()] [Window Size Limit] The assertion at line 113 checks that block_commits.len() is at most mining_commitment_window, but can this be violated if mining_commitment_window is reduced mid-consensus and existing commits exceed the new limit? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: sanity_check_window()] [Length Mismatch] The assertion at line 115 requires missed_commits.len() + 1 == block_commits.len(), but can this be violated during prepare phases or PoX transitions where the window collapses? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: sanity_check_window()] [Block Height Order] The assertion at lines 122-125 checks that commits are in block height order, but can this be violated if commits are received out of order due to network delays or reorgs? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Reverse Iteration] The iteration at line 199 goes in reverse (0..(window_size-1)).rev(), but can this cause issues if window_size is 1, making the range empty? (Medium)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Index Calculation] The index calculation (window_size - 1 - rel_block_height) at line 251 can underflow if rel_block_height >= window_size, but is this prevented by the loop bounds? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Burn Blocks Length] The assertion at line 181 checks burn_blocks.len() == block_commits.len(), but can misalignment cause wrong UTXO indices to be used for chaining validation? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [PoB vs PoX] The burn_blocks[rel_block_height] lookup at line 216 determines if commits are PoB-only, but can incorrect values in this vector cause miners to use wrong UTXO indices and break chains? (Critical)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Sunset Boundary] Can the burn_blocks vector incorrectly classify blocks around PoX sunset boundaries, causing miners to chain to wrong UTXO indices as shown in the test at lines 585-591? (High)",
  "[File: stackslib/src/chainstate/burn/distribution.rs] [Function: make_min_median_distribution()] [Frequency Accuracy] The frequency counter at lines 291-299 increments for each non-None commit, but does this accurately reflect a miner's participation if they have gaps in their UTXO chain? (Medium)"
]