[
  "[File: stackslib/src/net/server.rs] [Function: process_connecting_sockets()] [Event Ready Spurious Wakeup] If an event in poll_state.ready is not actually ready (spurious wakeup), can removing from connecting and attempting register_http() at line 515 fail, causing connection loss? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: process_ready_sockets()] [Rogue Socket Warning] When a rogue socket is detected at line 544, it's logged as debug at line 545; can an attacker trigger many rogue socket warnings to fill logs or should this be rate-limited? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: flush_conversations()] [Keep-Alive Resource Leak] Keep-alive connections are not closed at line 589 even if drained; if clients never close their keep-alive connections, can this cause unbounded resource accumulation over time? (High)",
  "[File: stackslib/src/net/server.rs] [Function: run()] [Timeout Clearing Timing] Timeouts are cleared at line 634 after flush_conversations(); if a timed-out request is still in the flush queue, can clearing the timeout allow a late response to be sent, violating timeout semantics? (Medium)",
  "[File: stackslib/src/net/server.rs] [Function: connect_http()] [Address Resolution] The addr parameter at line 123 is expected to be resolved; if the caller passes an unresolved address or DNS-based address, can connection fail or connect to the wrong host? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: count_inbound_ip_addrs()] [Empty Conversations] If a conversation exists in self.peers but has invalid or null peer_addr, can get_peer_addr().ip() at line 156 panic or return unexpected values? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: can_register_http()] [Max Clients Type] max_http_clients is compared against u64 values at lines 171 and 183; what is the actual type of max_http_clients, and can type conversion cause truncation or incorrect comparisons? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: register_http()] [ConversationHttp Initialization] If ConversationHttp::new() at line 243 fails to properly initialize internal buffers or state, can subsequent operations on the conversation trigger panics or undefined behavior? (Medium)",
  "[File: stackslib/src/net/server.rs] [Function: deregister_http()] [Multiple Deregister Calls] If deregister_http() is called multiple times for the same event_id (e.g., from different error paths), does each call safely handle missing entries via None matches at lines 286 and 292? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: disconnect_unresponsive()] [Concurrent Disconnection] If disconnect_unresponsive() runs while other code is processing the same conversations, can the removal at line 335 cause use-after-free or iterator invalidation in the other code? (High)",
  "[File: stackslib/src/net/server.rs] [Function: saturate_http_socket()] [Socket Mutability] client_sock is &mut mio::net::TcpStream; can multiple concurrent calls to saturate_http_socket() on the same socket (from different threads) cause data races or corruption? (Critical)",
  "[File: stackslib/src/net/server.rs] [Function: process_new_sockets()] [Network State Consistency] If network_state.register() succeeds at line 380 but subsequent checks fail (e.g., event_id collision), is network_state properly cleaned up at line 397, or can this leave stale registrations? (Medium)",
  "[File: stackslib/src/net/server.rs] [Function: process_http_conversation()] [Message Type Safety] The Vec<StacksMessageType> returned at line 493 contains messages from HTTP sources; if StacksMessageType includes consensus-critical messages, can HTTP clients forge block headers or transactions? (Critical)",
  "[File: stackslib/src/net/server.rs] [Function: process_connecting_sockets()] [Data URL Cloning] data_url is cloned at line 520 and passed to register_http(); if the URL contains sensitive data or is very large, can this cloning cause performance issues or memory exhaustion? (Low)",
  "[File: stackslib/src/net/server.rs] [Function: process_ready_sockets()] [Message Vector Growth] The msgs vector grows unbounded at line 564 as conversations are processed; if one conversation generates gigabytes of messages, can this cause out-of-memory errors? (High)",
  "[File: stackslib/src/net/server.rs] [Function: flush_conversations()] [Connection Closure Order] Conversations are added to close list at lines 587 and\n\n### Citations\n\n**File:** stackslib/src/net/server.rs (L1-1283)\n```rust\n// Copyright (C) 2013-2020 Blockstack PBC, a public benefit corporation\n// Copyright (C) 2020-2023 Stacks Open Internet Foundation\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nuse std::collections::HashMap;\n\nuse mio::net as mio_net;\nuse stacks_common::types::net::{PeerAddress, PeerHost};\nuse stacks_common::util::get_epoch_time_secs;\n\nuse crate::net::connection::*;\nuse crate::net::http::*;\nuse crate::net::httpcore::*;\nuse crate::net::p2p::PeerNetwork;\nuse crate::net::poll::*;\nuse crate::net::rpc::*;\nuse crate::net::{Error as net_error, *};\n\n#[derive(Debug)]\npub struct HttpPeer {\n    /// ongoing http conversations (either they reached out to us, or we to them)\n    pub peers: HashMap<usize, ConversationHttp>,\n    pub sockets: HashMap<usize, mio_net::TcpStream>,\n\n    /// outbound connections that are pending connection\n    pub connecting: HashMap<\n        usize,\n        (\n            mio_net::TcpStream,\n            Option<UrlString>,\n            Option<StacksHttpRequest>,\n            u64,\n        ),\n    >,\n\n    /// server network handle\n    pub http_server_handle: usize,\n\n    /// server socket address\n    pub http_server_addr: SocketAddr,\n\n    /// connection options\n    pub connection_opts: ConnectionOptions,\n}\n\nimpl HttpPeer {\n    pub fn new(\n        conn_opts: ConnectionOptions,\n        server_handle: usize,\n        server_addr: SocketAddr,\n    ) -> HttpPeer {\n        HttpPeer {\n            peers: HashMap::new(),\n            sockets: HashMap::new(),\n\n            connecting: HashMap::new(),\n            http_server_handle: server_handle,\n            http_server_addr: server_addr,\n\n            connection_opts: conn_opts,\n        }\n    }\n\n    pub fn set_server_handle(&mut self, h: usize, addr: SocketAddr) {\n        self.http_server_handle = h;\n        self.http_server_addr = addr;\n    }\n\n    /// Is there a HTTP conversation open to this data_url that is not in progress?\n    #[cfg_attr(test, mutants::skip)]\n    pub fn find_free_conversation(&self, data_url: &UrlString) -> Option<usize> {\n        for (event_id, convo) in self.peers.iter() {\n            if let Some(url) = convo.get_url() {\n                if url == data_url && !convo.is_request_inflight() {\n                    return Some(*event_id);\n                }\n            }\n        }\n        None\n    }\n\n    /// Get a mut ref to a conversation\n    #[cfg_attr(test, mutants::skip)]\n    pub fn get_conversation(&mut self, event_id: usize) -> Option<&mut ConversationHttp> {\n        self.peers.get_mut(&event_id)\n    }\n\n    /// Get a mut ref to a conversation and its socket\n    pub fn get_conversation_and_socket(\n        &mut self,\n        event_id: usize,\n    ) -> (\n        Option<&mut ConversationHttp>,\n        Option<&mut mio::net::TcpStream>,\n    ) {\n        (\n            self.peers.get_mut(&event_id),\n            self.sockets.get_mut(&event_id),\n        )\n    }\n\n    /// Connect to a new remote HTTP endpoint, given the data URL and a (resolved) socket address to\n    /// its origin.  Once connected, optionally send the given request.\n    /// Idempotent -- will not re-connect if already connected and there is a free conversation channel open\n    /// (will return Error::AlreadyConnected with the event ID)\n    pub fn connect_http(\n        &mut self,\n        network_state: &mut NetworkState,\n        network: &PeerNetwork,\n        data_url: UrlString,\n        addr: SocketAddr,\n        request: Option<StacksHttpRequest>,\n    ) -> Result<usize, net_error> {\n        if let Some(event_id) = self.find_free_conversation(&data_url) {\n            let http_nk = NeighborKey {\n                peer_version: network.burnchain.peer_version,\n                network_id: network.local_peer.network_id,\n                addrbytes: PeerAddress::from_socketaddr(&addr),\n                port: addr.port(),\n            };\n            return Err(net_error::AlreadyConnected(event_id, http_nk));\n        }\n\n        let sock = NetworkState::connect(\n            &addr,\n            network.connection_opts.socket_send_buffer_size,\n            network.connection_opts.socket_recv_buffer_size,\n        )?;\n        let hint_event_id = network_state.next_event_id()?;\n        let next_event_id =\n            network_state.register(self.http_server_handle, hint_event_id, &sock)?;\n\n        self.connecting.insert(\n            next_event_id,\n            (sock, Some(data_url), request, get_epoch_time_secs()),\n        );\n        Ok(next_event_id)\n    }\n\n    /// How many conversations are connected from this IP address?\n    fn count_inbound_ip_addrs(&self, peer_addr: &SocketAddr) -> u64 {\n        let mut count = 0;\n        for (_, convo) in self.peers.iter() {\n            if convo.get_url().is_none() && convo.get_peer_addr().ip() == peer_addr.ip() {\n                count += 1;\n            }\n        }\n        count\n    }\n\n    /// Can we register this socket?\n    #[cfg_attr(test, mutants::skip)]\n    fn can_register_http(\n        &self,\n        peer_addr: &SocketAddr,\n        outbound_url: Option<&UrlString>,\n    ) -> Result<(), net_error> {\n        if outbound_url.is_none()\n            && (self.peers.len() as u64) + 1 > self.connection_opts.max_http_clients\n        {\n            // inbound\n            debug!("
]