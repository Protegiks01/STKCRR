[
  "[File: stackslib/src/core/mempool.rs] [Function: update_bloom_counter()] [Saturation Eviction] When num_recents >= MAX_BLOOM_COUNTER_TXS, the lowest-fee transaction is evicted. Could an attacker submit many low-fee transactions to evict legitimate high-value transactions from the bloom filter, preventing mempool sync? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: prune_bloom_counter()] [Removed Txids Table] Transactions are added to removed_txids after being removed from bloom counter. If this table grows unbounded, could it cause performance degradation or database bloat? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: update_mempool_pager()] [Hash Collision] The hashed_txid is computed using Sha512Trunc256Sum. Could a hash collision cause two different transactions to have the same hashed_txid, breaking the randomized paging order? (Low)",
  "[File: stackslib/src/core/mempool.rs] [Function: make_mempool_sync_data()] [Tag vs Bloom Filter Threshold] The code switches from TxTags to BloomFilter at max_tx_tags threshold (default 2048). Could an attacker manipulate mempool size to force expensive bloom filter operations or trigger edge cases in sync protocol? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: get_bloom_txids()] [Height Calculation] Uses max_height.saturating_sub(BLOOM_COUNTER_DEPTH). If max_height is 0 or 1, could this return incorrect transaction sets, causing mempool sync failures? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: static_find_next_missing_transactions()] [Removed Txids Filter] The query filters out transactions in removed_txids table. Could a transaction be in removed_txids but not in mempool, causing the sync logic to skip valid transactions that should be propagated? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: decode_tx_stream()] [Page ID Parsing] The function expects an optional 32-byte page ID at the end of the transaction stream. Could a maliciously crafted stream with a partial page ID cause the parser to misinterpret transaction data as a page ID? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: parse_mempool_query_page_id()] [Unexpected EOF Handling] If pos == retry_reader.position() after UnexpectedEof, returns Ok(None). Could a precisely crafted empty stream cause infinite loops in pagination logic? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Constant: BLOOM_COUNTER_DEPTH] [Window Size Security] Set to 2 blocks. Could this small window cause valid transactions to be removed from the bloom filter too quickly, breaking mempool sync for nodes with slight delays? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Deadline Enforcement] The iteration stops when elapsed time exceeds max_walk_time_ms. Could a transaction with expensive validation executed just before the deadline cause significant deadline overrun, delaying block production? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Strategy Selection] NextNonceWithHighestFeeRate vs GlobalFeeRate strategies have different re-query behavior. Could switching strategies mid-iteration due to configuration changes cause transactions to be skipped or processed twice? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Null Fee Rate Sampling] In GlobalFeeRate strategy, transactions with NULL fee_rate are randomly sampled based on consider_no_estimate_tx_prob. Could an attacker exploit this by submitting many no-estimate transactions, diluting the probability that legitimate transactions are considered? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Candidate Cache Size] CandidateCache has max_cache_size limit. When full, push() silently drops transactions. Could this cause high-fee transactions with temporarily high nonces to be permanently lost from consideration? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Transaction Type Filter] The txs_to_consider HashSet filters transaction types. Could this filter be exploited to prevent certain transaction types from being mined, even if they have high fees? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Origin Filter] The filter_origins HashSet restricts which origin addresses are considered. If misconfigured, could this permanently prevent legitimate users from having their transactions mined? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Considered Txs Table] Transactions are added to considered_txs table to avoid re-processing. If this table is never cleared between iterations, could it cause transactions to be skipped indefinitely? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Nonce Cache Flush Timing] nonce_cache.flush() is called between outer loop iterations. Could unflushed changes cause the next query to use stale nonce values from the database? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [State Changed Flag] The outer loop continues if state_changed is true and stop_reason is NoMoreCandidates. Could a bug where state_changed is incorrectly set to false cause premature termination? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [SQL Query Limit] The NextNonceWithHighestFeeRate query has LIMIT 11650 (MAX_BLOCK_TXS). Could this limit cause transactions beyond position 11650 to never be considered, even if earlier transactions become invalid? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Random Fee Rate] For NULL fee_rate transactions, the query assigns random fee rates. Could this randomness cause non-deterministic transaction ordering across different nodes, leading to different blocks being produced? (Critical)",
  "[File: stackslib/src/core/mempool.rs] [Function: iterate_candidates()] [Transaction Deserialization] tx_info is obtained via MemPoolDB::get_tx() which deserializes the transaction. Could a maliciously crafted transaction in the database cause deserialization failures that crash the iteration? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: inner_blacklist_txs()] [Blacklist Size Check] The function inserts without checking current blacklist size. Could rapid blacklisting exceed blacklist_max_size before garbage_collect_tx_blacklist runs, causing unbounded memory growth? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: garbage_collect_tx_blacklist()] [Random Deletion] When blacklist exceeds max_size, entries are deleted at random. Could this delete recently blacklisted problematic transactions, allowing them to be immediately resubmitted? (High)",
  "[File: stackslib/src/core/mempool.rs] [Function: is_tx_blacklisted()] [Timeout Calculation] Checks if now < arrival_time + timeout. Could integer overflow in this addition cause blacklisted transactions to become un-blacklisted prematurely? (Medium)",
  "[File: stackslib/src/core/mempool.rs] [Function: drop_and_blacklist_txs()] [Bloom Filter Persistence] The comment states transactions are NOT removed from bloom filter. Could this cause the bloom filter to grow unbounded as blacklisted transactions accumulate over time? (Medium)"
]