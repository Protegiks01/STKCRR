[
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_decode_ascii()] [Final Carry Truncation] At line 271, when carry_bits > 0, `carry as u8` is pushed. If carry contains more than 8 bits due to overflow, can the truncation lose data or create non-deterministic decoding? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: double_sha256_checksum()] [Empty Data Checksum] What is the double-SHA256 of an empty byte array? Is this checksum value [0x5d, 0xf6, 0xe0, 0xe2]? Can an attacker exploit this known value to create malicious addresses? (Low)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode()] [Version in Checksum] At line 305, version is prepended to data before checksumming. At line 314, version is prepended to the final output. Can an attacker swap the version between these two operations in a modified client to pass checksum validation with the wrong version? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Checksum Extraction] At line 337, `data_sum_bytes.split_at(data_sum_bytes.len() - 4)` assumes len >= 5 (checked at line 333). For len == 5, data_bytes is 1 byte. Is a 1-byte address payload valid in the Stacks protocol? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_decode()] [Checksum Byte Order] At lines 344-352, the checksum bytes are combined into u32 with little-endian byte order (byte0 | byte1<<8 | byte2<<16 | byte3<<24). Is this consistent with the checksum computation in double_sha256_checksum()? (High)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address() / c32_address_decode()] [Network Identifier] The 'S' prefix is hardcoded. Are there different prefixes for different Stacks networks (mainnet, testnet, regtest)? If so, is the lack of prefix validation in c32_address_decode() a consensus risk? (Critical)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_check_encode() / c32_check_decode()] [Version Semantics] Version values 0-31 are valid. What do these versions represent in the Stacks protocol (e.g., P2PKH, P2SH, etc.)? Can mixing version types cause protocol violations? (Medium)",
  "[File: stacks-core/stacks-common/src/address/c32.rs] [Function: c32_address_decode()] [Canonical Representation] If an address can be decoded successfully with lowercase 's' or mixed case, but c32_address() always produces uppercase 'S', can this cause signature verification failures if the signed data includes the non-canonical address? (High)"
]