[
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: reset_cache()] [Consensus Divergence] When the cache detects corruption and calls reset_cache(), all in-memory nonces are cleared and the database table is deleted. Could this cause nodes to accept transactions with stale nonces if the MARF has been updated but the cache was reset, leading to consensus divergence between nodes that hit corruption at different times? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: reset_cache()] [Data Loss] The reset_cache() function ignores database deletion errors by only logging a warning. If the DELETE FROM nonces fails silently, could this leave stale nonces in the database that get loaded later, causing incorrect nonce validation and potential double-spend? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Race Condition] When cache.get() detects corruption at line 81-84, it calls reset_cache() and continues execution. If multiple threads detect corruption simultaneously, could concurrent reset_cache() calls cause database corruption or leave the cache in an inconsistent state? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Nonce Reuse] After reset_cache() is called due to cache corruption, the function continues to query the database. If the database still contains stale data (because DELETE failed), could this return an outdated nonce that's already been used on-chain, enabling transaction replay? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Error Handling] When db_get_nonce() fails at line 88-91, the error is logged but None is returned. Could this cause the function to query the MARF unnecessarily, and if the MARF is also unavailable, could it return nonce 0 for accounts that actually have non-zero nonces, allowing nonce reuse attacks? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Cache Inconsistency] When a nonce is retrieved from the database at line 92-108, it's inserted into the in-memory cache as 'clean' data. If another thread modifies the MARF nonce before this insertion completes, could the cache contain a stale nonce that prevents newer transactions from being accepted? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Eviction During Read] At lines 95-106, if inserting a database-retrieved nonce causes an eviction, the evicted entry is flushed back to the database. Could this create a circular dependency where reading causes writes, and if the database is locked, could this cause deadlock or cache thrashing? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Corruption Recovery Failure] If cache.insert_clean() fails with corruption at line 95-101 and reset_cache() is called, the function returns db_nonce without re-inserting it into the now-empty cache. Could subsequent get() calls for the same address hit the database repeatedly, causing performance degradation and increased lock contention? (Medium)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Stale MARF Read] When querying the chainstate at line 111, there's no verification that the clarity_tx represents the current canonical tip. Could this return a nonce from a different fork, and if that nonce is cached, could it cause the mempool to accept or reject transactions incorrectly? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: get()] [Unconditional Cache] After retrieving a nonce from the MARF at line 111-114, it's immediately set in the cache via self.set(). If the MARF query failed or returned an error that was coerced to 0, could this permanently cache an incorrect nonce value of 0 for an account? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: set()] [Nonce Rollback] The set() function at lines 119-132 unconditionally overwrites nonces in the cache. If called with a lower nonce value than currently cached (e.g., due to a fork switch), could this allow already-used nonces to be reused, enabling double-spend attacks? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: set()] [Corruption Recovery During Set] If cache.insert() fails at line 120-126 and reset_cache() is called, the evicted value becomes Some((address, value)). This is then passed to flush_with_evicted(). Could this cause the corrupted value to be written to the database, propagating corruption? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: set()] [Eviction Handling] When an eviction occurs at line 120-121, flush_with_evicted() is called with the evicted entry. If the flush operation hangs or fails repeatedly, could this block the calling thread indefinitely, causing denial of service in transaction processing? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: set()] [Missing Validation] The set() function accepts any u64 value without validation. Could an attacker craft transactions that cause the mempool to call set() with u64::MAX, and would this cause integer overflow when the nonce is incremented for the next transaction? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: flush_with_evicted()] [Infinite Loop] The flush_with_evicted() function at lines 136-160 retries indefinitely with exponential backoff until success. If the database is permanently locked or corrupted, could this cause the thread to hang forever, preventing any further transaction processing? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: flush_with_evicted()] [Backoff Cap] The exponential backoff is capped at 30 seconds at line 137. If database lock contention persists, could the repeated 30-second waits cause the mempool to become unresponsive, preventing the node from accepting new transactions and causing consensus delays? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: flush_with_evicted()] [Clone Cost] The evicted parameter is cloned on each retry iteration at line 141. For high-contention scenarios requiring many retries, could this repeated cloning of StacksAddress and u64 cause unnecessary memory allocation overhead and performance degradation? (Low)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: flush_with_evicted()] [Thread Sleep] The function sleeps the current thread at line 150. If this is called from a critical consensus path or the mempool admission thread, could sleeping block other essential operations and cause the node to fall behind in block processing? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: flush_with_evicted()] [No Timeout] There's no maximum retry count or total timeout for the retry loop. Could an adversary trigger database lock conditions (e.g., via resource exhaustion attacks) to force nodes into infinite retry loops, causing denial of service? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: try_flush_with_evicted()] [Transaction Atomicity] The flush operation starts a database transaction at line 171 but doesn't explicitly set isolation level or use BEGIN IMMEDIATE. Could this allow concurrent transactions to interleave, causing lost updates if two flushes for the same address execute simultaneously? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: try_flush_with_evicted()] [Evicted Write Order] The evicted entry is written to the database at line 173-175 before flushing the main cache. If the cache.flush() operation fails or returns corruption, could the evicted entry remain in the database while the cache is reset, creating inconsistency? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: try_flush_with_evicted()] [Partial Flush] If cache.flush() at line 177-189 fails partway through the flush operation (e.g., database error after writing some but not all entries), could this leave some nonces in the database and others only in memory, causing divergence when the cache is reloaded? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: try_flush_with_evicted()] [Transaction Drop on Corruption] When FlushError::LruCacheCorrupted is detected at line 182-187, the transaction is dropped without committing, then reset_cache() is called. Could this drop the transaction after the evicted entry was already written, leaving partial data in the database? (High)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: try_flush_with_evicted()] [Commit Failure] If tx.commit() fails at line 191, the error is propagated. However, the in-memory cache has already been marked as flushed by cache.flush(). Could this cause the cache to believe data was persisted when it wasn't, leading to data loss on node restart? (Critical)",
  "[File: stacks-core/stackslib/src/core/nonce_cache.rs] [Function: try_flush_with_evicted()] [INSERT OR REPLACE Semantics] The SQL uses INSERT OR REPLACE at line 169. If the nonce table has additional constraints or triggers, could the REPLACE operation delete and re-insert rows in a way that violates referential integrity or causes unexpected side effects? (Medium)"
]