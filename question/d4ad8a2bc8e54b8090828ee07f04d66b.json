[
  "[File: stackslib/src/net/atlas/db.rs] [Function: insert_instantiated_attachment()] [Transaction Ordering] If the UPDATE fails but INSERT succeeds (or vice versa due to partial transaction commit), could the database have an attachment without corresponding available instances or vice versa? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: find_uninstantiated_attachment()] [Hash Encoding Inconsistency] The function converts Hash160 to hex for lookup - if attachment.hash() uses a different encoding in insert operations, could valid attachments never be found? (Critical)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: find_attachment()] [Instantiation Flag Bypass] The query requires was_instantiated = 1 - could an attacker downgrade an instantiated attachment to uninstantiated by calling INSERT OR REPLACE with was_instantiated = 0? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: should_keep_attachment()] [Contract Allowlist Bypass] If atlas_config.contracts is empty, all attachments are rejected - could an attacker cause DoS by manipulating config to have empty contracts list? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: should_keep_attachment()] [Size Check Type Mismatch] Comparing attachment.content.len() as u32 with atlas_config.attachments_max_size - could attachments with length > u32::MAX bypass size validation due to truncation? (Critical)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: count_uninstantiated_attachments()] [COUNT Overflow] query_count returns usize cast to u32 - if there are more than u32::MAX uninstantiated attachments, could the count wrap and break eviction logic? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: count_unresolved_attachment_instances()] [COUNT Overflow] Similar to count_uninstantiated_attachments, could u32 overflow if instance count exceeds u32::MAX? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Attachment struct] [Content Validation] The Attachment struct has no validation on content - could an attacker insert malformed or malicious binary data that crashes parsers when attachments are retrieved and deserialized? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: queue_attachment_instance()] [Status Initialization] New instances are always set to Queued with is_available = false - if an attachment with this content_hash already exists, should is_available be true immediately? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: insert_initial_attachment_instance()] [Batch Validation] Instances from initial batch are marked Checked and available = true without verifying the attachment exists - could this create orphaned instances? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: insert_attachment_instance()] [INSERT OR REPLACE Semantics] Using INSERT OR REPLACE on the (index_block_hash, contract_id, attachment_index) primary key - could this silently overwrite existing instances, losing created_at timestamp and download history? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: insert_attachment_instance()] [Timestamp Overwrite] On INSERT OR REPLACE, created_at is always set to now - could an attacker repeatedly re-insert instances to reset their age and prevent expiration? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: mark_attachment_instance_checked()] [Missing Transaction] The UPDATE executes directly on conn without a transaction - could partial updates leave instances in inconsistent states if the operation is interrupted? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: mark_attachment_instance_checked()] [WHERE Clause Insufficiency] The WHERE clause uses (index_block_hash, contract_id, attachment_index) but doesn't verify current status = Queued - could Checked instances be incorrectly updated? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: queued_attachments()] [MAX_PROCESS_PER_ROUND Limit] Limiting results to 1000 entries could cause starvation if queued instances accumulate faster than they're processed - is there a mechanism to detect this condition? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: queued_attachments()] [Ordering Ambiguity] The query SELECT * WHERE status = Queued doesn't specify ORDER BY - could non-deterministic ordering cause different nodes to process instances in different orders? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: find_unresolved_attachment_instances()] [Double Filter] Query filters by is_available = 0 AND status = Checked - but shouldn't Queued instances also be considered unresolved? Is this a logic error? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: find_all_attachment_instances()] [Status Filter] Only returns instances with status = Checked - could important Queued instances with the same content_hash be missed? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: evict_expired_unresolved_attachment_instances()] [Timestamp Overflow] Similar to evict_expired_uninstantiated_attachments, could overflow in 'now - expire_after' calculation cause incorrect eviction? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: evict_expired_unresolved_attachment_instances()] [Available Filter] Only deletes instances with is_available = 0 - but if an instance becomes available later, is created_at updated or could old available instances accumulate? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [AttachmentInstance Primary Key] [Collision Attack] An attacker could create multiple attachments in the same block with the same contract_id and attachment_index to cause primary key collisions - is attachment_index validated to be unique per contract per block? (Critical)",
  "[File: stackslib/src/net/atlas/db.rs] [AttachmentInstanceStatus enum] [Missing Variants] Only Queued (1) and Checked (2) are defined - if database contains other integer values (0, 3, etc.), FromSql returns OutOfRange error, but are these errors handled gracefully? (Medium)",
  "[File: stackslib/src/net/atlas/db.rs] [AttachmentInstanceStatus ToSql/FromSql] [Integer Representation] Status is stored as i64 in SQL but only uses values 1 and 2 - could storing large i64 values cause problems if the schema is later extended? (Low)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: get_minmax_heights_window_for_page_index()] [Integer Overflow] The calculation 'page_index * ATTACHMENTS_INV_PAGE_SIZE' could overflow u32 if page_index is large - is there validation on page_index? (High)",
  "[File: stackslib/src/net/atlas/db.rs] [Function: get_minmax_heights_window_for_page_index()] [Overflow in Max Calculation] The calculation '(page_index + 1) * ATTACHMENTS_INV_PAGE_SIZE' could overflow u32, causing min > max and breaking query logic? (High)"
]