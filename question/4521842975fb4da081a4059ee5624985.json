[
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: CHAIN_ID_MAINNET, CHAIN_ID_TESTNET] [Consensus Divergence] Could an attacker craft transactions that are valid on both mainnet (0x00000001) and testnet (0x80000000) networks if chain ID validation is not strictly enforced during transaction deserialization, potentially enabling replay attacks across networks? (Critical)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: CHAIN_ID_MAINNET, CHAIN_ID_TESTNET] [Transaction Replay] Does the bit pattern difference (bit 31 set for testnet) between CHAIN_ID_MAINNET and CHAIN_ID_TESTNET provide sufficient protection against replay attacks if other parts of the codebase perform bitwise operations that could inadvertently clear or set this bit? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: CHAIN_ID_MAINNET] [Integer Overflow] If chain ID values are used in arithmetic operations elsewhere in the codebase, could the value 0x00000001 cause unexpected behavior when combined with other network identifiers or version numbers through bitwise OR/AND operations? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: PEER_VERSION_MAINNET_MAJOR, PEER_VERSION_TESTNET_MAJOR] [Network Partition] Could a malicious node advertise a modified peer version (e.g., 0x18000000 with different epoch byte) that passes initial validation but causes consensus divergence when processing epoch-specific rules? (Critical)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: PEER_NETWORK_EPOCH] [Version Downgrade Attack] If PEER_NETWORK_EPOCH is set to PEER_VERSION_EPOCH_3_2 (0x0d) but a node accepts connections from peers advertising older epochs, could an attacker force the network to downgrade to vulnerable epoch rules by controlling enough peer connections? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: PEER_VERSION_MAINNET, PEER_VERSION_TESTNET] [Bitwise Operation Error] Does the bitwise OR operation (PEER_VERSION_MAINNET_MAJOR | PEER_NETWORK_EPOCH) correctly preserve both the major version and epoch byte, or could bit collisions occur if PEER_NETWORK_EPOCH grows beyond 0xFF, potentially corrupting the version field? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constants: PEER_VERSION_EPOCH_* series] [Consensus Incompatibility] Are all epoch version constants (0x00 through 0x0e) guaranteed to be unique and monotonically increasing? Could duplicate or misordered values cause nodes to incorrectly determine peer compatibility and fragment the network? (Critical)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: PEER_VERSION_TESTNET_MAJOR] [Magic Number Collision] Could the testnet major version 0xfacade00 collide with legitimate version numbers or debug markers in other parts of the protocol, potentially causing testnet transactions to be accepted on mainnet if validation checks are incomplete? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: NETWORK_ID_MAINNET, NETWORK_ID_TESTNET] [Network Identification] Could an attacker craft network messages with modified network IDs (0x17000000 vs 0xff000000) that pass initial parsing but cause nodes to mix mainnet and testnet state, leading to consensus failures or fund loss? (Critical)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: NETWORK_ID_MAINNET] [Bit Pattern Vulnerability] Does the network ID value 0x17000000 have any mathematical relationship with peer version or chain ID values that could be exploited through bitwise operations to bypass network isolation checks? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: TOKEN_TRANSFER_MEMO_LENGTH] [Buffer Overflow] If TOKEN_TRANSFER_MEMO_LENGTH is set to 34 bytes for Stacks v1 compatibility, could transaction deserialization code that reads memo fields without proper bounds checking allow buffer overflows when processing memos that claim to be 34 bytes but provide more data? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: TOKEN_TRANSFER_MEMO_LENGTH] [Consensus Divergence] If the memo length limit (34 bytes) is enforced differently across validation contexts (mempool admission vs. block validation), could an attacker include a transaction with an oversized memo that is accepted into some nodes' mempools but rejected during block validation, causing miner rewards to be lost? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: TOKEN_TRANSFER_MEMO_LENGTH] [Deterministic Serialization] Does the 34-byte memo length constant account for UTF-8 encoding edge cases where certain character sequences could be interpreted differently across systems, potentially breaking serialization determinism? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: BITCOIN_REGTEST_FIRST_BLOCK_HASH] [Burnchain Validation] Could the all-zeros genesis hash (0x00...00) for regtest mode collide with actual Bitcoin block hashes or internal sentinel values used elsewhere, causing burnchain validation to accept invalid blocks in regtest mode? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: BITCOIN_REGTEST_FIRST_BLOCK_HEIGHT, BITCOIN_REGTEST_FIRST_BLOCK_TIMESTAMP] [Integer Underflow] If regtest mode uses height 0 and timestamp 0 as first block values, could arithmetic operations that subtract from these values (e.g., calculating relative heights or time windows) cause integer underflows leading to incorrect block validation? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: FIRST_STACKS_BLOCK_HASH] [Genesis Validation] Could the all-zeros genesis block hash (BlockHeaderHash([0u8; 32])) be exploited by an attacker who generates a malicious block with a hash collision targeting this sentinel value, potentially allowing replacement of the genesis block in certain validation contexts? (Critical)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: FIRST_BURNCHAIN_CONSENSUS_HASH] [Burnchain Anchoring] If FIRST_BURNCHAIN_CONSENSUS_HASH is ConsensusHash([0u8; 20]), could validation code that uses this as a special case marker incorrectly accept fabricated burnchain data that happens to hash to all zeros? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: MINER_REWARD_MATURITY] [Conditional Compilation] Does the conditional compilation that sets MINER_REWARD_MATURITY to 2 for tests but 100 for production create a risk that test builds could be accidentally deployed to mainnet, allowing miners to spend rewards after only 2 blocks instead of 100? (Critical)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: MINER_REWARD_MATURITY] [PoX Reward Timing] If MINER_REWARD_MATURITY is set to 100 blocks, could an off-by-one error in reward maturity checks allow miners to access rewards at block 99 instead of 100, violating the protocol's economic security model? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: MINER_REWARD_MATURITY] [Integer Overflow] Could the maturity constant (100) be added to block heights in validation code without overflow checks, potentially wrapping around for blocks near u64::MAX and incorrectly marking immature rewards as spendable? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: STACKS_EPOCH_MAX] [Integer Boundary] If STACKS_EPOCH_MAX is defined as i64::MAX cast to u64, could code that performs signed/unsigned conversions inadvertently interpret this as a negative value, causing epoch comparisons to fail and reject valid blocks? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: STACKS_EPOCH_MAX] [Overflow Protection] Does using i64::MAX as u64 (0x7FFFFFFFFFFFFFFF) instead of u64::MAX provide sufficient headroom to prevent overflow in epoch arithmetic, or could adding small values to blocks near STACKS_EPOCH_MAX still cause wrapping? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: SIGNER_SLOTS_PER_USER] [StackerDB Capacity] Could the hardcoded value of 13 slots per signer be exceeded by malicious signers who attempt to claim more slots in StackerDB for DKG and block validation, potentially causing denial of service or consensus failures? (High)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Constant: SIGNER_SLOTS_PER_USER] [Integer Multiplication] If SIGNER_SLOTS_PER_USER (13) is multiplied by the number of active signers without overflow checks, could a large signer set cause integer overflow when calculating total required StackerDB slots, leading to buffer allocation failures? (Medium)",
  "[File: stacks-core/stacks-common/src/libcommon.rs] [Test: signer_slots_count_2_5()] [Constant Validation] Does the test assertion that verifies SIGNER_SLOTS_PER_USER equals 13 prevent accidental changes that would break Epoch 2.5 .signers contract instantiation? If this constant is increased without corresponding contract changes, could it cause consensus divergence between nodes running different code versions? (Critical)"
]