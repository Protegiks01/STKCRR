[
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: SYSTEM_FORK_SET_VERSION] [Consensus Divergence] Could modifying SYSTEM_FORK_SET_VERSION at line 45 after network deployment cause a chain split if different nodes use different fork set versions when mixing with consensus hashes? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BURNCHAIN_TX_SEARCH_WINDOW] [DoS] Could setting BURNCHAIN_TX_SEARCH_WINDOW at line 61 to an extremely small value (e.g., 1) cause nodes to miss critical burnchain operations during reorgs, leading to sortition disagreements? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: TX_BLOCK_LIMIT_PROPORTION_HEURISTIC] [Mempool Policy] Could an attacker exploit the TX_BLOCK_LIMIT_PROPORTION_HEURISTIC value at line 69 (20%) by crafting transactions that consistently trigger block limit at exactly 20% capacity, causing legitimate transactions to be incorrectly dropped from mempool? (Medium)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: INITIAL_MINING_BONUS_WINDOW] [Reward Distribution] Could the difference between test (10) and production (10,000) values for INITIAL_MINING_BONUS_WINDOW at lines 77-79 create a reward calculation mismatch if test code accidentally runs in production, leading to incorrect miner compensation? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: STACKS_2_0_LAST_BLOCK_TO_PROCESS] [Chain Processing] Could the hardcoded STACKS_2_0_LAST_BLOCK_TO_PROCESS value at line 81 (700,000) cause consensus failure if nodes disagree on when to stop processing Stacks 2.0 blocks during migration? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: MAINNET_2_0_GENESIS_ROOT_HASH] [State Verification] Could an incorrect or modified MAINNET_2_0_GENESIS_ROOT_HASH at lines 82-83 allow an attacker to present a fraudulent genesis state that passes validation? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: FIRST_BURNCHAIN_CONSENSUS_HASH] [Consensus Hash] Could using a non-zero FIRST_BURNCHAIN_CONSENSUS_HASH value instead of the all-zeros hash at line 86 create consensus issues when validating the earliest burnchain blocks? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constants: Bitcoin Heights] [Epoch Activation] Could an off-by-one error in any of the Bitcoin mainnet epoch activation heights (lines 89-111) cause nodes to activate epochs at different times, leading to a permanent chain fork? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BITCOIN_MAINNET_STACKS_31_BURN_HEIGHT] [Epoch Timing] Could the specific height value for BITCOIN_MAINNET_STACKS_31_BURN_HEIGHT at line 107 (875,000) be manipulated during config if it doesn't align with reward cycle boundaries as required by Nakamoto transition rules? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BITCOIN_TESTNET_STACKS_30_BURN_HEIGHT] [Testnet Divergence] Could the extremely high testnet epoch heights at lines 125-128 (30,000,000+) cause integer overflow issues when calculating reward cycles or epoch differences? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: FIRST_STACKS_BLOCK_HASH] [Genesis Block] Could using a non-zero FIRST_STACKS_BLOCK_HASH value instead of the all-zeros hash at line 135 break fork choice logic that depends on this sentinel value? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: EMPTY_MICROBLOCK_PARENT_HASH] [Microblock Validation] Could an attacker forge microblocks with a zero-hash parent (EMPTY_MICROBLOCK_PARENT_HASH at line 136) to bypass parent validation checks? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BOOT_BLOCK_HASH] [Boot Block] Could using 0xff-filled BOOT_BLOCK_HASH at line 143 instead of 0x00-filled create collisions with legitimate block hashes that happen to have all-ones pattern? (Medium)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BURNCHAIN_BOOT_CONSENSUS_HASH] [Boot Consensus] Could the 0xff-filled BURNCHAIN_BOOT_CONSENSUS_HASH at line 144 conflict with actual consensus hashes and cause validation bypass? (Medium)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constants: POX_SUNSET_START/END] [PoX Sunset] Could manipulating POX_SUNSET_START (100,000) or POX_SUNSET_END (500,000) at lines 146-147 allow an attacker to prematurely disable or indefinitely extend PoX stacking mechanisms? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: POX_PREPARE_WINDOW_LENGTH] [PoX Timing] Could setting POX_PREPARE_WINDOW_LENGTH to an incorrect value (currently 100 at line 149) cause stacking transactions to be accepted or rejected at wrong times in the reward cycle? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: POX_REWARD_CYCLE_LENGTH] [PoX Cycle] Could modifying POX_REWARD_CYCLE_LENGTH from 2100 (line 150) after network launch cause catastrophic reward cycle desynchronization between nodes? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: POX_MAXIMAL_SCALING] [Reward Scaling] Could setting POX_MAXIMAL_SCALING to a value higher than 4 (line 156) allow attackers with low participation to receive disproportionately inflated PoX rewards? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: POX_THRESHOLD_STEPS_USTX] [Threshold Calculation] Could the POX_THRESHOLD_STEPS_USTX value at line 158 (10,000 STX in microSTX) create rounding errors in threshold adjustments that accumulate over time? (Medium)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: POX_MAX_NUM_CYCLES] [Stacking Duration] Could setting POX_MAX_NUM_CYCLES to 12 at line 160 be bypassed by submitting multiple overlapping stacking transactions to lock funds for more than 12 cycles total? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constants: POX_V1/V2/V3_EARLY_UNLOCK_HEIGHT] [Unlock Timing] Could off-by-one errors in POX_V1_MAINNET_EARLY_UNLOCK_HEIGHT (line 166-167) or similar constants cause premature or delayed unlocking of stacked STX? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: NAKAMOTO_SIGNER_BLOCK_APPROVAL_THRESHOLD] [Nakamoto Consensus] Could lowering NAKAMOTO_SIGNER_BLOCK_APPROVAL_THRESHOLD below 7/10 (70%) at line 183 enable a minority of malicious signers to approve invalid blocks? (Critical)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BLOCK_LIMIT_MAINNET_10] [Epoch 1.0 Limits] Could the all-zero ExecutionCost in BLOCK_LIMIT_MAINNET_10 at lines 186-192 be exploited if Epoch 1.0 validation logic is accidentally invoked in later epochs? (Medium)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BLOCK_LIMIT_MAINNET_20] [Block Limits] Could an attacker craft transactions that maximize all five cost dimensions (write_length: 15MB, write_count: 7,750, read_length: 100MB, read_count: 7,750, runtime: 5B) simultaneously at lines 195-201 to cause DoS? (High)",
  "[File: stacks-core/stackslib/src/core/mod.rs] [Constant: BLOCK_LIMIT_MAINNET_205] [Cost Increase] Could the doubled write_count and read_count values in BLOCK_LIMIT_MAINNET_205 (15,000 each at lines 204-210) enable new attack vectors not possible in Epoch 2.0? (Medium)"
]