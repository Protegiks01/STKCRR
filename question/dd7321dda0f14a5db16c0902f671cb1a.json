[
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: set-burnchain-parameters()] [Access Control] Can set-burnchain-parameters be called multiple times through a race condition if two transactions check the configured flag before either sets it, allowing an attacker to reconfigure critical consensus parameters after initialization? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: set-burnchain-parameters()] [Integer Overflow] Can arithmetic overflow occur when setting pox-reward-cycle-length or first-burnchain-block-height with extremely large uint values, causing incorrect reward cycle calculations throughout the contract? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: set-burnchain-parameters()] [Validation] Can rejection-fraction be set to values greater than 100, causing is-pox-active to produce incorrect results and potentially disable PoX when it should be active? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: set-burnchain-parameters()] [Validation] Can prepare-cycle-length be set to zero, causing division by zero or unexpected behavior in reward cycle boundary calculations? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: burn-height-to-reward-cycle()] [Integer Underflow] Can passing a height less than first-burnchain-block-height cause integer underflow in the subtraction operation, leading to incorrect reward cycle calculations or runtime abort? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: burn-height-to-reward-cycle()] [Division by Zero] If pox-reward-cycle-length is set to zero through misconfiguration, can this function cause a division by zero runtime error, halting all stacking operations? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: reward-cycle-to-burn-height()] [Integer Overflow] Can multiplying cycle by pox-reward-cycle-length overflow for very large cycle numbers, returning incorrect burn heights and causing stacking lock periods to be miscalculated? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: reward-cycle-to-burn-height()] [Integer Overflow] Can adding the multiplication result to first-burnchain-block-height cause overflow, leading to wraparound to small values and incorrect unlock height calculations? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-pox-addr-version()] [Validation Bypass] Can buff-to-uint-be return unexpected values for malformed buffers longer than expected, allowing invalid address versions greater than MAX_ADDRESS_VERSION to pass validation? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-pox-addr-hashbytes()] [Validation] Can hashbytes with length between 20 and 32 bytes pass validation if the version check logic has off-by-one errors in the boundary conditions? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-pox-addr-hashbytes()] [Logic Error] For version values between MAX_ADDRESS_VERSION_BUFF_20 and MAX_ADDRESS_VERSION_BUFF_32, can both length checks (20 and 32) fail, incorrectly rejecting valid P2WSH/P2TR addresses? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-pox-addr-hashbytes()] [Edge Case] Can a hashbytes buffer of exactly 32 bytes with trailing zeros be accepted for version 0x04, allowing an attacker to stack to an invalid P2WPKH address with extra bytes? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: is-pox-active()] [Integer Overflow] Can multiplying u100 by reject-votes overflow for extremely large rejection amounts, causing the comparison to incorrectly evaluate PoX as active when it should be disabled? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: is-pox-active()] [Integer Overflow] Can multiplying pox-rejection-fraction by stx-liquid-supply overflow, causing incorrect threshold calculation and allowing PoX to remain active despite sufficient rejection votes? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: is-pox-active()] [Logic Error] Does the < comparison instead of <= allow PoX to be disabled at exactly the threshold rather than requiring votes to exceed it, creating an off-by-one vulnerability in consensus rules? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: get-stacker-info()] [State Consistency] Can the lock expiry check use <= instead of < for comparing current cycle to expiry, causing stacker info to be returned as valid for one extra cycle after it should expire? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: get-stacker-info()] [Integer Overflow] Can adding first-reward-cycle and lock-period overflow for maximum lock periods, causing the expiry check to incorrectly return stale stacking info as valid? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-caller-allowed()] [Access Control] Can the >= comparison for expiry checking allow an expired contract caller to execute one additional transaction at exactly the expiry burn height? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: check-caller-allowed()] [Logic Error] If until-burn-ht is set to u0, will the allowance be treated as expired or unexpired, potentially allowing a permanent bypass of caller restrictions? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: get-check-delegation()] [Access Control] Can the > comparison for expiry checking allow a delegation to be used one extra block after it expires if burn-block-height equals until-burn-ht? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: get-check-delegation()] [Edge Case] If until-burn-ht is none, can a delegation created with zero amounts or invalid fields persist indefinitely without expiration? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: append-reward-cycle-pox-addr()] [Integer Overflow] Can incrementing the reward set size (+ u1 sz) overflow when sz is at maximum uint value, causing the length counter to wrap to zero and corrupting the reward set? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: append-reward-cycle-pox-addr()] [State Consistency] If get-reward-set-size returns a stale value due to concurrent modifications, can multiple entries be written to the same index, overwriting existing reward addresses? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: append-reward-cycle-pox-addr()] [Denial of Service] Can an attacker repeatedly call stacking functions to append entries until the reward set size exceeds practical limits, causing iteration operations to consume excessive resources? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/pox-3.clar] [Function: fold-unlock-reward-cycle()] [State Corruption] Can the unwrap-panic on map-get reward-cycle-pox-address-list cause a runtime abort if the entry was already deleted by a concurrent unlock operation? (Critical)"
]