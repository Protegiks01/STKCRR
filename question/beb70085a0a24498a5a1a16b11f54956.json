[
  "[File: stackslib/src/net/http/request.rs] [Function: get_header()] [Header Retrieval Logic] At lines 184-200, get_header() special-cases reserved headers but uses to_lowercase() on the key - is there a TOCTOU issue where a header could be added with mixed case but retrieved with different casing? (Low)",
  "[File: stackslib/src/net/http/request.rs] [Function: get_content_length()] [Default Value Semantics] At line 206, missing content_length returns 0 - can an attacker exploit this by omitting Content-Length to bypass size checks that expect non-zero values for requests with bodies? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: HttpRequestPayload::content_length()] [JSON Serialization Overflow] At lines 479-481, JSON is serialized to compute content_length as u32 - can an attacker provide a deeply nested JSON structure that serializes to more than u32::MAX bytes, causing integer overflow or truncation? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: HttpRequestPayload::content_length()] [Cast Overflow] At lines 481-485, lengths are cast directly to u32 using 'as u32' - can an attacker provide Vec<u8> or String payloads larger than 4GB that overflow when cast, causing content_length to wrap around to a small value? (Critical)",
  "[File: stackslib/src/net/http/request.rs] [Function: HttpRequestPayload::content_length()] [String UTF-8 Length Mismatch] At line 485, string length is calculated using as_bytes().len() - is this always equal to the serialized length, or can UTF-8 encoding differences cause mismatches? (Low)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Non-Deterministic Ordering] At line 294, write_headers() is called on self.headers which is a BTreeMap - is the iteration order guaranteed deterministic across all Rust versions and platforms for consensus-critical serialization? (Critical)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [HTTP Version String Injection] At lines 235-244, HTTP version strings are hardcoded as 'HTTP/1.0' and 'HTTP/1.1' - but is self.version validated anywhere, or can an attacker construct an HttpRequestPreamble with an invalid enum variant that causes serialization issues? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Verb Injection] At lines 228-229, self.verb is serialized directly without validation - can an attacker construct a request with a verb containing CRLF sequences or spaces that create malformed HTTP requests? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Path Injection] At lines 232-233, path_and_query_str is serialized without validation - can an attacker inject CRLF, spaces, or control characters that break HTTP request formatting? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Host Format Injection] At line 249, self.host is formatted using format!() - does PeerHost's Display implementation sanitize against injection attacks, or can a malformed PeerHost inject headers? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Content-Type Serialization] At lines 255-262, content_type is serialized using to_string() - is this deterministic across all HttpContentType variants, or could two nodes serialize the same content-type differently? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Content-Length Formatting] At line 268, content_length is formatted using format!() - is u32 string formatting guaranteed deterministic (no locale-specific separators), or could nodes in different locales format numbers differently? (Low)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Keep-Alive Logic Mismatch] At lines 275-288, keep-alive serialization logic differs between HTTP/1.0 and HTTP/1.1 - can an attacker exploit this asymmetry to create requests that serialize differently than they deserialize? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: consensus_serialize()] [Accept Header Injection] At line 290, default_accept_header() is written without validation - can an attacker modify the default accept header to inject malicious content? (Low)",
  "[File: stackslib/src/net/http/request.rs] [Function: parse_qs()] [Query String DoS] At lines 529-537, form_urlencoded::parse() is called on an arbitrary query string - can an attacker send extremely long query strings with thousands of parameters to exhaust memory or CPU? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: parse_qs()] [Parameter Overwrite] At lines 532-533, parameters are inserted into a HashMap - if the same key appears multiple times in the query string, does the last value overwrite previous values, and is this behavior exploitable? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: parse_qs()] [URL Encoding Bypass] Can an attacker use double URL encoding or malformed percent-encoding in the query string at line 532 to bypass parameter validation performed on the decoded values? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: query_string()] [Query Argument Collision] At lines 541-544, new query arguments are extended into existing ones - can an attacker exploit this to overwrite previously parsed query arguments from the path, leading to parameter injection? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: get_full_query_string()] [Query String Reconstruction] At lines 661-668, query arguments are re-serialized using form_urlencoded - is the reconstructed query string guaranteed to be identical to the original, or could round-trip encoding differences cause consensus issues? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: HttpRequestPayload::send()] [JSON Serialization Determinism] At line 493, serde_json::to_writer() is used for JSON payloads - is JSON object key ordering guaranteed deterministic across serde_json versions, or could nodes serialize JSON maps differently? (Critical)",
  "[File: stackslib/src/net/http/request.rs] [Function: HttpRequestPayload::send()] [Write Error Handling] At lines 490-497, write errors are converted to Error types - but are partial writes handled correctly, or could a write failure leave the connection in an inconsistent state? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: payload_json()] [JSON Injection] At line 549, arbitrary serde_json::Value is accepted without validation - can an attacker inject malicious JSON that exploits downstream parsing or causes excessive memory allocation? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: try_payload_json_ref()] [Shared JSON Bytes] At lines 560-566, JSON is serialized once and shared via Arc - but if the JSON serialization is non-deterministic, could different nodes produce different Arc contents for the same logical value? (High)",
  "[File: stackslib/src/net/http/request.rs] [Function: path_arg()] [Path Argument Overwrite] At line 589, path arguments are inserted without checking for duplicates - can an attacker exploit request processing that calls path_arg() multiple times to overwrite critical path parameters? (Medium)",
  "[File: stackslib/src/net/http/request.rs] [Function: query_arg()] [Query Argument Overwrite] At line 595, query arguments are inserted without checking for duplicates - similar to path_arg(), can this be exploited to override validated query parameters? (Medium)"
]