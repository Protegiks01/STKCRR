[
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [Consensus Bypass] Can an attacker manipulate the `preserve` HashSet to prevent pruning of malicious peers, causing the node to maintain connections only to attacker-controlled peers and potentially accepting invalid blocks? (Critical)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [DoS - Resource Exhaustion] If `self.events` contains a very large number of event IDs and all are checked against `preserve`, can this cause O(n*m) complexity leading to node hang during pruning? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [State Inconsistency] If `self.peers.get(event_id)` returns `None` but the event_id exists in `self.events`, what invariant is violated and can this lead to incorrect org distribution calculations? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [Database Race Condition] Can a race condition between `PeerDB::get_peer()` call and peer deletion from database cause incorrect organization assignments or panics when unwrapping peer data? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [Organization ID Manipulation] Can an attacker control the `peer.org` value returned from PeerDB to cluster all their peers under org ID 0 or u32::MAX to evade per-org connection limits? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [Memory Exhaustion] If a single org ID has thousands of neighbors due to organization ID collision, can the `Vec<(NeighborKey, NeighborStats)>` grow unbounded causing OOM? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [Filter Bypass] By setting `convo.stats.outbound = false` for connections that are actually outbound, can an attacker prevent their peers from being counted in outbound org distribution? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: org_neighbor_distribution()] [Database Error Handling] If `PeerDB::get_peer()` returns a `DBError`, the function propagates it - can repeated database errors during pruning prevent the node from ever pruning connections, leading to resource exhaustion? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Time Manipulation] If `stats.first_contact_time` is in the future (greater than `get_epoch_time_secs()`), can the subtraction at line 110 cause integer underflow, producing extremely large uptime values that prevent pruning? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Time Wraparound] When epoch time wraps around (e.g., year 2038 problem or u64 overflow), can negative uptime calculations cause the log2 function to panic or produce incorrect bucket assignments? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Logarithm Edge Case] If `uptime_1` or `uptime_2` is 0 or negative, can `log2()` return NaN or negative infinity, causing the `fmax!` macro to produce unexpected results in bucket calculation? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Randomness Predictability] The function uses `thread_rng()` to break ties - can an attacker who controls timing of peer connections predict the RNG state to influence which peers get pruned? (Low)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Health Score Manipulation] If `stats.get_health_score()` can be manipulated by the peer (e.g., by responding to pings), can an attacker keep unhealthy peers from being pruned by artificially inflating health scores? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Uptime Bucketing Bias] The geometric bucketing by powers of 2 means a node with 1 second uptime is in the same bucket as one with 2 seconds - can an attacker exploit this to keep recently-connected malicious peers by staying in low uptime buckets? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: compare_neighbor_uptime_health()] [Floating Point Precision] Can the conversion from integer seconds to f64 at line 110-111 lose precision for very large uptime values, causing incorrect bucket assignments for long-running peers? (Low)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: sample_org_by_neighbor_count()] [Division by Zero] If all organizations in `org_weights` have count 0, the total at line 149 would be 0, causing `rng.gen_range(0..0)` to panic - is this case properly prevented by callers? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: sample_org_by_neighbor_count()] [Unreachable Panic] The function ends with `unreachable!()` at line 164 - under what conditions can the loop complete without returning, and would this cause a node crash during pruning? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: sample_org_by_neighbor_count()] [Sampling Bias] If the random sample equals `offset + count` boundary (line 159), can off-by-one errors cause the last organization to never be selected or selected twice as often? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: sample_org_by_neighbor_count()] [Integer Overflow] If the sum of all `count` values exceeds usize::MAX when accumulating `total`, can overflow cause incorrect sampling distribution or panic? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: sample_org_by_neighbor_count()] [RNG Manipulation] Can an attacker who observes the timing of peer pruning events predict the `thread_rng()` seed to influence which organizations get sampled for pruning? (Low)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: sample_org_by_neighbor_count()] [Empty HashMap] If `org_weights` is empty, what happens to the `total` calculation and can this cause the `unreachable!()` to be reached? (Medium)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: prune_frontier_outbound_orgs()] [Connection Limit Bypass] If `num_outbound` equals `self.connection_opts.soft_num_neighbors`, the function returns early at line 176 - can an attacker maintain exactly this number of connections to prevent any pruning? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: prune_frontier_outbound_orgs()] [Preserve Set Bypass] Can an attacker add all their malicious peers to the `preserve` set to prevent them from ever being pruned, even if they dominate the peer table? (Critical)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: prune_frontier_outbound_orgs()] [Integer Underflow] At line 219, `saturating_sub` is used for prune_count calculation - but if this always returns 0 due to saturation, can it prevent pruning of overrepresented orgs? (High)",
  "[File: stacks-core/stackslib/src/net/prune.rs] [Function: prune_frontier_outbound_orgs()] [Off-by-One Error] The loop at line 223 uses `take(prune_count)` and then removes with `neighbor_infos.remove(0)` at line 242 - can misalignment between iterations and removals cause incorrect peers to be pruned? (Medium)"
]