[
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_try_ret()] [Cost Model] Try-return charges constant runtime: u1000 - this operation checks for error and returns early if found, so should it cost more than simple unwrap due to the early return mechanism, or is constant cost appropriate? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_contract_call()] [Cost Model] Contract-call charges constant runtime: u1000 - cross-contract calls involve context switching, parameter marshaling, and callee execution, so is u1000 adequate for just the call overhead, or should the base cost be much higher to prevent call spam? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_contract_of()] [Cost Model] Contract-of operation charges constant runtime: u1000 - this likely extracts the contract principal from a trait reference, but does constant cost properly account for potential trait resolution or lookup operations? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_principal_of()] [Cost Model] Principal-of charges constant runtime: u1000 for extracting principal from public key - does this include the cryptographic operations to derive the principal, or is that charged separately, and could this be undercharged if derivation is expensive? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_at_block()] [Cost Accounting] At-block operation charges constant runtime: u1000 with read_count: u1 and read_length: u1 - evaluating expressions in a historical block context could require loading old state, so is this adequate, or could querying ancient blocks be undercharged? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_at_block()] [DoS] With constant cost regardless of how far back the historical block is, can an attacker repeatedly query very old blocks (requiring deep MARF traversal or disk seeks) to cause I/O DoS while staying within execution cost limits? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_as_max_len()] [Cost Model] As-max-len charges constant runtime: u1000 for sequence type casting - is this just compile-time type checking that's actually free at runtime, or does it involve runtime validation that could be more expensive for large sequences? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_print()] [Cost Model] Print uses linear(n, u1000, u1000) where n is likely the data size being printed - does this account for serialization cost, or just the I/O cost, and could printing complex nested structures be undercharged if serialization is expensive? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_analysis_use_trait_entry()] [Cost Accounting] This function charges read_count: u1 and read_length: (linear n u1 u1) for trait usage - if n is the trait definition size, does reading the trait from storage at coefficient u1 per byte adequately reflect deserialization and validation costs? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_analysis_use_trait_entry()] [Cost Model] The function has write_length: (linear n u1 u1) but write_count: u0 - what is being written (analysis metadata?) and why is write_count zero when write_length scales with n, creating an inconsistency? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_analysis_get_function_entry()] [Cost Consistency] This charges read_length: (linear n u1 u1) for function lookup while cost_lookup_function charges only constant runtime: u1000 - are these for different phases (analysis vs runtime), and is the analysis phase properly charging for function metadata reads? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_analysis_fetch_contract_entry()] [Cost Model] Fetching a contract entry during analysis uses the same cost model as get_function_entry - if fetching contracts is more expensive than fetching functions due to size, should contract fetching have a higher coefficient than u1 per byte? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_analysis_iterable_func()] [Cost Model] This uses linear(n, u1000, u1000) - what does n represent here (number of iterations analyzed?), and could analyzing deeply nested iteration patterns be more than linear complexity, causing undercharging? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_analysis_option_cons()] [Cost Asymmetry] Option construction during analysis charges constant runtime: u1000 while runtime cost_some_cons also charges u1000 - should analysis-time type checking cost more or less than runtime allocation? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: poison_microblock()] [Cost Model] Poisoning a microblock charges constant runtime: u1000 with read and write operations - given that this is a critical consensus operation that involves cryptographic proof verification, is constant cost adequate, or should it be much higher to prevent poisoning spam? (High)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: poison_microblock()] [Cost Accounting] The function charges write_count: u1 and read_count: u1 with constant lengths - what state is being read and written (poison report storage?), and does this properly account for the on-chain record of the poisoning event? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: poison_microblock()] [Consensus Implications] If poison_microblock is undercharged, could an attacker repeatedly poison valid microblocks at low cost to disrupt block production, and does the constant cost create an economic attack vector against microblock producers? (Critical)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_block_info()] [Cost Model] Block-info query charges constant runtime: u1000 with single read operation - does this assume block info is cached in memory, or if it requires MARF traversal or disk I/O, could querying block info become a DoS vector? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_stx_balance()] [Cost Model] STX balance lookup charges constant runtime: u1000 with single read - if balance requires reading from the MARF and deserializing account state, is constant cost adequate, or could balance queries on accounts with complex state be undercharged? (Medium)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_ft_balance()] [Cost Consistency] FT balance charges the same constant cost as STX balance - is this appropriate, or might FT balances stored in contract state require more expensive lookups than native STX balances? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_ft_get_supply()] [Cost Model] Getting FT supply charges constant runtime: u1000 with single read - if supply is stored and updated separately from individual balances, is constant cost correct, or could supply lookups for some tokens be more expensive requiring multiple reads? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_int_cast()] [Cost Model] Integer casting charges constant runtime: u1000 - does this include validation that the cast doesn't lose precision or overflow, and could casting between different integer types (int to uint) involve expensive checking that's undercharged? (Low)",
  "[File: stackslib/src/chainstate/stacks/boot/costs.clar] [Function: cost_xor()] [Cost Model] XOR charges constant runtime: u1000 - for bitwise operations on 128-bit integers, is constant cost appropriate, or if XOR is applied to buffers/sequences, should it scale with input size like other buffer operations? (Low)"
]