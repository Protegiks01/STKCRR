[
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: make_getblocksinv()] [Assertion Failure] At line 1661, there's an assertion that `num_blocks <= self.burnchain.pox_constants.reward_cycle_length`. If get_getblocksinv_num_blocks returned a value exceeding this due to a bug, this would panic. Could a race condition in updating burnchain view cause this? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getpoxinv_try_finish()] [Divergence Handling] At lines 1858-1884, when a peer is Diverged after NACK, the function truncates inventories and proceeds with block scan. For bootstrap peers in IBD, it deepens the rescan at line 1874. However, if the divergence is due to the remote peer being ahead rather than on a different fork, could this truncation lose valid inventory data? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getpoxinv_try_finish()] [State Corruption] At lines 1898-1904, merge_pox_inv is called which can trigger truncate_block_inventories at line 1900-1903 if PoX bits flipped. The return value lowest_learned_reward_cycle indicates the lowest RC that flipped. However, if multiple RCs flipped in the PoxInv, only the lowest is returned. Could this cause incomplete truncation of block inventories for higher reward cycles that also flipped? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getpoxinv_try_finish()] [Uncertainty Logic] At lines 1929-1946, the function checks remote and local uncertainty. If either is not equal to `(pox_inv.bitlen as u64) + stats.target_pox_reward_cycle`, it truncates inventories at lines 1964-1969. However, what if the uncertainty is due to the remote peer being more certain than us? Should we truncate our inventory, or should we request more data? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getpoxinv_try_finish()] [Loop Continuation] At lines 1981-1985, if uncertainty was found, the PoX scan continues by incrementing pox_reward_cycle and resetting. However, the increment at line 1983 uses `pox_inv.bitlen as u64` which came from the remote peer. Could a malicious peer send a large bitlen to cause us to skip over many reward cycles in our scan, missing inventory data? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getblocksinv_try_finish()] [IBD Divergence] At lines 2043-2058, when in IBD and peer is Diverged, the function deepens the scan by subtracting inv_reward_cycles from block_reward_cycle. The saturating_sub at line 2047 prevents underflow, but if inv_reward_cycles is very large, this could reset block_reward_cycle to 0. Could an attacker exploit this to cause excessive rescanning? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getblocksinv_try_finish()] [State Machine Skip] At line 2064, if the peer is not online, the function returns Ok(false) which keeps the loop running. However, line 2063 sets stats.done = true. This seems contradictory - done=true but returning false to continue. Could this cause the state machine to get stuck? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getblocksinv_try_finish()] [Counter Logic] At lines 2092-2095, if new blocks or microblocks were learned, learned_data is set and learned_data_height is updated. However, line 2094 uses cmp::min to keep the lowest height. If this function is called multiple times with different target heights, could the learned_data_height become stale, pointing to an old height that's no longer relevant? (Low)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_getblocksinv_try_finish()] [Scan Continuation] At lines 2099-2104, the scan continues if block_reward_cycle is less than num_inventory_reward_cycles. However, line 2103 increments block_reward_cycle after checking target_block_reward_cycle. Could there be an off-by-one error where we check target vs num_inventory but increment block, causing us to miss the last reward cycle? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_sync_run()] [Infinite Loop] The while loop at line 2128 continues while !stats.done. However, if any of the state handlers fails to advance the state or set done=true, this could loop forever. Are there timeout protections or iteration limits to prevent this? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: inv_sync_run()] [State Transition] At lines 2136-2153, each state is handled. If a handler returns Err, it's propagated up, but if it returns Ok(false), the loop breaks at line 2155. Could an attacker cause a handler to repeatedly return Ok(false) without advancing state, causing the sync to appear to make progress but never complete? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: refresh_sortition_view()] [Race Condition] At lines 2174-2188, new PoX ID is loaded if burnchain_tip.sortition_id differs from tip_sort_id. Between lines 2174 and 2180, another thread could update burnchain_tip. Could this cause new_tip_sort_id and new_pox_id to be from different tips, creating an inconsistent state? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: refresh_sortition_view()] [Inventory Invalidation] At lines 2196-2209, if a PoX bit flipped from 0 to 1, all block inventories at and after that reward cycle are invalidated. However, the loop at line 2196 only checks up to the minimum of old and new PoX vector lengths. If the new vector is longer, could there be flipped bits beyond num_reward_cycles that aren't checked? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: refresh_sortition_view()] [Header Cache Clear] At line 2207, the entire header_cache is cleared when any PoX bit flips. This is noted as pessimistic. Could an attacker trigger frequent PoX bit flips (by causing reorgs or forks) to force cache clearing, degrading performance? (Low)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: refresh_sortition_view()] [Vector Shrinkage] At lines 2213-2216, if the new PoX vector is shorter than the old one, inventories are invalidated. However, this uses `new_pox_id.len() as u64` to determine the cutoff. If len() returns 0, this would invalidate all inventories. Could a corrupted or malformed PoX ID cause this? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: sync_inventories_epoch2x()] [Throttling Logic] At lines 2255-2268, the function returns early with throttle=true if certain conditions are met. However, this prevents any inventory synchronization. Could an attacker manipulate timing (via last_rescanned_at) or hint flags to keep the node perpetually throttled, preventing it from learning about new blocks? (High)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: sync_inventories_epoch2x()] [IBD Divergence Height] At line 2323, ibd_diverged_height is set when a bootstrap peer diverges during IBD. This becomes the hint for where to start downloads at line 2367. If an attacker controls a bootstrap peer and repeatedly causes divergences, could they force the node to repeatedly re-download from very early heights, preventing it from ever catching up? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: sync_inventories_epoch2x()] [Peer Selection] At lines 2428-2465, the function selects peers to sync with. Bootstrap peers are always included at lines 2457-2459 during IBD. If all bootstrap peers are malicious or diverged, this forces the node to sync only with malicious peers. Could this lead to consensus isolation? (Critical)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: sync_inventories_epoch2x()] [Lowest Block Reward Cycle] At lines 2360-2364, the lowest_block_reward_cycle is calculated across all peers using fold with cmp::min. If one peer has a corrupted block_reward_cycle value of 0, this would be selected as the minimum, causing block_sortition_start at line 2367 to be set very low. Could this cause excessive re-scanning? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: sync_inventories_epoch2x()] [State Machine Error Handling] At lines 2285-2305, various errors from inv_sync_run are handled. StaleView error sets hint_learned_data=true with height=u64::MAX at line 2293. Why u64::MAX instead of a specific height? Could this cause integer overflow issues in downstream code expecting a real height? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: get_block_scan_start()] [Stale Data] At lines 1770-1771, the canonical Stacks chain tip is queried. If this fails with Err, first_block_height is used at line 1776. However, the error is silently ignored. Could this cause us to start scanning from the very beginning when we should start from a later point, wasting resources? (Low)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: get_block_scan_start()] [Saturating Sub] At line 1788, saturating_sub is used to calculate inv_rescan_rc. If inv_reward_cycles is extremely large, this could saturate to 0, causing the rescan to start from reward cycle 0 every time. Could an attacker manipulate connection_opts.inv_reward_cycles to cause this? (Medium)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: get_block_scan_start()] [Minimum Selection] At line 1790, the result is the minimum of inv_rescan_rc and peer_block_reward_cycle. If peer_block_reward_cycle is 0 (e.g., for a new peer), this forces the scan to start at 0. Could this cause unnecessary rescanning when most peers are at higher reward cycles? (Low)",
  "[File: stackslib/src/net/inv/epoch2x.rs] [Function: set_data_available()] [PoX Validity] At lines 1201-1210, if the snapshot exists but pox_valid is false, the function returns Ok(None) to absorb the message. However, no warning is logged. Could an attacker send many BlocksAvailable messages for invalid PoX forks to silently waste our processing time? (Low)"
]